var tipuesearch = {"pages":[{"title":" LightConvex ","text":"LightConvex project_website: https://fortran-lang.github.io/fftpack/ favicon: doc/media/favicon.ico\nlicense: by-sa\nauthor: Jean-Christophe Loiseau\nauthor_pic: https://fortran-lang.org/assets/img/fortran_logo_512x512.png\nemail: jean-christophe.loiseau@ensam.eu\ngithub: https://github.com/loiseaujc\ntwitter: https://twitter.com/jcloiseau\nwebsite: https://loiseaujc.github.io\ndbg: true\nparallel: 4 project_website: https://fortran-lang.github.io/fftpack/ Fortran FFTPACK API Documentation LightConvex Description Road map Linear Programming Building LightConvex Fortran Package Manager (fpm) References Warning This API documentation for the Modern Fortran Edition of the quadprog solver is a work in progress. Fortran FFTPACK API Documentation This is the main API documentation landing page generated by FORD .\nThe documentation for comment markup in source code, running FORD and the FORD project file are all maintained on the FORD wiki . LightConvex Lightweight package for convex programming written in Modern Fortran. Status : Prototype Description LightConvex is an experiment about writing convex programming solvers in Modern Fortran. It aims at providing an easy-to-use API for solving both dense and sparse convex programs, including linear programs , e.g. and quadratic programs , e.g. where the inequalities are applied element-wise, and $P \\in \\mathbb{R}&#94;{n \\times n}$ is a symmetric positive semi-definite matrix.\nWhile we strive for an intuitive user interface, we do not compromise with computational performances and make extensive use of Modern Fortran constructs for the implementation of battle-tested algorithms. The current version of LightConvex focuses on designing the structure of the package and its interface. For that purpose, LightConvex is thus currently restricted to linear programs. Road map Linear Programming Linear programming (LP) is a method to achieve the best outcome (such as maximizing profit or minimizing cost) in a mathematical model whose requirements and objective are represented by linear relationships. The standard form of an LP reads with $c \\in \\mathbb{R}&#94;n$, $x \\in \\mathbb{R}&#94;n$, $A \\in \\mathbb{R}&#94;{m \\times n}$ (with $m \\leq n$) and $b \\in \\mathbb{R}&#94;m$. Although it may seem restrictive at first, all LP can be formulated in this format. Below is a tentative list of features to be included in the first working prototype of LightConvex : Support for dense LP [x] Standard primal simplex algorithm [ ] Standard dual simplex algorithm [ ] Revised dual simplex algorithm Support for sparse LP [ ] Primal simplex algorithm [ ] Revised dual simplex algorithm [ ] Primal Affine Scaling High-level interfaces [ ] problem = LP(c, A, b) for dense and sparse LP. [ ] solution = solve(problem, alg) for dense and sparse LP. Preprocessing [ ] Conversion of any LP into standard equality form [ ] Idiot Crash Algorithm Utilities [ ] (Compressed) MPS file reader Examples [ ] Max Flow / Min Cut Documentation [ ] In-code documentation [ ] Online documentation using FORD Continuous integration and documentation [ ] Unit tests based on the netlib LP test suite [x] CI based on setup-fortran-conda with fpm build system and automatic documentation with FORD [x] Add code coverage using codecov For the sake of simplicity, only double precision arithmetic is currently supported. Building LightConvex Fortran Package Manager ( fpm ) The library can be build with the Fortran Package Manager fpm using the provided fpm.toml like so: fpm build --release Only double precision ( real64 ) is currently supported. To use LightConvex within your fpm project, add the following line to your fpm.toml file: [dependencies] LightConvex = { git = \"https://github.com/loiseaujc/LightConvex.git\" } References Boyd, Stephen P., and Lieven Vandenberghe. Convex optimization. Cambridge university press, 2004.","tags":"home","url":"index.html"},{"title":"simplex – LightConvex","text":"public interface simplex Subroutines private pure module subroutine dense_standard_simplex(A, nleq, ngeq, neq, iposv, maxiter, info) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: A (:,:) Simplex tableau of dimension n+2 x m integer(kind=ilp), intent(in) :: nleq Number of constraints of each type. integer(kind=ilp), intent(in) :: ngeq Number of constraints of each type. integer(kind=ilp), intent(in) :: neq Number of constraints of each type. integer(kind=ilp), intent(out) :: iposv (:) Book-keeping for the primal and slack variables. integer(kind=ilp), intent(in) :: maxiter Maximum number of iterations. integer(kind=ilp), intent(out) :: info Return flag:\n - info = -1 : Problem is infeasible.\n - info = 0  : Optimal solution has been found.\n - info = 1  : Objective function is unbounded.","tags":"","url":"interface/simplex.html"},{"title":"LightConvex – LightConvex","text":"Uses stdlib_linalg_constants assert_m module~~lightconvex~~UsesGraph module~lightconvex LightConvex assert_m assert_m module~lightconvex->assert_m stdlib_linalg_constants stdlib_linalg_constants module~lightconvex->stdlib_linalg_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: lightconvex_lp module~~lightconvex~~UsedByGraph module~lightconvex LightConvex module~lightconvex_lp lightconvex_lp module~lightconvex_lp->module~lightconvex Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface simplex private pure module subroutine dense_standard_simplex(A, nleq, ngeq, neq, iposv, maxiter, info) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: A (:,:) Simplex tableau of dimension n+2 x m integer(kind=ilp), intent(in) :: nleq Number of constraints of each type. integer(kind=ilp), intent(in) :: ngeq Number of constraints of each type. integer(kind=ilp), intent(in) :: neq Number of constraints of each type. integer(kind=ilp), intent(out) :: iposv (:) Book-keeping for the primal and slack variables. integer(kind=ilp), intent(in) :: maxiter Maximum number of iterations. integer(kind=ilp), intent(out) :: info Return flag:\n - info = -1 : Problem is infeasible.\n - info = 0  : Optimal solution has been found.\n - info = 1  : Objective function is unbounded.","tags":"","url":"module/lightconvex.html"},{"title":"lightconvex_lp – LightConvex","text":"Uses stdlib_math stdlib_linalg stdlib_intrinsics Ancestors: LightConvex module~~lightconvex_lp~~UsesGraph module~lightconvex_lp lightconvex_lp module~lightconvex LightConvex module~lightconvex_lp->module~lightconvex stdlib_intrinsics stdlib_intrinsics module~lightconvex_lp->stdlib_intrinsics stdlib_linalg stdlib_linalg module~lightconvex_lp->stdlib_linalg stdlib_math stdlib_math module~lightconvex_lp->stdlib_math assert_m assert_m module~lightconvex->assert_m stdlib_linalg_constants stdlib_linalg_constants module~lightconvex->stdlib_linalg_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module/lightconvex_lp.html"},{"title":"lighthconvex_linearprograms.f90 – LightConvex","text":"This file depends on sourcefile~~lighthconvex_linearprograms.f90~~EfferentGraph sourcefile~lighthconvex_linearprograms.f90 lighthconvex_linearprograms.f90 sourcefile~lightconvex.f90 LightConvex.f90 sourcefile~lighthconvex_linearprograms.f90->sourcefile~lightconvex.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( lightconvex ) lightconvex_lp use stdlib_math , only : arange , swap use stdlib_linalg , only : outer_product use stdlib_intrinsics , only : sum => stdlib_sum implicit none ( external ) contains module procedure dense_standard_simplex integer ( ilp ) :: m , n !! Dimensions of the problem. !!  - m : Number of constraints (excluding the non-negativity). !!  - n : Number of variables (excluding the slack ones). integer ( ilp ) :: niter !! Current iteration number integer ( ilp ), allocatable :: izrov (:) !! Book-keeping for variables being zeroed-out. integer ( ilp ), dimension ( size ( A , 2 )) :: admissible_columns !! List of columns admissible for exchange. logical ( lk ), dimension ( ngeq ) :: in_basis !! List of >= constraints currently in the basis. ! Miscellaneous integer ( ilp ) :: nl1 , ip , kp , i , k , kh logical ( lk ) :: init real ( dp ) :: bmax !> Sanity checks. m = size ( A , 1 ) - 2 ; n = size ( A , 2 ) - 1 call assert ( assertion = m == nleq + ngeq + neq , & description = \"Tableau size is inconsistent with the number of constraints.\" ) call assert ( assertion = size ( iposv ) == m , & description = \"Dimension of iposv is inconsistant with the number of constraints.\" ) call assert ( assertion = all ( A ( 2 :, 1 ) >= 0.0_dp ), & description = \"Constants b_i need to be non-negative.\" ) !----- Initialization ----- ! Index list of columns admissible for exchange. nl1 = n ; admissible_columns (: n ) = arange ( n ) izrov = admissible_columns (: n ) ! All variables are initially right-hand. iposv = n + arange ( m ) ! Initial left-hand variables. <= constraints ! are represented by having their slacks left-hand with no artificial variable. ! >= constraints have their slack initially left-hand with a minus sign and their ! artificial variable handled implicitly during their first exchange. ! == constraints have their artificial variable initially left-hand. !---------------------------------------------- !----- Phase 1 : Find a feasible solution ----- !---------------------------------------------- init = . true . phase1 : do if ( init ) then if ( ngeq + neq == 0 ) exit phase1 init = . false . ! List of >= constraints whose slack has never been exchanged. in_basis = . true . ! Auxiliary objective function. A ( m + 2 , :) = - sum ( A ( nleq + 2 : m + 1 , :), dim = 1 ) end if if ( nl1 > 0 ) then ! Find the maximum coefficient of the auxiliary objective function. kp = maxloc ( A ( m + 2 , admissible_columns (: nl1 ) + 1 ), dim = 1 ) kp = admissible_columns ( kp ) bmax = A ( m + 2 , kp + 1 ) else bmax = 0.0_dp end if phase1a : do if (( bmax <= eps ) . and . ( A ( m + 2 , 1 ) < - eps )) then ! Auxiliary objective is still negative and can't be improved. ! No feasible solution exits. info = - 1 return else if (( bmax <= eps ) . and . ( A ( m + 2 , 1 ) <= eps )) then ! Auxiliary objective is zero and can't be improved. Feasible ! starting vector has been computed. Clean out the artificial ! variables corresponding to remaining equality constraints ! and exit phase one. do ip = nleq + ngeq + 1 , m if ( iposv ( ip ) == ip + n ) then if ( nl1 > 0 ) then kp = maxloc ( abs ( A ( ip + 1 , admissible_columns (: nl1 ) + 1 )), dim = 1 ) kp = admissible_columns ( kp ) bmax = A ( ip + 1 , kp + 1 ) else bmax = 0.0_dp end if if ( bmax > eps ) exit phase1a end if end do ! Change sign of row for any >= constraints still present from ! the initial basis. where ( spread ( in_basis , 2 , n + 1 ) . eqv . . true .) & A ( nleq + 2 : nleq + ngeq + 1 , :) = - A ( nleq + 2 : nleq + ngeq + 1 , :) exit phase1 end if ip = find_pivot ( A , kp ) if ( ip == 0 ) then ! No pivot has been found. Maximum of the auxiliary function ! is unbounded. info = 1 return end if exit phase1a end do phase1a ! Exchange a basic and non-basic variable. call exchange_variables ( A , ip , kp , m + 1 , n ) if ( iposv ( ip ) >= n + nleq + ngeq + 1 ) then ! Exchanged out an artifical variable for an equality constraint. ! Make sure it stays out by removing it from the l1 list. k = findloc ( admissible_columns (: nl1 ), kp , dim = 1 ) nl1 = nl1 - 1 admissible_columns ( k : nl1 ) = admissible_columns ( k + 1 : nl1 + 1 ) else kh = iposv ( ip ) - nleq - n ! Exchanged an >= constraints. if ( kh >= 1 ) then ! If it's the first time, correct the pivot column for the minus ! sign and the implicit artifical variable. if ( in_basis ( kh )) then in_basis ( kh ) = . false . A ( m + 2 , kp + 1 ) = A ( m + 2 , kp + 1 ) + 1.0_dp A (:, kp + 1 ) = - A (:, kp + 1 ) end if end if end if ! Book-keeping. call swap ( izrov ( kp ), iposv ( ip )); exit phase1 end do phase1 !------------------------------------------------------ !-----     Phase 2 : Compute optimal solution     ----- !------------------------------------------------------ niter = 0 phase2 : do while ( niter <= maxiter ) niter = niter + 1 if ( nl1 > 0 ) then kp = maxloc ( A ( 1 , admissible_columns (: nl1 ) + 1 ), dim = 1 ) kp = admissible_columns ( kp ) bmax = A ( 1 , kp + 1 ) else bmax = 0.0_dp end if if ( bmax <= eps ) then ! No more positive coefficient in the modified cost function. ! Solution is optimal. info = 0 return end if ip = find_pivot ( A , kp ) if ( ip == 0 ) then ! No pivot has been found. Objective function is unbounded. info = 1 return end if ! Exchange a basic and non-basic variable. call exchange_variables ( A , ip , kp , m , n ) ! Book-keeping. call swap ( izrov ( kp ), iposv ( ip )) end do phase2 ! Return information flag info = 2 if the maximum number of ! iterations has been reached. if ( niter > maxiter ) then info = 2 ; return end if end procedure dense_standard_simplex pure integer ( ilp ) function find_pivot ( A , k ) result ( ip ) real ( dp ), intent ( in ) :: A (:, :) !! Simplex tableau integer ( ilp ), intent ( in ) :: k !! Current column ! Internal variables real ( dp ) :: q , q0 , q1 , qp integer ( ilp ) :: i , j associate ( m => size ( A , 1 ) - 2 , n => size ( A , 2 ) - 1 ) ! Determine if a pivot exist. i = findloc ( A ( 2 : m + 1 , k + 1 ) < - eps , . true ., dim = 1 ) if ( i > m ) then ! No possible pivot. Problem is infeasible. ip = 0 ; return end if q1 = - A ( i + 1 , 1 ) / A ( i + 1 , k + 1 ); ip = i do i = ip + 1 , m if ( A ( i + 1 , k + 1 ) < - eps ) then q = - A ( i + 1 , 1 ) / A ( i + 1 , k + 1 ) if ( q < q1 ) then ip = i ; q1 = q else if ( q == q1 ) then ! Degeneracy situation. do j = 1 , n qp = - A ( i + 1 , j + 1 ) / A ( ip + 1 , k + 1 ) q0 = - A ( i + 1 , j + 1 ) / A ( i + 1 , k + 1 ) if ( q0 /= qp ) exit end do if ( q0 < qp ) ip = i end if end if end do end associate end function find_pivot pure subroutine exchange_variables ( A , ip , kp , i1 , k1 ) real ( dp ), intent ( inout ) :: A (:, :) integer ( ilp ), intent ( in ) :: ip , kp , i1 , k1 integer ( ilp ) :: ip1 , kp1 , i , j real ( dp ) :: piv integer ( ilp ), dimension ( k1 ) :: icol integer ( ilp ), dimension ( i1 ) :: irow integer ( ilp ), dimension ( max ( i1 , k1 ) + 1 ) :: itmp ip1 = ip + 1 ; kp1 = kp + 1 piv = 1.0_dp / A ( ip1 , kp1 ) itmp ( 1 : k1 + 1 ) = arange ( k1 + 1 ) icol = pack ( itmp ( 1 : k1 + 1 ), itmp ( 1 : k1 + 1 ) /= kp1 ) itmp ( 1 : i1 + 1 ) = arange ( i1 + 1 ) irow = pack ( itmp ( 1 : i1 + 1 ), itmp ( 1 : i1 + 1 ) /= ip1 ) A ( irow , kp1 ) = A ( irow , kp1 ) * piv A ( irow , icol ) = A ( irow , icol ) - outer_product ( A ( irow , kp1 ), A ( ip1 , icol )) A ( ip1 , icol ) = - A ( ip1 , icol ) * piv A ( ip1 , kp1 ) = piv end subroutine exchange_variables end submodule lightconvex_lp","tags":"","url":"sourcefile/lighthconvex_linearprograms.f90.html"},{"title":"LightConvex.f90 – LightConvex","text":"Files dependent on this one sourcefile~~lightconvex.f90~~AfferentGraph sourcefile~lightconvex.f90 LightConvex.f90 sourcefile~lighthconvex_linearprograms.f90 lighthconvex_linearprograms.f90 sourcefile~lighthconvex_linearprograms.f90->sourcefile~lightconvex.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module LightConvex use stdlib_linalg_constants , only : ilp , dp , lk use assert_m , only : assert implicit none ( external ) private public :: simplex !----------------------------- !-----     Constants     ----- !----------------------------- real ( dp ), parameter :: eps = epsilon ( 1.0_dp ) !-------------------------------------- !-----     LINEAR PROGRAMMING     ----- !-------------------------------------- interface simplex pure module subroutine dense_standard_simplex ( A , nleq , ngeq , neq , iposv , maxiter , info ) implicit none ( external ) real ( dp ), intent ( inout ) :: A (:, :) !! Simplex tableau of dimension n+2 x m integer ( ilp ), intent ( in ) :: nleq , ngeq , neq !! Number of constraints of each type. integer ( ilp ), intent ( in ) :: maxiter !! Maximum number of iterations. integer ( ilp ), intent ( out ) :: info !! Return flag: !!  - info = -1 : Problem is infeasible. !!  - info = 0  : Optimal solution has been found. !!  - info = 1  : Objective function is unbounded. integer ( ilp ), intent ( out ) :: iposv (:) !! Book-keeping for the primal and slack variables. end subroutine dense_standard_simplex end interface simplex end module LightConvex","tags":"","url":"sourcefile/lightconvex.f90.html"},{"title":"Contributing and specs – LightConvex","text":"Warning This page is currently under construction! Todo Improve the title of this FORD \"pages\" section, and\nimprove the organization of pages\nto separate end-user, high-level documentation and examples from developer documentation and specs.","tags":"","url":"page/index.html"},{"title":"Fortran stdlib License (MIT) – LightConvex","text":"MIT License Copyright (c) 2025 Jean-Christophe Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","tags":"","url":"page/License.html"},{"title":"Changelog – LightConvex","text":"","tags":"","url":"page/changelog.html"},{"title":"Contributing – LightConvex","text":"This page aims to provide information that are useful for stdlib contributors.\nIssues can be reported on GitHub .","tags":"","url":"page/contributing/index.html"},{"title":"Contributor Code of Conduct – LightConvex","text":"","tags":"","url":"page/contributing/CodeOfConduct.html"},{"title":"Style Guide – LightConvex","text":"Note This is a living document.\nYou are welcome to propose changes to this workflow by opening an issue .","tags":"","url":"page/contributing/StyleGuide.html"},{"title":"Workflow for Contributors – LightConvex","text":"Note This is a living document.\nYou are welcome to propose changes to this workflow by opening an issue .","tags":"","url":"page/contributing/Workflow.html"},{"title":"Specifications (specs) – LightConvex","text":"Fortran stdlib Specifications (specs) This is an index/directory of the specifications (specs) for each new module/feature as described in the workflow document . Fortran stdlib Specifications (specs) Experimental Features & Modules Released/Stable Features & Modules Experimental Features & Modules ansi - Terminal color and style escape sequences array - Procedures for index manipulation and array handling ascii - Procedures for handling ASCII characters constants - Constants bitsets - Bitset data types and procedures error - Catching and handling errors state_type - General state and error handling hash - Hashing integer\n vectors or character strings hashmaps - Hash maps/tables io - Input/output helper & convenience kinds - Kind parameters linalg - Linear Algebra linalg_state_type - Linear Algebra state and error handling logger - Runtime logging system math - General purpose mathematical functions optval - Fallback value for optional arguments quadrature - Numerical integration random - Probability Distributions random number generator sorting - Sorting of rank one arrays stats - Descriptive Statistics stats_distributions_uniform - Uniform Probability Distribution stats_distributions_normal - Normal Probability Distribution stats_distributions_exponential - Exponential Probability Distribution string_type - Basic string support stringlist_type - 1-Dimensional list of strings strings - String handling and manipulation routines system - OS and sub-processing routines version - Version information Released/Stable Features & Modules (None yet)","tags":"","url":"page/specs/index.html"},{"title":"terminal colors – LightConvex","text":"The stdlib_ansi module The stdlib_ansi module Introduction Derived types provided ansi_code type Status Example Constants provided style_reset style_bold style_dim style_italic style_underline style_blink style_blink_fast style_reverse style_hidden style_strikethrough fg_color_black fg_color_red fg_color_green fg_color_yellow fg_color_blue fg_color_magenta fg_color_cyan fg_color_white fg_color_default bg_color_black bg_color_red bg_color_green bg_color_yellow bg_color_blue bg_color_magenta bg_color_cyan bg_color_white bg_color_default Procedures and methods provided to_string Syntax Class Argument Result value Status Example operator(+) Syntax Class Argument Result value Status Example operator(//) Syntax Class Argument Result value Status Example Introduction Support terminal escape sequences to produce styled and colored terminal output. Derived types provided ansi_code type The ansi_code type represent an ANSI escape sequence with a style, foreground\ncolor and background color attribute. By default the instances of this type are\nempty and represent no escape sequence. Status Experimental Example Constants provided style_reset Style enumerator representing a reset escape code. style_bold Style enumerator representing a bold escape code. style_dim Style enumerator representing a dim escape code. style_italic Style enumerator representing an italic escape code. style_underline Style enumerator representing an underline escape code. style_blink Style enumerator representing a blink escape code. style_blink_fast Style enumerator representing a (fast) blink escape code. style_reverse Style enumerator representing a reverse escape code. style_hidden Style enumerator representing a hidden escape code. style_strikethrough Style enumerator representing a strike-through escape code. fg_color_black Foreground color enumerator representing a foreground black color escape code. fg_color_red Foreground color enumerator representing a foreground red color escape code. fg_color_green Foreground color enumerator representing a foreground green color escape code. fg_color_yellow Foreground color enumerator representing a foreground yellow color escape code. fg_color_blue Foreground color enumerator representing a foreground blue color escape code. fg_color_magenta Foreground color enumerator representing a foreground magenta color escape code. fg_color_cyan Foreground color enumerator representing a foreground cyan color escape code. fg_color_white Foreground color enumerator representing a foreground white color escape code. fg_color_default Foreground color enumerator representing a foreground default color escape code. bg_color_black Background color enumerator representing a background black color escape code. bg_color_red Background color enumerator representing a background red color escape code. bg_color_green Background color enumerator representing a background green color escape code. bg_color_yellow Background color enumerator representing a background yellow color escape code. bg_color_blue Background color enumerator representing a background blue color escape code. bg_color_magenta Background color enumerator representing a background magenta color escape code. bg_color_cyan Background color enumerator representing a background cyan color escape code. bg_color_white Background color enumerator representing a background white color escape code. bg_color_default Background color enumerator representing a background default color escape code. Procedures and methods provided to_string Generic interface to turn a style, foreground or background enumerator into an actual escape code string for printout. Syntax string = stdlib_ansi (code) Class Pure function. Argument code : Style, foreground or background code of ansi_code type,\n          this argument is intent(in) . Result value The result is a default character string. Status Experimental Example operator(+) Add two escape sequences, attributes in the right value override the left value ones. Syntax code = lval + rval Class Pure function. Argument lval : Style, foreground or background code of ansi_code type,\n          this argument is intent(in) . rval : Style, foreground or background code of ansi_code type,\n          this argument is intent(in) . Result value The result is a style, foreground or background code of ansi_code type. Status Experimental Example operator(//) Concatenate an escape code with a string and turn it into an actual escape sequence Syntax str = lval // rval Class Pure function. Argument lval : Style, foreground or background code of ansi_code type or a character string,\n          this argument is intent(in) . rval : Style, foreground or background code of ansi_code type or a character string,\n          this argument is intent(in) . Result value The result is a character string with the escape sequence prepended or appended. Status Experimental Example","tags":"","url":"page/specs/stdlib_ansi.html"},{"title":"array – LightConvex","text":"The stdlib_array module The stdlib_array module Introduction Procedures and methods provided trueloc Status Description Syntax Class Arguments Return value Examples falseloc Status Description Syntax Class Arguments Return value Examples Introduction Module for index manipulation and array handling tasks. Procedures and methods provided trueloc Status Experimental Description Turn a logical mask into an index array by selecting all true values.\nProvides similar functionality like the built-in where or the intrinsic procedures merge and pack when working with logical mask.\nThe built-in / intrinsics are usually preferable to trueloc , unless the access to the index array is required. Syntax loc = trueloc (array[, lbound]) Class Pure function. Arguments array : List of default logical arrays. This argument is intent(in) . lbound : Lower bound of the array to index. This argument is optional and intent(in) . Return value Returns an array of default integer size, with a maximum length of size(array) elements. Examples falseloc Status Experimental Description Turn a logical mask into an index array by selecting all false values.\nProvides similar functionality like the built-in where or the intrinsic procedures merge and pack when working with logical mask.\nThe built-in / intrinsics are usually preferable to falseloc , unless the access to the index array is required. Syntax loc = falseloc (array[, lbound]) Class Pure function. Arguments array : List of default logical arrays. This argument is intent(in) . lbound : Lower bound of the array to index. This argument is optional and intent(in) . Return value Returns an array of default integer size, with a maximum length of size(array) elements. Examples","tags":"","url":"page/specs/stdlib_array.html"},{"title":"ascii – LightConvex","text":"The stdlib_ascii module The stdlib_ascii module Introduction Constants provided by stdlib_ascii NUL SOH STX ETX EOT ENQ ACK BEL BS TAB LF VT FF CR SO SI DLE DC1 DC2 DC3 DC4 NAK SYN ETB CAN EM SUB ESC FS GS RS US DEL fullhex_digits hex_digits lowerhex_digits digits octal_digits letters uppercase lowercase whitespace Specification of the stdlib_ascii procedures is_alpha Status Description Syntax Class Argument Result value is_alphanum Status Description Syntax Class Argument Result value is_ascii Status Description Syntax Class Argument Result value is_control Status Description Syntax Class Argument Result value is_digit Status Description Syntax Class Argument Result value is_octal_digit Status Description Syntax Class Argument Result value is_hex_digit Status Description Syntax Class Argument Result value is_punctuation Status Description Syntax Class Argument Result value is_graphical Status Description Syntax Class Argument Result value is_printable Status Description Syntax Class Argument Result value is_lower Status Description Syntax Class Argument Result value is_upper Status Description Syntax Class Argument Result value is_white Status Description Syntax Class Argument Result value is_blank Status Description Syntax Class Argument Result value to_lower Status Description Syntax Class Argument Result value Example to_upper Status Description Syntax Class Argument Result value Example to_title Status Description Syntax Class Argument Result value Example to_sentence Status Description Syntax Class Argument Result value Example reverse Status Description Syntax Class Argument Result value Example Introduction The stdlib_ascii module provides procedures for handling and manipulating\nintrinsic character variables and constants. Constants provided by stdlib_ascii NUL Null character SOH Start Of Heading Character STX Start Of Text character ETX End Of Text character EOT End Of Transmission character ENQ Enquiry character ACK Acknowledge character BEL Bell character BS Backspace character TAB Horizontal Tab character LF Line Feed character VT Vertical Tab character FF Form Feed character CR Carriage Return character SO Shift Out character SI Shift In character DLE Data Link Escape character DC1 Device Control 1 character DC2 Device Control 2 character DC3 Device Control 3 character DC4 Device Control 4 character NAK Negative Acknowledge character SYN Synchronous Idle character ETB End of Transmission Block character CAN Cancel character EM End of Medium character SUB Substitute character ESC Escape character FS File separator character GS Group Separator character RS Record Separator character US Unit separator character DEL Delete character fullhex_digits All the hexadecimal digits (0-9, A-F, a-f) hex_digits All the numerical and uppercase hexadecimal digits (0-9, A-F) lowerhex_digits All the numerical and lowercase hexadecimal digits (0-9, a-f) digits base 10 digits (0-9) octal_digits base 8 digits (0-7) letters Uppercase and lowercase letters of the english alphabet (A-Z, a-z) uppercase Uppercase english albhabets (A-Z) lowercase Lowercase english albhabets (a-z) whitespace All the ascii whitespace characters (space, horizontal tab, vertical tab, carriage return, line feed, form feed) Specification of the stdlib_ascii procedures is_alpha Status Experimental Description Checks whether input character is an ASCII letter (A-Z, a-z). Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . is_alphanum Status Experimental Description Checks whether input character is an ASCII letter or a number (A-Z, a-z, 0-9). Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . is_ascii Status Experimental Description Checks whether input character is in the ASCII character set i.e in the range 0-128. Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . is_control Status Experimental Description Checks whether input character is a control character. Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . is_digit Status Experimental Description Checks whether input character is a digit (0-9). Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . is_octal_digit Status Experimental Description Checks whether input character is an octal digit (0-7) Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . is_hex_digit Status Experimental Description Checks whether input character is a hexadecimal digit (0-9, A-F, a-f). Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . is_punctuation Status Experimental Description Checks whether input character is a punctuation character. Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . is_graphical Status Experimental Description Checks whether input character is a graphical character (printable other than the space character). Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . is_printable Status Experimental Description Checks whether input character is a printable character (including the space character). Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . is_lower Status Experimental Description Checks whether input character is a lowercase ASCII letter (a-z). Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . is_upper Status Experimental Description Checks whether input character is an uppercase ASCII letter (A-Z). Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . is_white Status Experimental Description Checks whether input character is a whitespace character (which includes space, horizontal tab, vertical tab,\ncarriage return, linefeed and form feed characters) Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . is_blank Status Experimental Description Checks whether input character is a blank character (which includes space and tabs). Syntax res = stdlib_ascii (c) Class Elemental function. Argument c : shall be an intrinsic character(len=1) type. It is an intent(in) argument. Result value The result is a logical . to_lower Status Experimental Description Converts input character variable to all lowercase. Syntax res = stdlib_ascii (string) Class Elemental function. Argument string : shall be an intrinsic character type. It is an intent(in) argument. Result value The result is an intrinsic character type of the same length as string . Example to_upper Status Experimental Description Converts input character variable to all uppercase. Syntax res = stdlib_ascii (string) Class Elemental function. Argument string : shall be an intrinsic character type. It is an intent(in) argument. Result value The result is an intrinsic character type of the same length as string . Example to_title Status Experimental Description Returns the titlecase version of the input character variable. Title case: First character of every word in the sentence is converted to \nuppercase and the rest of the characters are converted to lowercase. A word is a contiguous sequence of character(s) which consists of alphabetical \ncharacter(s) and numeral(s) only and doesn't exclude any alphabetical character \nor numeral present next to either of its 2 ends. Syntax res = stdlib_ascii (string) Class Elemental function. Argument string : shall be an intrinsic character type. It is an intent(in) argument. Result value The result is an intrinsic character type of the same length as string . Example to_sentence Status Experimental Description Returns the sentencecase version of the input character variable. The first alphabetical character of the sequence is transformed to uppercase \nunless it follows a numeral. The rest of the characters in the sequence are \ntransformed to lowercase. Syntax res = stdlib_ascii (string) Class Elemental function. Argument string : shall be an intrinsic character type. It is an intent(in) argument. Result value The result is an intrinsic character type of the same length as string . Example reverse Status Experimental Description Reverses the order of all characters in the input character type. Syntax res = stdlib_ascii (string) Class Elemental function. Argument string : shall be an intrinsic character type. It is an intent(in) argument. Result value The result is an intrinsic character type of the same length as string . Example","tags":"","url":"page/specs/stdlib_ascii.html"},{"title":"bitsets – LightConvex","text":"The stdlib_bitsets module The stdlib_bitsets module Introduction The module's constants The stdlib_bitsets derived types The bitset-literal The binary-literal Summary of the module's operations Table of the bitset_type methods Table of the non-member procedure overloads Assignments Example Table of the non-member comparison operations Specification of the stdlib_bitsets methods and procedures all - determine whether all bits are set in self Status Description Syntax Class Argument Result value Example and - bitwise and of the bits of two bitsets Status Description Syntax Class Arguments Example and_not - Bitwise and of one bitset with the negation of another Status Description Syntax Class Arguments Example any - determine whether any bits are set Status Description Syntax Class Argument Result value Example bit_count - return the number of bits that are set Status Description Syntax Class Argument Result value Example bits - returns the number of bits Status Description Syntax Class Argument Result value Example clear - clears a sequence of one or more bits Status Description Syntax Class Arguments Example extract - create a new bitset from a range in an old bitset Status Description Syntax Class Arguments Example flip - flip the values of a sequence of one or more bits Status Description Syntax Class Arguments Example from_string - initializes a bitset from a binary literal Status Description Syntax Class Arguments Example init - bitset_type initialization routines Status Description Syntax Class Arguments Example input - reads a bitset from an unformatted file Status Description Syntax Class Arguments Example none - determines whether no bits are set Status Description Syntax Class Argument Result value Example not - Performs the logical complement on a bitset Status Description Syntax Class Argument Example or - Bitwise OR of the bits of two bitsets Status Description Syntax Class Arguments Example output - Writes a binary representation of a bitset to a file Status Description Syntax Class Arguments Example read_bitset - initializes self with the value of a bitset_literal Status Description Syntax Class Arguments Example set - sets a sequence of one or more bits to 1 Status Description Syntax Class Arguments Example test - determine whether a bit is set Status Descriptions Syntax Class Arguments Result value Example to_string - represent a bitset as a binary literal Status Description Syntax Class Arguments Example value - determine the value of a bit Status Description Syntax Class Arguments Result value Example write_bitset - writes a bitset-literal Status Description Syntax Class Arguments Example xor - bitwise exclusive or Status Description Syntax Class Arguments Example Specification of the stdlib_bitsets operators == - compare two bitsets to determine whether the bits have the same value Status Description Syntax Class Arguments Result value Example /= - compare two bitsets to determine whether any bits differ in value Status Description Syntax Class Arguments Result value Example >= - compare two bitsets to determine whether the first is greater than or equal to the second Status Description Syntax Class Arguments Result value Example > - compare two bitsets to determine whether the first is greater than the other Status Description Syntax Class Arguments Result value Example <= - compare two bitsets to determine whether the first is less than or equal to the other Status Description Syntax Class Arguments Result value Example < - compare two bitsets to determine whether the first is less than the other Status Description Syntax Class Arguments Result value Example Introduction The stdlib_bitsets module implements bitset types. A bitset is a\ncompact representation of a sequence of bits binary values. It can\nequivalently be considered as a sequence of logical values or as a\nsubset of the integers 0 ... bits-1 . For example, the value 1110 can be considered as defining the subset of integers [1, 2, 3].\nThe bits are indexed from 0 to bits(bitset)-1 .\nA bitset is used when space savings are critical in applications\nthat require a large number of closely related logical values.\nIt may also improve performance by reducing memory traffic. To\nimplement bitsets the module\ndefines three bitset types, multiple constants, a character string\nliteral that can be read to and from strings and formatted files, a\nsimple character string literal that can be read to and from strings,\nassignments, procedures, methods, and operators. Note that the module\nassumes two's complement integers, but all current Fortran 95 and later\nprocessors use such integers. Note that the module defines a number of \"binary\" procedures,\nprocedures with two bitset arguments. These arguments must be of the\nsame type and should have the same number of bits . For reasons of\nperformance the module does not enforce the bits constraint, but\nfailure to obey that constraint results in undefined behavior. This\nundefined behavior includes undefined values for those bits that\nexceed the defined number of bits in the smaller bitset. The\nundefined behavior may also include a \"segmentation fault\" for\nattempting to address bits in the smaller bitset, beyond the defined\nnumber of bits . Other problems are also possible. The module's constants The module defines several public integer constants, almost all\nintended to serve as error codes in reporting problems through an\noptional stat argument. One constant, bits_kind is\nthe integer kind value for indexing bits and reporting counts of\nbits. The other constants that are error codes are summarized below: Error Code Summary success No problems found alloc_fault Failure with a memory allocation array_size_invalid_error Attempt to define either negative bits or more than 64 bits in a bitset_64 char_string_invalid_error Invalid character found in a character string char_string_too_large_error Character string was too large to be encoded in the bitset char_string_too_small_error Character string was too small to hold the expected number of bits index_invalid_error Index to a bitstring was less than zero or greater than the number of bits integer_overflow_error Attempt to define an integer value bigger than huge(0_bits_kind) read_failure Failure on a read statement eof_failure An unexpected \"End-of-File\" on a read statement write_failure Failure on a write statement The stdlib_bitsets derived types The stdlib_bitsets module defines three derived types, bitset_type , bitset_64 , and bitset_large . bitset_type is an abstract\ntype that serves as the ancestor of bitset_64 and bitset_large . bitset_type defines one method, bits , and all of its\nother methods are deferred to its extensions. bitset_64 is a bitset\nthat can handle up to 64 bits. bitset_large is a bitset that can handle\nup huge(0_bits_kind) bits. All attributes of the bitset types are\nprivate. The various types each define a sequence of binary values: 0\nor 1. In some cases it is useful to associate a logical value, test ,\nfor each element of the sequence, where test is .true. if the value\nis 1 and .false. otherwise. The number of such values in an entity\nof that type is to be termed, bits . The bits are ordered in terms of\nposition, that, in turn, is indexed from 0 to bits-1 . bitset_type is\nused only as a class to define entities that can be either a bitset_64 or\na bitset_large . The syntax for using the types are: class( stdlib_bitsets ) :: variable type( stdlib_bitsets ) :: variable and type( stdlib_bitsets ) :: variable The bitset-literal A bitset value may be represented as a bitset-literal-constant character string in source code or as a bitset-literal in\nformatted files and non-constant strings. bitset-literal-constant is ' bitset-literal '\n                          or \" bitset-literal \" bitset-literal is bitsize-literal binary-literal bitsize-literal is S digit [ digit ] ... binary-literal is B binary-digit [ binary-digit ] ... digit is 0\n        or 1\n        or 2\n        or 3\n        or 4\n        or 5\n        or 6\n        or 7\n        or 8\n        or 9 binary-digit is 0\n               or 1 The bitset-literal consists of two parts: a bitsize-literal and a binary-literal . The sequence of decimal digits that is part of the bitsize-literal is interpreted as the decimal value of bits .\nThe binary-literal value is interpreted as a sequence of bit\nvalues and there must be as many binary digits in the literal as there\nare bits . The sequence of binary digits are treated as if they were\nan unsigned integer with the i-th digit corresponding to the bits-i bit position. The binary-literal In defining the bitset-literal we also defined a binary-literal . While not suitable for file I/0, the binary-literal is suitable for transfer to and from character\nstrings. In that case the length of the string is the number of bits\nand all characters in the string must be either \"0\" or \"1\". Summary of the module's operations The stdlib_bitsets module defines a number of operations: \"unary\" methods of class bitset_type , \"binary\" procedure overloads of type bitset_64 or bitset_large , assignments, and \"binary\" comparison operators of type bitset_64 or bitset_large . Each category will be discussed separately. Table of the bitset_type methods The bitset_type class has a number of methods. All except one, bits ,\nare deferred. The methods consist of all procedures with one argument\nof class bitset_type . The procedures with two arguments of type bitset_64 or bitset_large are not methods and are\nsummarized in a separate table of procedures. The methods are\nsummarized below: Method name Class Summary all function .true. if all bits are 1, .false. otherwise any function .true. if any bits are 1, .false. otherwise bit_count function returns the number of bits that are 1 bits function returns the number of bits in the bitset clear subroutine sets a sequence of one or more bits to 0 flip subroutine flips the value of a sequence of one or more bits from_string subroutine reads the bitset from a string treating it as a binary literal init subroutine creates a new bitset of size bits with no bits set input subroutine reads a bitset from an unformatted I/O unit none function .true. if no bits are 1, .false. otherwise not subroutine performs a logical not operation on all the bits output subroutine writes a bitset to an unformatted I/O unit read_bitset subroutine reads a bitset from a bitset literal in a character string or formatted I/O unit set subroutine sets a sequence of one or more bits to 1 test function .true. if the bit at pos is 1, .false. otherwise to_string subroutine represents the bitset as a binary literal value function 1 if the bit at pos is 1, 0 otherwise write_bitset subroutine writes a bitset as a bitset literal to a  character string or formatted I/O unit Table of the non-member procedure overloads The procedures with two arguments of type bitset_large or bitset_64 must have both arguments of the same known type which\nprevents them from being methods. The bitwise \"logical\" procedures, and , and_not , or , and xor also require that the two bitset\narguments have the same number of bits, otherwise the results are\nundefined. These procedures are summarized in the following table: Procedure name Class Summary and elemental subroutine Sets self to the bitwise and of the original bits in self and set2 and_not elemental subroutine Sets self to the bitwise and of the original bits in self and the negation of set2 extract subroutine creates a new bitset, new , from a range in old or elemental subroutine Sets self to the bitwise or of the original bits in self and set2 xor elemental subroutine Sets self to the bitwise exclusive or of the original bits in self and set2 Assignments The module uses the intrinsic assignment operation, = , to create a\nduplicate of an original bitset. It additionally defines assignments to and\nfrom rank one arrays of logical type of kinds int8 , int16 , int32 , and int64 . In the assignment to and from logical arrays\narray index, i , is mapped to bit position, pos=i-1 , and .true. is mapped to a set bit, and .false. is mapped to an unset bit. Example Table of the non-member comparison operations The comparison operators with two arguments of type bitset_large or bitset_64 must have both arguments of the same known type which\nprevents them from being methods. The operands must also have the same\nnumber of bits otherwise the results are undefined. These operators\nare summarized in the following table: Operator Description == , .eq. .true. if all bits in set1 and set2 have the same value, .false. otherwise /= , .ne. .true. if any bits in set1 and set2 differ in value, .false. otherwise > , .gt. .true. if the bits in set1 and set2 differ in value and the highest order differing bit is 1 in set1 and 0 in set2 , .false. otherwise >= , .ge. .true. if the bits in set1 and set2 are the same or the highest order differing bit is 1 in set1 and 0 in set2 , .false. otherwise < , .lt. .true. if the bits in set1 and set2 differ in value and the highest order differing bit is 0 in set1 and 1 in set2 , .false. otherwise <= , .le. .true. if the bits in set1 and set2 are the same or the highest order differing bit is 0 in set1 and 1 in set2 , .false. otherwise Specification of the stdlib_bitsets methods and procedures all - determine whether all bits are set in self Status Experimental Description Determines whether all bits are set to 1 in self . Syntax result = self % bitset_type () Class Elemental function. Argument self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if all bits in self are set,\notherwise it is .false. . Example and - bitwise and of the bits of two bitsets Status Experimental Description Sets the bits in set1 to the bitwise and of the original bits in set1 and set2 . Note that set1 and set2 must have the same\nnumber of bits, otherwise the result is undefined. Syntax call stdlib_bitsets (set1, set2) Class Elemental subroutine. Arguments set1 : shall be a bitset_64 or bitset_large scalar variable. It\nis an intent(inout) argument. On return the values of the bits in set1 are the bitwise and of the original bits in set1 with the\ncorresponding bits in set2 . set2 : shall be a scalar expression of the same type as set1 . It is\nan intent(in) argument. Note that set2 must also have the same\nnumber of bits as set1 . Example and_not - Bitwise and of one bitset with the negation of another Status Experimental Description Sets the bits of set1 to bitwise and of the bits of set1 with\nthe bitwise negation of the corresponding bits of set2 . Note that set1 and set2 must have the same number of bits, otherwise the\nresult is undefined. Syntax call stdlib_bitsets (set1, set2) Class Elemental subroutine. Arguments set1 : shall be a scalar bitset_64 or bitset_large variable. It\nis an intent(inout) argument. On return the values of the bits in set1 are the bitwise and of the original bits in set1 with the\ncorresponding negation of the bits in set2 . set2 : shall be a scalar expression of the same type as set1 . It is\nan intent(in) argument. Note that it should also have the same\nnumber of bits as set1 , otherwise the result is undefined. Example any - determine whether any bits are set Status Experimental Description Determines whether any bits are set in self . Syntax result = self % bitset_type () Class Elemental function. Argument self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. Result value The result is a default logical scalar. The result is .true. if any bits in self are set, otherwise it\nis .false. . Example bit_count - return the number of bits that are set Status Experimental Description Returns the number of bits that are set to one in self . Syntax result = self % bitset_type () Class Elemental function. Argument self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. Result value The result is an integer scalar of kind bits_kind ,\nequal to the number of bits that are set in self . Example bits - returns the number of bits Status Experimental Description Reports the number of bits in self . Syntax result = self % bitset_type () Class Elemental function. Argument self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. Result value The result is an integer scalar of kind bits_kind , equal to\nthe number of defined bits in self . Example clear - clears a sequence of one or more bits Status Experimental Description If only pos is present, clears the bit with position pos in self . If start_pos and end_pos are present with end_pos >= start_pos clears the bits with positions from start_pos to end_pos in self . if start_pos and end_pos are present with end_pos < start_pos self is unmodified. Note: Positions outside the range 0 to bits(set) -1 are ignored. Syntax call self % bitset_type (pos) or call self % bitset_type (start_pos, end_pos) Class Elemental subroutine Arguments self : shall be a scalar variable of class bitset_type . It is an intent(inout) argument. pos : shall be a scalar integer expression of kind bits_kind . It is\nan intent(in) argument. start_pos : shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. end_pos : shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. Example extract - create a new bitset from a range in an old bitset Status Experimental Description Creates a new bitset, new , from a range, start_pos to stop_pos ,\nin bitset old . If start_pos is greater than stop_pos the new\nbitset is empty. If start_pos is less than zero or stop_pos is\ngreater than bits(old)-1 then if status is present it has the\nvalue index_invalid_error , otherwise processing stops with an\ninformative message. Syntax call stdlib_bitsets (new, old, start_pos, stop_pos, status ) Class Subroutine Arguments new : shall be a scalar bitset_64 or bitset_large variable. It\nis an intent(out) argument. It will be the new bitset. old : shall be a scalar expression of the same type as new . It is\nan intent(in) argument. It will be the source bitset. start_pos : shall be a scalar integer expression of the kind bits_kind . It is an intent(in) argument. stop_pos : shall be a scalar integer expression of the kind bits_kind . It is an intent(in) argument. status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument. If present it shall have one of the values: success - no problems found index_invalid_error - start_pos was less than zero or stop_pos was greater than bits(old)-1 . Example flip - flip the values of a sequence of one or more bits Status Experimental Description Flip the values of  a sequence of one or more bits. If only pos is present flip the bit value with position pos in self .\n* If start_pos and end_pos are present with end_pos >= start_pos flip the bit values with positions from start_pos to end_pos in self . If end_pos < start_pos then self is unmodified. Syntax call self % bitset_type (pos) or call self % bitset_type (start_pos, end_pos) Class Elemental subroutine. Arguments self : shall be a scalar class bitset_type variable It is an intent(inout) argument. pos : shall be a scalar integer expression of kind bits_kind . It is\nan intent(in) argument. start_pos : shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. end_pos : shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. Example from_string - initializes a bitset from a binary literal Status Experimental Description Initializes the bitset self from string , treating string as a\nbinary literal. Syntax call self % bitset_type (string[, status]) Class Subroutine Arguments self : shall be a scalar class bitset_type variable. It is an intent(out) argument. string : shall be a scalar default character expression. It is an intent(in) argument. It shall consist only of the characters \"0\",\nand \"1\". status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument. If present, on return its value shall be\none of the error codes defined in this module. If absent, and its\nvalue would not have been success , then processing will stop with an\ninformative text as its stop code. It shall have one of the error\ncodes: success - if no problems were found, alloc_fault - if allocation of the bitset failed char_string_too_large_error - if string was too large, or char_string_invalid_error - if string had an invalid character. Example init - bitset_type initialization routines Status Experimental Description bitset_type initialization routine. Syntax call self % bitset_type (bits [, status]) Class Subroutine. Arguments self : shall be a scalar bitset_64 or bitset_large variable. It\nis an intent(out) argument. bits : shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument that if present\nspecifies the number of bits in set . A negative value, or a value\ngreater than 64 if self is of type bitset_64 , is an error. status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument that, if present, returns an error code\nindicating any problem found in processing init , and if absent and\nan error was found result in stopping processing with an informative\nstop code. It can have any of the following error codes: success - no problem found alloc_fault - self was of type bitset_large and memory\n  allocation failed array_size_invalid_error - bits was present with either a negative\n  value, or a value greater than 64 when self was of type bitset_64 . Example input - reads a bitset from an unformatted file Status Experimental Description Reads a bitset from its binary representation in an unformatted\nfile. Syntax call self % bitset_type (unit [, status]) Class Subroutine Arguments self : shall be a scalar variable of class bitset_64 or bitset_large . It is an intent(out) argument. unit : shall be a scalar default integer expression. It is an intent(in) argument. Its value must be that of a logical unit\nnumber for an open unformatted file with read or readwrite access positioned at the start of a bitset value written by a bitset_type output subroutine by the same processor. status (optional): shall be a scalar default integer variable. If\npresent its value shall be of one of the error codes defined in this\nmodule. If absent and it would have had a value other than success processing will stop with an informative stop code. Allowed error code\nvalues for this status are: success - no problem found alloc_fault - self was of type bitset_large and allocation of\n  memory failed. array_size_invalid_error - if the number of bits read from unit is either negative or greater than 64, if class of self is bitset_64 . read_failure - failure during a read statement Example none - determines whether no bits are set Status Experimental Description Determines whether no bits are set in self . Syntax result = self % bitset_type () Class Elemental function. Argument self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if no bits in self are set, otherwise it is .false. . Example not - Performs the logical complement on a bitset Status Experimental Description Performs the logical complement on the bits of self . Syntax call self % bitset_type () Class Elemental subroutine. Argument self shall be a scalar variable of class bitset_type . It is an intent(inout) argument. On return its bits shall be the logical\ncomplement of their values on input. Example or - Bitwise OR of the bits of two bitsets Status Experimental Description Replaces the original bits of set1 with the bitwise or of those\nbits with the bits of set2 . Note set1 and set2 must have the\nsame number of bits, otherwise the result is undefined. Syntax call stdlib_bitsets (set1, set2) Class Elemental subroutine. Arguments set1 : shall be a scalar bitset_64 or bitset_large variable. It\nis an intent(inout) argument. On return the values of the bits in setf are the bitwise or of the original bits in set1 with the\ncorresponding bits in set2 . set2 : shall be a scalar expression of the same type as set1 . It is\nan intent(in) argument. Note bits(set2) must equal bits(set1) otherwise the results are undefined. Example output - Writes a binary representation of a bitset to a file Status Experimental Description Writes a binary representation of a bitset to an unformatted file. Syntax call self % bitset_type (unit[, status]) Class Subroutine. Arguments self : shall be a scalar expression of class bitset_64 or bitset_large . It is an intent(in) argument. unit : shall be a scalar default integer expression. It is an intent(in) argument. Its value must be that of an I/O unit number\nfor an open unformatted file with write or readwrite access. status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument. If present on return it will have the value\nof success or write_failure . If absent and it would not have the\nvalue of success then processing will stop with an informative stop\ncode. The two code values have the meaning: success - no problem found write_failure - a failure occurred in a write statement. Example read_bitset - initializes self with the value of a bitset_literal Status Experimental Description Reads a bitset-literal and initializes self with the corresponding\nvalue. Syntax call self % bitset_type (string[, status]) or call self % bitset_type (unit[, advance, status]) Class Subroutine Arguments self : shall be a scalar variable of class bitset_type . It is an intent(out) argument. Upon a successful return it is initialized with\nthe value of a bitset-literal . string (optional): shall be a scalar default character\nexpression. It is an intent(in) argument. It will consist of a left \njustified bitset-literal , terminated by either the end of the string\nor a blank. unit (optional): shall be a scalar default integer expression. It is\nan intent(in) argument. Its value must be that of an I/O unit number\nfor an open formatted file with read or readwrite access\npositioned at the start of a bitset-literal . advance (optional): shall be a scalar default character\nexpression. It is an intent(in) argument. It is the advance specifier for the final read of unit . If present it should have\nthe value 'yes' or 'no' . If absent it has the default value of 'yes' . status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument. If present on return it shall have the\nvalue of one of the error codes of this module. If absent and it would\nnot have had the value success processing will stop with a message\nas its error code. The possible error codes are: success - no problems found; alloc_fault - if self is of class bitset_large and allocation\n  of the bits failed; array_size_invalid_error - if the bitset-literal has a bits\n  value greater than 64 and self is of class bitset_64 ; char_string_invalid_error - if the bitset-literal has an invalid\n  character; char_string_too_small_error - if string ends before all the bits\n  are read; eof_failure -  if a read statement reached an end-of-file before\n   completing the read of the bitset literal, integer_overflow_error - if the bitset-literal has a bits value larger than huge(0_bits_kind) ; or read_failure - if a read statement failed. Example set - sets a sequence of one or more bits to 1 Status Experimental Description Sets a sequence of one or more bits in self to 1. If start_pos and end_pos are absent sets the bit at position pos in self to 1. If start_pos and end_pos are present with end_pos >= start_pos set the bits at positions from start_pos to end_pos in self to 1. If start_pos and end_pos are present with end_pos < start_pos self is unchanged. Positions outside the range 0 to bits(self) are ignored. Syntax call self % bitset_type (POS) or call self % bitset_type (START_POS, END_POS) Class Elemental subroutine Arguments self : shall be a scalar variable of class bitset_type . It is an intent(inout) argument. pos (optional): shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. start_pos (optional): shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. end_pos (optional): shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. Example test - determine whether a bit is set Status Experimental Descriptions Determine whether the bit at position pos is set to 1 in self . Syntax result = self % bitset_type (pos) Class Elemental function. Arguments self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. pos : shall be a scalar integer expression of kind bits_kind . It is\nan intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if the bit at pos in self is set,\notherwise it is .false. . If pos is outside the range 0... bits(self)-1 the result is .false. . Example to_string - represent a bitset as a binary literal Status Experimental Description Represents the value of self as a binary literal in string . Syntax call self % bitset_type (string[, status]) Class Subroutine Arguments self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. string : shall be a scalar default character variable of allocatable\nlength. It is an intent(out) argument. On return it shall have a binary-literal representation of the bitset self . status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument. If present it shall have either the value success or alloc_fault . If absent and it would have had the value alloc_fault then processing will stop with an informative test as\nthe stop code. The values have the following meanings: success - no problem found. alloc_fault - allocation of string failed. Example value - determine the value of a bit Status Experimental Description Determines the value of the bit at position, pos , in self . Syntax result = self % bitset_type (pos) Class Elemental function. Arguments self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. pos : shall be a scalar integer expression of kind bits_kind . It is\nan intent(in) argument. Result value The result is a default integer scalar.\nThe result is one if the bit at pos in self is set, otherwise it\nis zero. If pos is outside the range 0... bits(set)-1 the result\nis zero. Example write_bitset - writes a bitset-literal Status Experimental Description Writes a bitset-literal representing self 's current value to a\ncharacter string or formatted file. Syntax call self % bitset_type (string[, status]) or call self % bitset_type (unit[, advance, status]) Class Subroutine Arguments self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. string (optional): shall be a scalar default character variable of\nallocatable length. It is an intent(out) argument. unit (optional): shall be a scalar default logical expression. It is\nan intent(in) argument. Its value must be that of a I/O unit number\nfor an open formatted file with write or readwrite access. advance (optional): shall be a scalar default character\nexpression. It is an intent(in) argument. It is the advance specifier for the write to unit . If present it must have the value 'yes' or 'no' . It has the default value of 'yes' . if advance is not present or is present with a value of 'no' then the bitset's bitset-literal is written to unit followed by a blank, and the current record is not advanced. If advance is present with a value of 'yes' then the\n  bitset's bitset-literal is written to unit and the\n  record is immediately advanced. status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument. If present on return it shall have the\nvalue of one of the module's error codes. If absent and a problem was\nfound processing will stop with an informative stop code. It may have\nthe following error code values: success - no problem was found alloc_fault - allocation of the string failed write_failure - the write to the unit failed Example xor - bitwise exclusive or Status Experimental Description Replaces set1 's bitset with the bitwise exclusive or of the\noriginal bits of set1 and set2 . Note set1 and set2 must have\nthe samee number of bits, otherwise the result is undefined. Syntax result = stdlib_bitsets (set1, set2) Class Elemental subroutine Arguments set1 : shall be a scalar bitset_64 or bitset_large variable. It\nis an intent(inout) argument. On return the values of the bits in set1 are the bitwise exclusive or of the original bits in set1 with the corresponding bits in set2 . set2 shall be a scalar expression of the same type as set1 . It is\n  an intent(in) argument. Note set1 and set2 must have the\nsamee number of bits, otherwise the result is undefined. Example Specification of the stdlib_bitsets operators == - compare two bitsets to determine whether the bits have the same value Status Experimental Description Returns .true. if all bits in set1 and set2 have the same value, .false. otherwise. Syntax result = set1 [[stdlib_bitsets(module):==(interface)]] set2 or result = set1 .EQ. set2 Class Elemental operator Arguments set1 : shall be a scalar bitset_64 or bitset_large expression. It\nis an intent(in) argument. set2 : shall be a scalar expression of the same type as self . It\nwill have the same number of bits as set1 . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if the bits in both bitsets are set\nto the same value, otherwise the result is .false. . Example /= - compare two bitsets to determine whether any bits differ in value Status Experimental Description Returns .true. if any bits in self and set2 differ in value, .false. otherwise. Syntax result = set1 [[stdlib_bitsets(module):/=(interface)]] set2 or result = set1 .NE. set2 Class Elemental function Arguments set1 : shall be a scalar bitset_64 or bitset_large expression. It\nis an intent(in) argument. set2 : shall be a scalar expression of the same type as self . It\nwill have the same number of bits as set1 . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if any bits in both bitsets differ, otherwise\nthe result is .false. . Example >= - compare two bitsets to determine whether the first is greater than or equal to the second Status Experimental Description Returns .true. if the bits in set1 and set2 are the same or the\nhighest order different bit is set to 1 in set1 and to 0 in set2 , .false. .  otherwise. The sets must be the same size otherwise the\nresults are undefined. Syntax result = set1 [[stdlib_bitsets(module):>=(interface)]] set2 or result = set1 .GE. set2 Class Elemental operator Arguments set1 : shall be a scalar bitset_64 or bitset_large expression. It\nis an intent(in) argument. set2 : shall be a scalar expression of the same type as self . It\nwill have the same number of bits as set1 . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if the bits in set1 and set2 are the same\nor the highest order different bit is set to 1 in set1 and to 0 in set2 , .false. otherwise. Example > - compare two bitsets to determine whether the first is greater than the other Status Experimental Description Returns .true. if the bits in set1 and set2 differ and the\nhighest order different bit is set to 1 in set1 and to 0 in set2 , .false. otherwise. The sets must be the same size otherwise the\nresults are undefined. Syntax result = set1 [[stdlib_bitsets(module):>(interface)]] set2 or result = set1 .GT. set2 Class Elemental operator Arguments set1 : shall be a scalar bitset_64 or bitset_large expression. It\nis an intent(in) argument. set2 : shall be a scalar expression of the same type as self . It\nwill have the same number of bits as set1 . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if the bits in set1 and set2 differ and the\nhighest order different bit is set to 1 in set1 and to 0 in set2 , .false. otherwise. Example <= - compare two bitsets to determine whether the first is less than or equal to the other Status Experimental Description Returns .true. if the bits in set1 and set2 are the same or the\nhighest order different bit is set to 0 in set1 and to 1 in set2 , .false. otherwise. The sets must be the same size otherwise the\nresults are undefined. Syntax result = set1 [[stdlib_bitsets(module):<=(interface)]] set2 or result = set1 .LE. set2 Class Elemental operator Arguments set1 : shall be a scalar bitset_64 or bitset_large expression. It\nis an intent(in) argument. set2 : shall be a scalar expression of the same type as self . It\nwill have the same number of bits as set1 . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if the bits in set1 and set2 are the same\nor the highest order different bit is set to 0 in set1 and to 1 in set2 , .false. otherwise. Example < - compare two bitsets to determine whether the first is less than the other Status Experimental Description Returns .true. if the bits in set1 and set2 differ and the\nhighest order different bit is set to 0 in set1 and to 1 in set2 , .false. otherwise. The sets must be the same size otherwise the\nresults are undefined. Syntax result = set1 [[stdlib_bitsets(module):<(interface)]] set2 or `result = set1 .LT. set2 Class Elemental operator Arguments set1 : shall be a scalar bitset_64 or bitset_large expression. It\nis an intent(in) argument. set2 : shall be a scalar expression of the same type as self . It\nwill have the same number of bits as set1 . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if the bits in set1 and set2 differ and the\nhighest order different bit is set to 0 in set1 and to 1 in set2 , .false. otherwise. Example","tags":"","url":"page/specs/stdlib_bitsets.html"},{"title":"constants – LightConvex","text":"Introduction Codata to_real - Get the constant value or its uncertainty. Status Description Syntax Arguments Return value Example Introduction The stdlib_constants module provides mathematical constants and the most common physical constants. Warning : The names of the most common physical constants are kept short as they are inside a dedicated module. \nNonetheless, in case of overlapping names, they can always be renamed as following: use stdlib_constants , only : clight => c Codata The stdlib_codata module defines all codata (physical) constants as derived \ntype. The module is automatically generated with a simple parser written in Python The latest codata constants were released in 2022 by the NIST All values for the codata constants are provided as double precision reals. \nThe names are quite long and can be aliased with shorter names. The derived type stdlib_codata_type defines: 4 members: name (string) value (double precision real) uncertainty (double precision real) unit (string) 2 type-bound procedures: print : to print the values of the constant members; to_real : to get the value or the uncertainty to the desired precision. A module level interface stdlib_codata_type is \navailable for getting the constant value or uncertainty of a constant. to_real - Get the constant value or its uncertainty. Status Experimental Description Convert a stdlib_codata_type to a real (at least sp , or dp ) scalar. Warning : Some constants cannot be converted to single precision sp reals due to the value of the exponents. Syntax r = stdlib_codata_type (c, mold [, uncertainty]) Arguments c : argument has intent(in) and shall be of type stdlib_codata_type . mold : argument has intent(in) and shall be of real type. Note : The type of the mold argument defines the type of the result. uncertainty (optional): argument has intent(in) and shall be of logical type. \nIt specifies if the uncertainty needs to be returned instead of the value. Default to .false. . Return value Returns a scalar of real type which is either the value or the uncertainty of a codata constant. Example","tags":"","url":"page/specs/stdlib_constants.html"},{"title":"error – LightConvex","text":"The stdlib_error module The stdlib_error module Introduction Procedures and methods provided check - Checks the value of a logical condition Status Description Syntax Arguments Return value Examples error_stop - aborts the program Status Description Syntax Arguments Output Examples Introduction Catching and handling errors. Procedures and methods provided check - Checks the value of a logical condition Status Experimental Description Checks the value of a logical condition. Syntax call check (condition, msg, code, warn) Arguments condition : Shall be a scalar of type logical . msg (optional): Shall be a character expression containing the message to be printed to stderr . The default msg is 'Check failed.'. code (optional): Shall be a scalar of type integer . The default code is 1 . warn (optional): Shall be a scalar of type logical . The default warn is .true. . Return value If condition is .false. , and: no other arguments are provided, this subroutine stops the program with the default message and exit code 1; msg is provided, this subroutine stops the program and it prints the value of msg ; code is provided, this subroutine stops the program with the given exit code; warn is provided and warn is .true. , this subroutine doesn't stop the program and prints the message. Examples error_stop - aborts the program Status Experimental Description Aborts the program with a message and a nonzero exit code. Syntax call stdlib_error (msg, code) Arguments msg : Shall be a character expression containing the message to be printed to stderr . code (optional): Shall be a scalar of type integer to be returned as exit code. Output Aborts the program with printing the message msg to stderr and a nonzero exit code. The nonzero exit code is equal to code if provided, and 1 otherwise. Examples Without error code: With error code:","tags":"","url":"page/specs/stdlib_error.html"},{"title":"state_type – LightConvex","text":"State and Error Handling Derived Type State and Error Handling Derived Type Introduction Derived types provided The state_type derived type Type-bound procedures Status Example Error flags provided Comparison operators provided Introduction The stdlib_error module provides a derived type holding information on the state of operations within the standard library and procedures for expert control of workflows.\nAn optional state_type variable to hold such information is provided as a form of expert API.\nIf the user does not require state information but fatal errors are encountered during execution, the program will undergo a hard stop.\nInstead, if the state argument is present, the program will never stop but will return detailed error information into the state handler. Derived types provided The state_type derived type The state_type is defined as a derived type containing an integer error flag and fixed-size character strings to store an error message and the location of the error state change.\nFixed-size string storage was chosen to facilitate the compiler's memory allocation and ultimately ensure maximum computational performance. A similarly named generic interface, state_type , is provided to allow the developer to create diagnostic messages and raise error flags easily. \nThe call starts with an error flag or the location of the event and is followed by an arbitrary list of integer , real , complex , or character variables. \nNumeric variables may be provided as either scalars or rank-1 (array) inputs. Type-bound procedures The following convenience type-bound procedures are provided:\n- print() returns an allocatable character string containing state location, message, and error flag;\n- print_message() returns an allocatable character string containing the state message;\n- ok() returns a logical flag that is .true. in case of successful state ( flag==STDLIB_SUCCESS );\n- error() returns a logical flag that is .true. in case of an error state ( flag/=STDLIB_SUCCESS ). Status Experimental Example Error flags provided The module provides the following state flags:\n- STDLIB_SUCCESS : Successful execution\n- STDLIB_VALUE_ERROR : Numerical errors (such as infinity, not-a-number, range bounds) are encountered.\n- STDLIB_LINALG_ERROR : Linear Algebra errors are encountered, such as non-converging iterations, impossible operations, etc.\n- STDLIB_INTERNAL_ERROR : Provided as a developer safeguard for internal errors that should never occur.\n- STDLIB_IO_ERROR : Input/Output-related errors, such as file reading/writing failures.\n- STDLIB_FS_ERROR : File system-related errors, such as directory access issues. Comparison operators provided The module provides overloaded comparison operators for all comparisons of a state_type variable with an integer error flag: < , <= , == , >= , > , /= .","tags":"","url":"page/specs/stdlib_error_state_type.html"},{"title":"hash – LightConvex","text":"The stdlib_hash_32bit and stdlib_hash_64bit modules The stdlib_hash_32bit and stdlib_hash_64bit modules Overview of hash procedures Licensing Glossary The hash codes modules Overview of the modules The stdlib_hash_32bit module Overview of the module The int_hash parameter The little_endian parameter Specifications of the stdlib_hash_32bit procedures fibonacci_hash - maps an integer to a smaller number of bits Status Description Syntax Class Arguments Result Note Example fnv_1_hash- calculates a hash code from a key Status Description Syntax Class Argument Result Note Example fnv_1a_hash- calculates a hash code from a key Status Description Syntax Class Argument Result Note Example new_nmhash32_seed- returns a valid input seed for nmhash32 Status Description Syntax Class Argument Note Example new_nmhash32x_seed- returns a valid input seed for nmhash32x Status Description Syntax Class Argument Note Example new_water_hash_seed- returns a valid input seed for water_hash Status Description Syntax Class Argument Note Example nmhash32- calculates a hash code from a key and a seed Status Description Syntax Class Arguments Result Note Example nmhash32x- calculates a hash code from a key and a seed Status Description Syntax Class Arguments Result Note Example odd_random_integer - returns an odd integer Status Description Syntax Class Argument Note Example universal_mult_hash - maps an integer to a smaller number of bits Status Description Syntax Class Arguments Result Note Example water_hash- calculates a hash code from a key and a seed Status Description Syntax Class Arguments Result Note Example The stdlib_hash_64bit module Overview of the module The int_hash parameters The little_endian parameter Specifications of the stdlib_hash_64bit procedures fibonacci_hash - maps an integer to a smaller number of bits Status Description Syntax Class Arguments Result Note Example FNV_1- calculates a hash code from a key Status Description Syntax Class Argument Result Note Example FNV_1A- calculates a hash code from a key Status Description Syntax Class Argument Result Note Example new_pengy_hash_seed- returns a valid input seed for pengy_hash Status Description Syntax Class Argument Note Example new_spooky_hash_seed- returns a valid input seed for spooky_hash Status Description Syntax Class Argument Note Example odd_random_integer - returns odd integer Status Description Syntax Class Argument Note Example pengy_hash - maps a character string or integer vector to an integer Status Description Syntax Class Arguments Result Note Example spooky_hash - maps a character string or integer vector to an integer Status Description Syntax Class Arguments Result Note Example universal_mult_hash - maps an integer to a smaller number of bits Status Description Syntax Class Arguments Result Note Example Test Codes Overview of hash procedures The comparison of lexical entities or other objects for equality\ncan be computationally expensive.\nThis cost is often reduced by computing a near unique integer value,\ntermed a hash code, from the structure of the object using a procedure\ntermed a hash function.\nEquality of hash codes is a necessary, but not sufficient, condition\nfor the original objects to be equal.\nAs integer comparisons are very efficient, performing an initial\ncomparison of hash codes and then performing a detailed comparison\nonly if the hash codes are equal can improve performance.\nThe hash codes, in turn, can be mapped to a smaller set of integers,\nthat can be used as an index, termed a hash index, to a rank-1\narray, often termed a hash table.\nThis mapping will be known as a scalar hash.\nThe use of a hash table reduces the number of hash codes that need to\nbe compared, further improving performance.\nA hash function can also be used to generate a checksum to verify that\ndata has not changed.\nThe Fortran Standard Library therefore provides procedures to compute\nhash codes and scalar hashes.\nThis document only discusses the hash codes and scalar hashes in the\nlibrary. Licensing The Fortran Standard Library is distributed under the MIT License.\nHowever components of the library may be based on code released under a\ndifferent license. In particular, the hash codes are often based\non algorithms considered as public domain ( Fibonacci Hash , Universal\nMultiplicative Hash) or released under a different license than the\nMIT license ( FNV-1 Hash , FNV-1A Hash , nmhash32 , nmhash32x , waterhash , pengyhash and SpookyHash )\nThe licensing status of the algorithms are discussed below. fibonacci_hash is a scalar hash. It is an implementation in Fortran\n2008 and signed two's complement integers of the Fibonacci Hash\ndescribed in D. E. Knuth, \"The Art of\nComputer Programming, Second Edition, Volume 3, Sorting and\nSearching\", Addison-Wesley, Upper Saddle River, NJ,\npp. 517-518, 1998. The algorithms in that source are considered public\ndomain, and its use is unrestricted. universal_mult_hash is a scalar hash. It is an implementation in\nFortran 2008 and signed two's complement integers of the\nuniversal multiplicative hash algorithm of M. Dietzfelbinger,\nT. Hagerup, J. Katajainen, and M. Penttonen, \"A Reliable Randomized\nAlgorithm for the Closest-Pair Problem,\" J. Algorithms, Vol. 25,\nNo. 1, Oct. 1997, pp. 19-51. Because of its publication in the Journal\nof Algorithms, the universal multiplicative hash algorithm is public\ndomain. fnv_1_hash and fnv_1a_hash are translations to Fortran 2008 and\nsigned two's complement integers of the FNV-1 and FNV-1a hash functions of Glenn Fowler, Landon Curt Noll,\nand Phong Vo, that has been released into the public\ndomain. Permission has been granted, by Landon Curt Noll, for the use\nof these algorithms in the Fortran Standard Library. A description of\nthese functions is available at https://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function .\nThese functions have been modified from their normal forms to also\nencode the structure size in the output hash. Similarly spooky_hash and associated procedures are translations to\nFortran 2008 and signed two's complement integers of the unsigned 64\nbit version 2 SpookyHash functions of Bob\nJenkins https://burtleburtle.net/bob/hash/spooky.html to signed 64\nbit operations. Version 2 was chosen over version 1 as it has better\nperformance and fewer bad seeds\nBob Jenkins has also put this code in the public\ndomain and has given permission to treat this code as public domain in\nthe USA, provided the code can be used under other licenses and he is\ngiven appropriate credit. nmhash32 and nmhash32x are translations to Fortran 2008 and signed\ntwo's complement integers of the unsigned 32-bit\nhashes of James Z. M. Gao's nmhash32 and nmhash32x version of 0.2, https://github.com/gzm55/hash-garage/blob/a8913138bdb3b7539c202edee30a7f0794bbd835/nmhash.h James Z. M. Gao has released his code under the BSD 2 Clause\nLicense. The BSD 2-Clause license is as follows: BSD 2-Clause License Copyright ( c ) 2021 , James Z . M . Gao All rights reserved . Redistribution and use in source and binary forms , with or without modification , are permitted provided that the following conditions are met : 1 . Redistributions of source code must retain the above copyright notice , this list of conditions and the following disclaimer . 2 . Redistributions in binary form must reproduce the above copyright notice , this list of conditions and the following disclaimer in the documentation and / or other materials provided with the distribution . THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED . IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE . water_hash is a translation to Fortran 2008  and signed two's\ncomplement integers of the waterhash algorithm\nof Tommy Ettinger. This algorithm is inspired by the Wy Hash of\nWang Yi. Tommy Ettinger's original C++ code, waterhash.h ,\nis available at URL: https://github.com/tommyettinger/waterhash under\nthe unlicense , https://github.com/tommyettinger/waterhash/blob/master/LICENSE .\nThe unlicense reads as follows: This is free and unencumbered software released into the public domain . Anyone is free to copy , modify , publish , use , compile , sell , or distribute this software , either in source code form or as a compiled binary , for any purpose , commercial or non - commercial , and by any means . In jurisdictions that recognize copyright laws , the author or authors of this software dedicate any and all copyright interest in the software to the public domain . We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors . We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . For more information , please refer to < http : // unlicense . org > pengy_hash is a translation to Fortran 2008 and signed two's\ncomplement arithmetic of the pengyhash algorithm of Alberto Fajardo,\ncopyright 2020. Alberto Fajardo's original C code, pengyhash.c , is\navailable at the URL:\nhttps://github.com/tinypeng/pengyhash/blob/master/pengyhash.c\nunder the BSD 2-Clause License:\nhttps://github.com/tinypeng/pengyhash/blob/master/LICENSE The BSD 2-Clause license is as follows: BSD 2-Clause License pengyhash Copyright ( c ) 2020 Alberto Fajardo All rights reserved . Redistribution and use in source and binary forms , with or without modification , are permitted provided that the following conditions are met : 1 . Redistributions of source code must retain the above copyright notice , this list of conditions and the following disclaimer . 2 . Redistributions in binary form must reproduce the above copyright notice , this list of conditions and the following disclaimer in the documentation and / or other materials provided with the distribution . THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED . IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE . Glossary There are a few words used in this document that may not be familiar to\nreaders of this document: Key - a value to be used to find entries in a hash table typically\n  using its hashed value for the initial search; Salt - see seed, and; Seed - an additional argument to a hash function that changes its\n  output making some attacks impractical. The hash codes modules Overview of the modules The Standard Library provides two modules implementing hash\nfunctions and scalar hashes.\nThe stdlib_hash_32bit module provides procedures to\ncompute 32-bit integer hash codes and a scalar hash.\nThe hash codes can be used for tables of up to 2**30 entries, and\nfor keys with a few hundred elements, but performance has only been\ntested for tables up to 2**16 entries and performance may degrade\nfor larger numbers of entries.\nThe stdlib_hash_64bit module provides hash procedures to\ncompute 64-bit integer hash codes and a scalar hash.\nThe hash codes can, in principle, be used for tables of up to 2**62 entries, and for keys with a few thousand elements, but testing of\nperformance has only been been for tables up to 2**16 elements and\nperformance may degrade for larger numbers of entries.\nWhile one of the codes in stdlib_hash_64bit , SPOOKY_HASH , can also be used to calculate 128 bit hash codes, none\nof the current codes can be used to calculate 256 bit hash codes.\nSuch larger hash codes are useful for larger hash tables and keys, and\nfor checksums.\nSuch larger keys and tables are little used, if used at all, in\ncurrent\nFortran codes, but the larger hash codes may be added to the library\nif there is a demand for them. Hash functions are often divided into two categories\n\"cryptographic\" and \"non-cryptographic\".\nCryptographic hash functions produce codes that are infeasible to\nreverse without additional information beyond the identity of\nthe hash function used to generate the code and the resulting codes.\nNon-cryptographic codes, in some circumstances, are believed to be\nreversible.\nThe modules only implement hash\nfunctions that are considered non-cryptographic, with\nimplementations available in the public domain. There are a number of algorithms available for the computation of\nnon-cryptographic 32 and 64-bit hash codes that differ in their\ncomputational complexity,\ntheir relative performance on different size keys, and the\nexpected uniqueness (randomness) of the resulting hash codes.\nTheir relative performance in the analysis of text, in particular,\ncan depend on the compiler, character set, language, and content.\nThe quality of a hash function is often evaluated using\nthe SMHasher test suite, originally written by Austin Appleby , but greatly\nextended by Reini Urban .\nAll except the simplest, FNV_1 and FNV_1A , of the hash functions\ndefined in the modules perform well on the tests in Reini Urban's\nversion of SMHasher. There are two problems in implementing hash functions in Fortran.\nFirst, the static typing of Fortran makes it awkward to define general\npurpose hash functions.\nInstead hash functions are defined for some of the more common\nobjects: character strings and rank-1 arrays of integers.\nOther objects can, in principle, be hashed by using transfer to\nmap their contents to an integer array, typically one of kind int8 .\nThe other problem is that hash codes are typically defined using\nmodular unsigned integer arithmetic.\nAs such integers are not part of the current Fortran standard,\nworkarounds have to be used.\nThese can take two forms.\nIn one, the operations are emulated by using an integer of a\nlarger size, or, for the larger integers, by dividing the integer into\ntwo lower and higher order halves,\nand performing the operations on each half separately using\nthe larger integers.\nIn the second, the unsigned integers may be replaced directly by\nthe corresponding signed integers, but\notherwise not modifying the code logic.\nThe first should be standard conforming on current compilers, but\nis more computationally intensive unless the compilers recognize\nunderlying idioms that are rarely used in Fortran codes. The second is\nnot standard conforming as bit operations involving the sign are\nundefined,\nbut should yield equivalent results with fewer operations on\ncompilers with two's complement integers that do not trap on over\nor under flow. The codes currently use the second method. In order to compile the hash function modules, the compilers must\nimplement much of Fortran 2003, and selected components of Fortran\n2008: submodules, 64-bit integers, and some bit intrinsics.\nThe main limitation on valid compilers is whether they\nimplement the submodules enhancement of Fortran 2008.\nIn order to properly run the hash functions, the compilers must\nuse two's complement integers, and be able to execute them with\nwraparound semantics and no integer overflow exceptions.\nCurrent Fortran 2003+ compilers solely use two's complement\nintegers, and appear to be able to turn off overflow detection,\nso the modules use signed integer arithmetic. For that reason\ntrapping on signed arithmetic must be disabled. The command line\nflags to disable overflow detection for compilers implementing\nsubmodules are summarized in the table below.\nNote that FLANG, gfortran (since version 10), ifort, and NAG all default to\ninteger overflow wrapping. Compiler Legal flag Illegal flag Default ARM Fortran NA? NA? overflow wrapping? Cray Fortran NA? NA? overflow wrapping? FLANG/PGI -fwrapv -ftrapv -fwrapv gfortran -fwrapv -ftrapv -fwrapv IBM Fortran NA? NA? overflow wrapping? ifort NA? NA? overflow wrapping NAG Fortran -C=none -C=intovf -C=none NEC Fortran NA? NA? overflow wrapping? NVIDIA Fortran NA? NA? overflow wrapping? All of the modules' hash functions take one or two arguments.\nAll of them have as their first argument the object to be hashed,\ntermed a key .\nMost have a second argument, termed a seed , that sets the initial\nvalue of the hash code changing the hash function behavior.\nIn particular, inputs that hash to the same hash index with a given\nseed, will often hash to different indexes with a different seed.\nThis difference in behavior makes algorithms that use a seed much\nmore resistant to denial of service attacks that use the properties\nof a known hash to increase the number of hash table collisions.\nThis additional integer must be kept the same for all hashes\nin a given hash table, but can be changed and the objects rehashed\nif collisions are unusually common.\nThe seed can be either a scalar or a two-element array.\nSome of the hash functions have alternatives that allow incremental\nhashing. Algorithm Seed Result FNV-1 None 32 or 64-bit integer FNV-1a None 32 or 64-bit integer nmhash32 32-bit scalar integer 32-bit integer nmhash32x 32-bit scalar integer 32-bit integer pengyhash 32-bit scalar integer 64-bit integer Spooky Hash 64-bit two element vector 64-bit two element vector waterhash 64-bit scalar integer 32-bit integer The hash function modules each provide at least five algorithms for\nhash functions: two optimized for small (< 32 int8 integer elements)\nkeys, and three optimized for large (> 100 int8 integer elements)\nkeys.\nThe core implementation for each algorithm is for keys that are\nvectors of int8 integers.\nThese core implementations are then used in wrappers for keys\nthat are vectors of int16 , int32 and int64 integers, or default\ncharacter strings, in the expectation that inlining will eliminate the\noverhead of transferring the other keys to int8 integer vectors. The stdlib_hash_32bit module provides\nimplementations of five hash code algorithms:\nthe FNV_1 and FNV_1A variants of Glenn Fowler,\nLandon Curt Noll, and Kiem-Phong Vo;\nthe nmhash32 and nmhash32x of James Z. M. Gao;\nand the waterhash of Tommy Ettinger.\nThe detailed implementation of each algorithm is handled in a separate\nsubmodule: stdlib_hash_32bit_fnv , stdlib_hash_32bit_nm , and stdlib_hash_32bit_water ,\nrespectively. The nmhash32 , nmhash32x , and waterhash algorithms\nrequire seeds. The submodules provide separate seed generators\nfor each algorithm.\nThe module itself\nimplements two scalar hash functions, fibonacci_hash and universal_mult_hash .\nIt also implements the subroutine, odd_random_integer , for\ngenerating seeds for universal_mult_hash .\nAll assume a two's complement sign bit, and no out of\nrange checks. The stdlib_hash_64bit module also provides\nimplementations of four hash code algorithms:\nthe FNV_1 and FNV_1A variants of Glenn Fowler,\nLandon Curt Noll, and Kiem-Phong Vo;\nthe pengyhash of Alberto Fajardo;\nand the SpookyHash of Bob Jenkins.\nThe detailed implementation of each algorithm is handled in a separate\nsubmodule: stdlib_hash_64bit_fnv , stdlib_hash_64bit_pengy , and stdlib_hash_64bit_spooky ,\nrespectively.\nThe pengyhash , and Spooky Hash algorithms\nrequire seeds. The submodules provide separate seed generators\nfor each algorithm.\nThe module itself implements two scalar hash functions, fibonacci_hash and universal_mult_hash .\nIt also implements the subroutine, odd_random_integer , for\ngenerating seeds for universal_mult_hash .\nAll assume a two's complement sign bit, and no out of\nrange checks. The stdlib_hash_32bit_fnv and stdlib_hash_64bit_fnv submodules each provide implementations of the FNV-1 and FNV-1A\nalgorithms in the form of two separate overloaded functions: FNV_1 and FNV_1A .\nThe FNV-1 and FNV-2 algorithms differ in their order of the\nmultiplication and exclusive or operations.\nThey differ from their normal implementation in that they also\nencode the structure size in the hash code.\nThe 32 and 64-bit algorithms differ in their initial offsets and in\ntheir multiplicative constants.\nAnalysis suggests that FNV_1A should be better at randomizing the\ninput, but tests with hash tables show negligible difference.\nThese algorithms have the reputation of being particularly useful for\nsmall byte strings, i.e., strings of less than 32 bytes.\nWhile they do not at all perform well on the SMHasher test suite,\nusage indicates that this has little impact on the\nperformance of small hash tables, and the small size of the functions\nallows their quick loading and retainment in the instruction cache,\ngiving a performance boost where the hashing is intermittent.\n(See the SMHasher discussion and S. Richter, V. Alvarez, and J. Dittrich. 2015. A Seven-Dimensional Analysis of Hashing Methods and its Implications on Query Processing, Proceedings of the VLDB Endowment, Vol. 9, No. 3. https://doi.org/10.14778/2850583.2850585 . The stdlib_hash_32bit_nm submodule provides implementations\nof James Z.M. Gao's nmhash32 and nmhash32x algorithms,\nversion 0.2,\nin the form of the overloaded functions, nmhash32 and nmhash32x .\nThe implementations are based on the scalar versions of Gao's\nalgorithms and not the vector versions that require access to\nthe vector instructions of some compilers.\nBoth algorithms perform well on the SMHasher tests, and have no known\nbad seeds. The vector versions of both codes perform well on large\nkeys, with the nmhash32x faster on short keys. To provide randomly\ngenerated seeds for the two functions the submodule also defines the\nsubroutines new_nmhash32_seed and new_nmhash32x_seed . Gao claims\nthat nmhash32x is significantly faster than nmhash32 on short\nseeds, but slower on long seeds, but our limited testing so far shows nmhash32x to be significantly faster on short seeds and slightly\nfaster on long seeds. The stdlib_hash_32bit_water submodule provides implementations\nof Tommy Ettinger's waterhash algorithm in the form of the overloaded\nfunction, water_hash . Water Hash has not been tested by Reini Urban,\nbut Tommy Ettinger has tested it with Urban's SMHasher and presents\nresults that shows Water Hash passing all the tests. So far his\ntesting hasn't found any bad seeds for the algorithm. To provide\nrandomly generated seeds for the hash function the submodule also\ndefines the subroutine new_water_hash_seed . The stdlib_hash_64bit_pengy submodule provides implementations of\nAlberto Fajardo's pengyhash in the form of the overloaded function, pengy_hash . Reini Urban's testing shows that PengyHash passes all\nthe tests and has no bad seeds.  To provide randomly generated seeds\nfor the hash function the submodule also defines the subroutine new_pengy_hash_seed . The stdlib_hash_64bit_spooky submodule provides implementations\nof Bob Jenkins' SpookyHash in the form of the overloaded function, spooky_hash . Future implementations may provide the SpookyHash\nincremental hashing procedures.\nSpookyHash is optimized for large objects and should give excellent\nperformance for objects greater than about 96 byes, but has\nsignificant overhead for smaller objects.\nThe code was designed for little-endian compilers, and will give\ndifferent results on big-endian compilers, but the hash quality on\nthose compilers is probably just as good.\nSpookyHash version 2 passes all of Reini Urban's SMHasher tests, and\nhas one bad seed only when reduced to a 32-bit output.\nIts only potential problem is undefined behavior if the key is\nmisaligned. The stdlib_hash_32bit module Overview of the module Thirty two bit hash functions are primarily useful for generating hash\ncodes and hash indices for hash tables.\nThey tend to be less useful for generating checksums, which generally\nbenefit from having a larger number of bits.\nThe stdlib_hash_32bit module defines five public overloaded\n32-bit hash code functions, FNV_1 , FNV-1A , nmhash32 , nmhash32x and water_hash , two scalar hash functions, fibonacci_hash and universal_mult_hash , four seed generators, odd_random_integer for universal_mult_hash , and new_nmhash32_seed , new_nmhash32x_seed ,\nand new_water_hash_seed , for their respective hash code\nfunctions. It also defines the integer kind constant, int_hash , and\na logical constant, little_endian , used to deal with one aspect of\nthe machine dependence of the hash codes. The int_hash parameter It is necessary to define the kind of integer used to return the hash\ncode.\nAs stdlib_hash_32bit deals exclusively with 32-bit hash codes, int_hash is an alias for the integer kind int32 . The little_endian parameter In implementing hash functions it is sometimes necessary to know the\n\"endianess\" of the compiler's integers. To this end the stdlib_hash_32bit module defines the logical parameter little_endian that, if true, indicates that the compiler has\nlittle-endian integers, and that if false indicates that the integers\nare big-endian. Specifications of the stdlib_hash_32bit procedures fibonacci_hash - maps an integer to a smaller number of bits Status Experimental Description Calculates an nbits hash code from a 32-bit integer. This is useful\nin mapping hash codes into small arrays. Syntax code = stdlib_hash_32bit ( key, nbits ) Class Elemental function Arguments key : Shall be a scalar integer expression of kind int32 . It is an intent(in) argument. nbits Shall be a scalar default integer expression with 0 < nbits <\n32 . It is an intent(in) argument. Result The result is an integer of kind int32 with at most the lowest nbits nonzero, mapping to a range 0 to nbits-1 . Note fibonacci_hash is an implementation of the Fibonacci Hash of Donald\nE. Knuth. It multiplies the key by the odd valued approximation to 2**32/phi , where phi is the golden ratio 1.618..., and returns the nbits upper bits of the product as the lowest bits of the result. Example fnv_1_hash - calculates a hash code from a key Status Experimental Description Calculates a 32-bit hash code from a rank-1 integer array or a default\ncharacter string. Syntax code = stdlib_hash_32bit ( key ) Class Pure/elemental function Argument key : Shall be a deferred length default character scalar expression\nor a rank-1 integer array expression of kind int8 , int16 , int32 , or int64 .\nIt is an intent(in) argument. Result The result is a scalar integer of kind int32 . Note fnv_1_hash is an implementation of the original FNV-1 hash code of Glenn\nFowler, Landon Curt Noll, and Phong Vo.\nIt differs from typical implementations in that it also encodes the\nsize of the structure in the hash code.\nThis code is relatively fast on short keys, and is small enough that it\nwill often be retained in the instruction cache if hashing is\nintermittent.\nAs a result it should give good performance for typical hash table\napplications.\nThis code does not pass any of the SMHasher tests, but the resulting\ndegradation in performance due to its larger number of collisions is\nexpected to be minor compared to its faster hashing rate.\nIt is a pure function for integer arrays, and an elemental function for character strings. Example fnv_1a_hash - calculates a hash code from a key Status Experimental Description Calculates a 32-bit hash code from a rank-1 integer array or a default\ncharacter string. Syntax code = stdlib_hash_32bit ( key ) Class Pure/elemental function Argument key : Shall be a deferred length default character scalar expression\nor a rank-1 integer array expression of kind int8 , int16 , int32 , or int64 .\nIt is an intent(in) argument. Result The result is a scalar integer of kind int32 . Note fnv_1a_hash is an implementation of the alternative FNV-1a hash code of\nGlenn Fowler, Landon Curt Noll, and Phong Vo.\nIt differs from typical implementations in that it also encodes the\nsize of the structure in the hash code.\nThis code is relatively fast on short keys, and is small enough that it\nwill often be retained in the instruction cache if hashing is\nintermittent.\nAs a result it should give good performance for typical hash table\napplications.\nThis code does not pass any of the SMHasher tests, but the resulting\ndegradation in performance due to its larger number of collisions is\nexpected to be minor compared to its faster hashing rate.\nIt is a pure function for integer arrays, and an elemental function for character strings. Example new_nmhash32_seed - returns a valid input seed for nmhash32 Status Experimental Description Calculates a 32-bit \"random\" integer that is believed to be a valid\nseed for nmhash32 and is also different from the input seed. Syntax call stdlib_hash_32bit ( seed ) Class Subroutine Argument seed : shall be a defined integer scalar variable of kind int32 .\nIt is an intent(inout) argument. On input seed should be defined,\nand on output it will be different from the input seed . Note Currently there are no known bad seeds for nmhash32 , but if any are\nidentified the procedure will be revised so that they cannot be\nreturned. This subroutine uses Fortran's intrinsic random_number and the values returned can be changed by calling the\n intrinsic random_init . Example See the example for nmhash32 . new_nmhash32x_seed - returns a valid input seed for nmhash32x Status Experimental Description Calculates a 32-bit \"random\" integer that is believed to be a valid\nseed for nmhash32x and is also different from the input seed. Syntax call stdlib_hash_32bit ( seed ) Class Subroutine Argument seed : shall be a defined integer scalar variable of kind int32 .\nIt is an intent(inout) argument. On input seed should be defined,\nand on output it will be different from the input seed . Note Currently there are no known bad seeds for nmhash32x , but if any are\nidentified the procedure will be revised so that they cannot be\nreturned. This subroutine uses Fortran's intrinsic random_number and the values returned can be changed by calling the\n intrinsic random_init . Example See the example for nmhash32x . new_water_hash_seed - returns a valid input seed for water_hash Status Experimental Description Calculates a 64-bit \"random\" integer that is believed to be a valid\nseed for water_hash and is also different from the input seed. Syntax call stdlib_hash_32bit ( seed ) Class Subroutine Argument seed : shall be a defined integer scalar variable of kind int64 .\nIt is an intent(inout) argument. On input seed should be defined,\nand on output it will be different from the input seed . Note Currently there are no known bad seeds for water_hash , but if any\nare identified the procedure will be revised so that they cannot be\nreturned. This subroutine uses Fortran's intrinsic random_number and the values returned can be changed by calling the\n intrinsic random_init . Example See the example for water_hash . nmhash32 - calculates a hash code from a key and a seed Status Experimental Description Calculates a 32-bit hash code from a rank-1 integer array or a default\ncharacter string, and the input seed . Syntax code = stdlib_hash_32bit ( key, seed ) Class Pure/elemental function Arguments key : Shall be a deferred length default character scalar expression\nor a rank-1 integer array expression of kind int8 , int16 , int32 , or int64 .\nIt is an intent(in) argument. seed : shall be an integer scalar expression of kind int32 .\nIt is an intent(in) argument. Result The result is a scalar integer of kind int32 . Note nmhash32 is an implementation of the nmhash32 hash code of\nJames Z. M. Gao.\nThis code has good, but not great, performance on long keys, poorer\nperformance on short keys.\nAs a result it should give fair performance for typical hash table\napplications.\nThis code passes the SMHasher tests, and has no known bad seeds.\nIt is a pure function for integer arrays, and an elemental function for character strings. Example nmhash32x - calculates a hash code from a key and a seed Status Experimental Description Calculates a 32-bit hash code from a rank-1 integer array or a default\ncharacter string, and the input seed . Syntax code = stdlib_hash_32bit ( key, seed ) Class Pure/elemental function Arguments key : Shall be a deferred length default character scalar expression\nor a rank-1 integer array expression of kind int8 , int16 , int32 , or int64 .\nIt is an intent(in) argument. seed : shall be an integer scalar expression of kind int32 .\nIt is an intent(in) argument. Result The result is a scalar integer of kind int32 . Note nmhash32x is an implementation of the nmhash32x hash code of\nJames Z. M. Gao.\nThis code has good, but not great, performance on long keys, poorer\nperformance on short keys.\nAs a result it should give fair performance for typical hash table\napplications.\nThis code passes the SMHasher tests, and has no known bad seeds.\nIt is a pure function for integer arrays, and an elemental function for character strings. Example odd_random_integer - returns an odd integer Status Experimental Description Returns a random 32-bit integer distributed uniformly over the odd values. Syntax call stdlib_hash_32bit ( harvest ) Class Subroutine Argument harvest : Shall be a scalar integer variable of kind int32 . It is\nan intent(out) argument. Note odd_random_integer is intended to generate seeds for universal_mult_hash . odd_random_integer uses Fortran's intrinsic random_number and the values returned can be changed by calling the\n intrinsic random_init . Example See universal_mult_hash . universal_mult_hash - maps an integer to a smaller number of bits Status Experimental Description Calculates an nbits hash code from a 32-bit integer. This is useful\nin mapping a hash value to a range 0 to 2**nbits-1 . Syntax code = stdlib_hash_32bit ( key, seed, nbits ) Class Elemental function Arguments key : Shall be a scalar integer expression of kind int32 . It is an intent(in) argument. seed : Shall be a scalar integer expression of kind int32 . It is an intent(in) argument. It must have an odd value. nbits Shall be a scalar default integer expression with 0 < nbits <\n32 . It is an intent(in) argument. Result The result is a scalar integer of kind int32 with at most the lowest nbits nonzero. Note universal_mult_hash is an implementation of the Universal\nMultiplicative Hash of M. Dietzfelbinger, et al.\nIt multiplies the key by seed , and returns the nbits upper bits of the product as the lowest bits of the result. Example water_hash - calculates a hash code from a key and a seed Status Experimental Description Calculates a 32-bit hash code from a rank-1 integer array or a default\ncharacter string, and the input seed . Syntax code = stdlib_hash_32bit ( key, seed ) Class Pure/elemental function Arguments key : Shall be a deferred length default character scalar expression\nor a rank-1 integer array expression of kind int8 , int16 , int32 , or int64 .\nIt is an intent(in) argument. seed : shall be an integer scalar expression of kind int64 .\nIt is an intent(in) argument. Result The result is a scalar integer of kind int32 . Note water_hash is an implementation of the waterhash hash code of\nTommy Ettinger.\nThis code has excellent performance on long keys, and good performance\non short keys.\nAs a result it should give reasonable performance for typical hash\ntable applications.\nThis code passes the SMHasher tests.\nThe waterhash is based on the wyhash of Wang Yi.\nWhile wyhash has a number of bad seeds, where randomization of the\noutput is poor,\nso far testing has not found any bad seeds for waterhash .\nIt can have undefined behavior if the key is not word aligned,\ni.e. some computer processors can only process a given size integer if\nthe address of the integer is a multiple of the integer size.\nIt is a pure function for integer arrays, and an elemental function for character strings. Example The stdlib_hash_64bit module Overview of the module Sixty-four bit hash functions are generally overkill for hash table\napplications, and are primarily useful for check sums and related\napplications.\nAs checksums often have to deal with extremely large files or\ndirectories, it is often useful to use incremental hashing as well as\ndirect hashing, so 64-bit and higher hash algorithms often provide\nmultiple implementations. The current module, for simplicity of API,\ndoesn't provide any incremental hashes.\nThe stdlib_hash_64bit module defines several public\noverloaded 64-bit hash procedures, FNV_1 , FNV-1A , pengy_hash , and spooky_hash , two scalar hash functions, fibonacci_hash and universal_mult_hash , a seed generator, odd_random_integer , for the universal_mult_hash , and two seed generators, new_pengy_hash_seed and new_spooky_hash_seed for their respective hash functions. It\nalso defines the integer kind constant, int_hash , used to specify\nthe kind of the hash function results, and a logical constant, little_endian , used to deal with one aspect of the machine\ndependence of the hash codes.\nNote that while SpookyHash can be used as a sixty-four bit hash\nalgorithm, its algorithms actually returns two element integer arrays\nof kind int64 , so it can also be used as a 128 bit hash. The int_hash parameters It is necessary to define the kind of integer used to return the hash\ncode.\nAs stdlib_haash_64bit deals exclusively with 64-bit hash codes, int_hash is an alias for the integer kind int64 . The little_endian parameter In implementing hash functions it is sometimes necessary to know the\n\"endianess\" of the compiler's integers. To this end the stdlib_hash_64bit module defines the logical parameter little_endian that if true indicates that the compiler has\nlittle-endian integers, and that if false indicates that the integers\nare big-endian. Specifications of the stdlib_hash_64bit procedures fibonacci_hash - maps an integer to a smaller number of bits Status Experimental Description Calculates an nbits hash code from a 64-bit integer. This is useful\nin mapping hash codes into small arrays. Syntax code = stdlib_hash_64bit ( key, nbits ) Class Elemental function Arguments key : Shall be a scalar integer expression of kind int64 . It is an intent(in) argument. nbits Shall be a scalar default integer expression with 0 < nbits <\n64 . It is an intent(in) argument. Result The result is an integer of kind int64 with at most the lowest nbits nonzero, mapping to a range 0 to nbits-1 . Note fibonacci_hash is an implementation of the Fibonacci Hash of Donald\nE. Knuth. It multiplies the key by the odd valued approximation to 2**64/phi , where phi is the golden ratio 1.618..., and returns the nbits upper bits of the product as the lowest bits of the result. Example FNV_1 - calculates a hash code from a key Status Experimental Description Calculates a 64-bit hash code from a rank-1 integer array or a default\ncharacter string. Syntax code = stdlib_hash_64bit ( key ) Class Pure/elemental function Argument key : Shall be a deferred length default character scalar expression\nor a rank-1 integer array expression of kind int8 , int16 , int32 , or int64 .\nIt is an intent(in) argument. Result The result is a scalar integer of kind int64 . Note FNV_1 is an implementation of the original FNV-1 hash code of Glenn\nFowler, Landon Curt Noll, and Phong Vo.\nIt differs from typical implementations in that it also ecodes the\nsize of the structure in the hash code.\nThis code is relatively fast on short keys, and is small enough that it\nwill often be retained in the instruction cache if hashing is\nintermittent.\nAs a result it should give good performance for typical hash table\napplications, although it is rare for them to need 64 bits.\nThis code does not pass any of the SMHasher tests, but the resulting\ndegradation in performance due to its larger number of collisions is\nexpected to be minor compared to its faster hashing rate.\nIt is a pure function for integer arrays, and an elemental function for character strings. Example FNV_1A - calculates a hash code from a key Status Experimental Description Calculates a 64-bit hash code from a rank-1 integer array or a default\ncharacter string. Syntax code = stdlib_hash_64bit ( key ) Class Pure/elemental function Argument key : Shall be a deferred length default character scalar expression\nor a rank-1 integer array expression of kind int8 , int16 , int32 , or int64 .\nIt is an intent(in) argument. Result The result is a scalar integer of kind int32 . Note FNV_1A is an implementation of the alternative FNV-1a hash code of\nGlenn Fowler, Landon Curt Noll, and Phong Vo.\nIt differs from typical implementations in that it also encodes the\nsize of the structure in the hash code.\nThis code is relatively fast on short keys, and is small enough that it\nwill often be retained in the instruction cache if hashing is\nintermittent.\nAs a result it should give good performance for typical hash table\napplications.\nThis code does not pass any of the SMHasher tests, but the resulting\ndegradation in performance due to its larger number of collisions is\nexpected to be minor compared to its faster hashing rate.\nIt is a pure function for integer arrays, and an elemental function for character strings. Example new_pengy_hash_seed - returns a valid input seed for pengy_hash Status Experimental Description Calculates a 32-bit \"random\" integer that is believed to be a valid\nseed for pengy_hash and is also different from the input seed. Syntax call stdlib_hash_64bit ( seed ) Class Subroutine Argument seed : shall be a defined integer scalar variable of kind int32 .\nIt is an intent(inout) argument. On input seed should be defined,\nand on output it will be different from the input seed . Note Currently there are no known bad seeds for pengy_hash , but if any are\nidentified the procedure will be revised so that they cannot be\nreturned.  This subroutine uses Fortran's intrinsic random_number and the values returned can be changed by calling the\n intrinsic random_init . Example See the example for pengy_hash . new_spooky_hash_seed - returns a valid input seed for spooky_hash Status Experimental Description Calculates a 32-bit two element vector of \"random\" integer values that\nis believed to be a valid seed for spooky_hash and is also different\nfrom the input seed. Syntax call stdlib_hash_64bit ( seed ) Class Subroutine Argument seed : shall be a defined two element integer vector variable of kind int32 . It is an intent(inout) argument. On input seed should be\ndefined, and on output it will be different from the input seed . Note Currently there are no known bad seeds for spooky_hash , but if any are\nidentified the procedure will be revised so that they cannot be\nreturned.  This subroutine uses Fortran's intrinsic random_number and the values returned can be changed by calling the\n intrinsic random_init . Example See the example for spooky_hash . odd_random_integer - returns odd integer Status Experimental Description Returns a random 64-bit integer distributed uniformly over the odd values. Syntax call stdlib_hash_64bit ( harvest ) Class Subroutine Argument harvest : Shall be an integer of kind int64 . It is an intent(out) argument. Note odd_random_integer is intended to generate seeds for universal_mult_hash . odd_random_integer uses Fortran's intrinsic random_number and the values returned can be changed by calling the\n intrinsic random_init . Example See universal_mult_hash . pengy_hash - maps a character string or integer vector to an integer Status Experimental Description Maps a character string or integer vector to a 64-bit integer whose\nvalue also depends on a scalar 32-bit integer, seed . Syntax code = stdlib_hash_64bit ( key, seed ) Class Pure/elemental function Arguments key : shall be a scalar  expression of type default character or a\nrank-1 integer vector expression of kind int8 , int16 , int32 , or int64 . It is an intent(in) argument. seed : shall be an integer expression of kind int64 . It is\nan intent(in) argument. Result The result is an integer of kind int64 . Note pengy_hash is an implementation of the 64-bit pengyhash of Alberto\nFajardo. The hash has acceptable performance on small keys, and good\nperformance on long keys. It passes all the SMHasher tests, and has\nno known bad seeds.\nIt is a pure function for integer arrays, and an elemental function for character strings. Example spooky_hash - maps a character string or integer vector to an integer Status Experimental Description Maps a character string or integer vector to a 64-bit integer whose\nvalue also depends on a two element vector, seed . Syntax code = stdlib_hash_64bit ( key, seed ) Class Function Arguments key : shall be a scalar of type default character expression or a\nrank-1 integer vector expression of kind int8 , int16 , int32 , or int64 . It is an intent(in) argument. seed : shall be a two element integer vector expression of kind int64 . It is an intent(in) argument. Result The result is a two element integer vector of kind int64 . Note spooky_hash is an implementation of the 64-bit version 2 of\nSpookyHash of Bob Jenkins. The code was designed for little-endian\ncompilers. The output is different on big-endian compilers, but still\nprobably as good quality. It is often used as a 64-bit hash using the\nfirst element of the returned value, but can be used as a 128 bit\nhash. This version of spooky_hash has good performance on small keys\nand excellent performance on long keys. It passes all the SMHasher tests\nand has no known bad seeds. Example universal_mult_hash - maps an integer to a smaller number of bits Status Experimental Description Calculates an nbits hash code from a 64-bit integer. This is useful\nin mapping a hash value to a range 0 to 2**nbits-1 . Syntax code = stdlib_hash_64bit ( key, seed, nbits ) Class Elemental function Arguments key : Shall be an integer of kind int64 . It is an intent(in) argument. seed : Shall be an integer of kind int64 . It is an intent(in) argument. It should be an odd value. nbits Shall be a default integer with 0 < nbits < 64 . It is an intent(in) argument.  It must be an odd integer. Result The result is an integer of kind int64 with at most the lowest nbits nonzero. Note universal_mult_hash is an implementation of the Universal\nMultiplicative Hash of M. Dietzfelbinger, et al.\nIt multiplies the key by seed , and returns the nbits upper bits of the product as the lowest bits of the result. Example Test Codes The Fortran Standard Library provides two categories of test\ncodes. One category is tests of the relative performance of the\nvarious hash functions. The other is a comparison of the outputs of\nthe Fortran hash functions, with the outputs of the C and C++ hash\nprocedures that are the inspiration for the Fortran hash functions. In the test/hash_functions_perf subdirectory, the Fortran Standard\nLibrary provides two performance test codes for\nthe hash functions of stdlib_hash_32bit and stdlib_hash_64bit , test_32_bit_hash_performance and test_64_bit_hash_performance respectively. These are primarily set\nup to test runtime performance of the functions. They take a sample of 2**18 integers of kind int8 and break it up into vectors of size\n1, 2, 4, 8, 16, 64,  256, and 1024 elements, yielding 2**18 , 2**17 , 2**16 , 2**15 , 2**14 , 2**12 , 2**10 , and 2**8 vectors respectively. These are then processed by the hash functions\n4 times, and the time for processing is reported. Testing so far has\nbeen on a MacBook Pro with a 2.3 GHz Quad-Core Intel Core i5 and 8 GB\n2133 MHz LPDDR3 of RAM, using GNU Fortran (GCC) 11.1.0 to compile the\ncode. The results for test_32_bit_hash_performance is given by the\nfollowing table: Algorithm Key Size Bytes Key # Time (s) FNV-1 1 1048576 0.02949 FNV-1 2 524288 0.02361 FNV-1 4 262144 0.02016 FNV-1 8 131072 0.01806 FNV-1 16 65536 0.01867 FNV-1 64 16384 0.01717 FNV-1 256 4096 0.01759 FNV-1 1024 1024 0.01659 FNV-1a 1 1048576 0.02897 FNV-1a 2 524288 0.02472 FNV-1a 4 262144 0.02025 FNV-1a 8 131072 0.01901 FNV-1a 16 65536 0.01898 FNV-1a 64 16384 0.01784 FNV-1a 256 4096 0.01723 FNV-1a 1024 1024 0.01673 nmhash32 1 1048576 0.31092 nmhash32 2 524288 0.16230 nmhash32 4 262144 0.07815 nmhash32 8 131072 0.04176 nmhash32 16 65536 0.09261 nmhash32 64 16384 0.04587 nmhash32 256 4096 0.07238 nmhash32 1024 1024 0.07263 nmhash32x 1 1048576 0.04294 nmhash32x 2 524288 0.02937 nmhash32x 4 262144 0.01096 nmhash32x 8 131072 0.00911 nmhash32x 16 65536 0.01291 nmhash32x 64 16384 0.00859 nmhash32x 256 4096 0.07373 nmhash32x 1024 1024 0.07618 water 1 1048576 0.12560 water 2 524288 0.06302 water 4 262144 0.04020 water 8 131072 0.01999 water 16 65536 0.01459 water 64 16384 0.00923 water 256 4096 0.00816 water 1024 1024 0.00792 while for test_64_bit_hash_performance the results are: Algorithm Key Size Bytes Key # Time (s) FNV-1 1 1048576 0.02981 FNV-1 2 524288 0.02697 FNV-1 4 262144 0.02275 FNV-1 8 131072 0.02431 FNV-1 16 65536 0.02158 FNV-1 64 16384 0.02007 FNV-1 256 4096 0.01932 FNV-1 1024 1024 0.02089 FNV-1a 1 1048576 0.03226 FNV-1a 2 524288 0.03076 FNV-1a 4 262144 0.02359 FNV-1a 8 131072 0.02542 FNV-1a 16 65536 0.02364 FNV-1a 64 16384 0.02130 FNV-1a 256 4096 0.01962 FNV-1a 1024 1024 0.01966 Pengy 1 1048576 0.24294 Pengy 2 524288 0.12066 Pengy 4 262144 0.06205 Pengy 8 131072 0.03138 Pengy 16 65536 0.01608 Pengy 64 16384 0.00669 Pengy 256 4096 0.00387 Pengy 1024 1024 0.00295 Spooky 1 1048576 0.11920 Spooky 2 524288 0.07478 Spooky 4 262144 0.03185 Spooky 8 131072 0.01468 Spooky 16 65536 0.01503 Spooky 64 16384 0.00440 Spooky 256 4096 0.00290 Spooky 1024 1024 0.00177 As the tested function will typically reside in the instruction cache\nthese results do not include the costs of reloading the procedure if\nhashing is intermittent. If hashing is intermittent then that can more\nseverely impact the performance of nmhash32 , nmhash32x , water_hash , pengy_hash , and spooky_hash relative to fnv_1_hash and fnv_1a_hash . In the test/hash_functions subdirectory, the Fortran\nStandard Library contains codes to test the validity of\nthe Fortran codes against the original C and C++ codes. It consists of one\nexecutable test_hash_functions that\n1) generates a random sequence of 2048\nintegers of kind int8 , and stores that sequence in the binary file key_array.bin ;\n2) reads the values in key_array.bin , and, for each complicated C/C++-coded\nhash procedure, generates a corresponding binary file containing 2049 hash\nvalues generated from the values in key_array.bin ., and\n3) reads the binary files, and, for each complicated C/C++-coded hash procedure,\ncompares the contents of the binary file\nwith the results of calculating hash values using the corresponding\nFortran hash procedure on the same keys.","tags":"","url":"page/specs/stdlib_hash_procedures.html"},{"title":"Hash maps – LightConvex","text":"The stdlib_hashmap_wrappers , and stdlib_hashmaps modules The stdlib_hashmap_wrappers, and stdlib_hashmaps modules Overview of hash maps Licensing The hash map modules The stdlib_hashmap_wrappers module The stdlib_hashmap_wrappers's constant, int_hash The stdlib_hashmap_wrappers' module's derived types Table of stdlib_hashmap_wrappers procedures Specifications of the stdlib_hashmap_wrappers procedures copy_key - Returns a copy of the key Status Description Syntax Class Arguments Example fibonacci_hash - maps an integer to a smaller number of bits Status Description fnv_1_hasher- calculates a hash code from a key Status Description Syntax Class Argument Result character Result value Note Example fnv_1a_hasher- calculates a hash code from a key Status Description Syntax Class Argument Result character Result value Note Example free_key - frees the memory associated with a key Status Description Syntax Class Argument Example get - extracts the data from a derived type Status Description Syntax Class Argument Example hasher_fun- serves as a function prototype. Status Description Syntax Class Argument Result character Result value Note Example operator(==) - Compares two keys for equality Status Description Syntax Class Arguments Result character Result value Example seeded_nmhash32_hasher- calculates a hash code from a key Status Description Syntax Class Argument Result character Result value Note Example seeded_nmhash32x_hasher- calculates a hash code from a key Status Description Syntax Class Argument Result character Result value Note Example seeded_water_hasher- calculates a hash code from a key Status Description Syntax Class Argument Result character Result value Note Example set - places the data in a derived type Status Description Syntax Class Argument Note Example The stdlib_hashmaps module The stdlib_hashmaps module's public constants The stdlib_hashmaps module's derived types The hashmap_type abstract type The chaining_map_entry_type derived type The chaining_map_entry_ptr derived type The chaining_map_entry_pool derived type The chaining_hashmap_type derived type The open_map_entry_type derived type The open_map_entry_ptr derived type The open_hashmap_type derived type Table of stdlib_hashmap procedures Specifications of the stdlib_hashmaps procedures calls - Returns the number of calls on the hash map Status Description Syntax Class Argument Result character Result value Example entries - Returns the number of entries in the hash map Status Description Syntax Class Argument Result character Result value Example get_all_keys - Returns all the keys contained in a map Status Description Syntax Class Arguments Example get_other_data - Returns other data associated with the key Status Description Syntax Class Arguments Example init - initializes a hash map Status Description Syntax Class Arguments Example key_test - indicates whether key is present Status Description Syntax Class Arguments Example loading - Returns the ratio of entries to slots Status Description Syntax Class Argument Result character Result value Example map_entry - inserts an entry into the hash map Status Description Syntax Class Arguments Example map_probes - returns the number of hash map probes Status Description Syntax Class Argument Result character Result value Example num_slots - returns the number of hash map slots. Status Description Syntax Class Argument Result character Result value Example rehash - changes the hashing function Status Description Syntax Class Arguments Example remove - removes an entry from the hash map Status Description Syntax Class Arguments Example set_other_data - replaces the other data for an entry Status Description Syntax Class Arguments Example slots_bits - returns the number of bits used to address the hash map slots Status Description Syntax Class Argument Result character Result value Example total_depth - returns the total depth of the hash map entries Status Description Syntax Class Argument Result character Result value Example Overview of hash maps A hash map (hash table) is a data structure that maps keys to values . It uses a hash function to compute a hash code from the key that serves as an index into a linear array of slots (buckets) from\nwhich the desired value can be extracted.\nEach key ideally maps to a unique slot, but most hash functions are\nimperfect and can map multiple keys to the same slot resulting in\ncollisions. Hash maps differ in how they deal with such collisions.\nThis document discusses the hash maps in the Fortran Standard Library. Licensing The Fortran Standard Library is distributed under the MIT License.\nHowever components of the library should be evaluated as to whether\nthey are compatible with the MIT License.\nThe current hash maps were inspired by an implementation of David\nChase. While the code has been greatly modified from his\nimplementation, he has give permission for the unrestricted use of\nhis code. The hash map modules The Fortran Standard Library provides two modules for the\nimplementation of simple hash maps. These maps only accept hash\nfunctions with a single argument, the key, and yield a 32 bit\nhash code. The modules will need to be modified if it is desired to\nuse hash functions with a different API. The two modules are: stdlib_hashmap_wrappers , and stdlib_hashmaps corresponding to the\nfiles: stdlib_hashmap_wrappers.f90 , and stdlib_hashmaps.f90 The module stdlib_hashmap_wrappers provides types and procedures for\nuse by stdlib_hashmaps . It provides an\ninterface to the 32 bit hash functions of the Standard Library module, stdlib_hash_32bit , and provides wrappers to some of the\nhash functions so that they no longer need to be supplied seeds. It\nalso defines the key_type derived type. The key_type is used to\ndefine keys that, in turn, are used to identify the data entered into\na hash map. The module stdlib_hashmaps defines the API for a parent datatype, hashmap_type and two extensions of that hash map type: chaining_hashmap_type and open_hashmap_type . The hashmap_type defines the Application Programmers\nInterface (API) for the procedures used by its two extensions. It\nexplicitly defines five non-overridable procedures. It also defines\nthe interfaces for eleven deferred procedures. It does not define the\nfinalization routines for the two extension types, or one routine\nprovided by the open_hashmap_type . The chaining_hashmap_type uses separate chaining with linked\nlists to deal with hash index collisions. In separate chaining the\ncolliding indices are handled by using linked lists with their roots\nat the hash index. The chaining_hashmap_type procedures are\nimplemented in the module stdlib_hashmap_chaining corresponding\nto the file, stdlib_hashmap_chaining.f90 . The open_hashmap_type uses linear open addressing to deal with hash index collisions. In\nlinear open addressing the colliding indices are\nhandled by searching from the initial hash index in increasing\nsteps of one (modulo the hash map size) for an open map slot.\nThe open_hashmap_type procedures are implemented in the submodule stdlib_hashmap_open corresponding to the file stdlib_hashmap_open.f90 . The maps use powers of two for their slot sizes, so that the function, fibonacci_hash , can \nbe used to map the hash codes to indices in the map. This is\nexpected to be more efficient than prime number mapping using a\nmodulo operation, and reduces the requirement that the hash\nfunction need to do a good job randomizing its lower order bits.\nThey do require a good randomizing hash method for good performance.\nBoth adjust the map size to reduce collisions, based on \nthe ratio of the number of hash map probes to the number of subroutine \ncalls.\nWile the maps make extensive use of pointers internally, a private\nfinalization subroutine avoids memory leaks.\nThe maps can take entry keys of type key_type , and other data (also\ncommonly known as values, as in key value pairs) in any scalar type. \nThe maps allow the addition, removal, and lookup of entries, and the\ninclusion of data in addition to the entry key. The stdlib_hashmap_wrappers module The stdlib_hashmap_wrappers module provides data types to\nrepresent keys and associated data stored in a module, but is also, a\nwrapper for the stdlib_hash_32bit module. It allows\ndirect access to the stdlib_hash_32bit procedures: fibonacci_hash , fnv_1_hasher , fnv_1a_hasher ; and provides\nwrapper functions, seeded_nmhash32_hasher , seeded_nmhash32x_hasher , and seeded_water_hasher to the hash\nfunctions: nmhash32 , nmhash32x , and water_hash , respectively. It\ndefines an interface, hasher_fun , compatible with the hash functions\nthat take a non-scalar key . It defines one integer constant used\nas a kind value, int_hash . It also defines two types, key_type and other_type , and associated procedures, for storing and manipulating\nkeys and their associated data. The stdlib_hashmap_wrappers 's constant, int_hash The constant int_hash is used to define the integer kind value for\nthe returned hash codes and variables used to access them. It\ncurrently is imported from stdlib_hash_32bit where it has the\nvalue, int32 . The stdlib_hashmap_wrappers ' module's derived types The stdlib_hashmap_wrappers defines key_type which is intended to\nbe used for the search keys of hash tables. The tye is opaque.\nThe current representation is as follows type :: key_type private integer ( int8 ), allocatable :: value (:) end type key_type The module also defines six procedures for those types: copy_key , equal_keys , free_key , get , set , and one operator, == ,\nfor use by the hash maps to manipulate or inquire of components of\nthose types. Table of stdlib_hashmap_wrappers procedures The stdlib_hashmap_wrappers module provides procedures in\nseveral categories: procedures to manipulate data of the key_type ;\nand 32 bit hash functions for keys. The procedures in each category \nare listed below. It also provides an operator to compare two key \ntype values for equality. Procedures to manipulate key_type data: copy_key( key_in, key_out ) - Copies the contents of the key, key_in , to contents of the key, key_out . get( key, value ) - extracts the contents of key into value ,\n  an int8 array, int32 array, or character string. free_key( key ) - frees the memory in key . set( key, value ) - sets the content of key to value . Supported key types are int8 array, int32 array, and character\n  string. Procedures to hash keys to 32 bit integers: fnv_1_hasher( key ) - hashes a key using the FNV-1 algorithm. fnv_1a_hasher( key ) - hashes a key using the FNV-1a algorithm. seeded_nmhash32_hasher( key ) - hashes a key using the nmhash32\n  algorithm. seeded_nmhash32x_hasher( key ) - hashes a key using the nmhash32x\n  algorithm. seeded_water_hasher( key ) - hashes a key using the waterhash\n  algorithm. Operator to compare two key_type values for equality key1 == key2 - compares key1 with key2 for equality Specifications of the stdlib_hashmap_wrappers procedures copy_key - Returns a copy of the key Status Experimental Description Returns a copy of an input of type key_type . Syntax call stdlib_hashmap_wrappers ( old_key, new_key ) Class Subroutine. Arguments old_key : shall be a scalar expression of type key_type . It\nis an intent(in) argument. new_key : shall be a scalar variable of type key_type . It\nis an intent(out) argument. Example fibonacci_hash - maps an integer to a smaller number of bits Status Experimental Description fibonacci_hash is just a re-export of the function of the same name\nimplemented in stdlib_hash_32bit .\nIt reduces the value of a 32 bit integer to a smaller number of bits. fnv_1_hasher - calculates a hash code from a key Status Experimental Description Calculates a 32 bit hash code from an input of type key_type . Syntax code = stdlib_hashmap_wrappers ( key ) Class Pure function Argument key : Shall be a scalar expression of type key_type .\nIt is an intent(in) argument. Result character The result is a scalar integer of kind int32 . Result value The result is a hash code created using the FNV-1 algorithm. Note fnv_1_hasher is an implementation of the original FNV-1 hash code of\nGlenn Fowler, Landon Curt Noll, and Phong Vo.\nThis code is relatively fast on short keys, and is small enough that\nit will often be retained in the instruction cache if hashing is\nintermittent.\nAs a result it should give good performance for typical hash map\napplications.\nThis code does not pass any of the SMHasher tests, but the resulting\ndegradation in performance due to its larger number of collisions is\nexpected to be minor compared to its faster hashing rate. Example fnv_1a_hasher - calculates a hash code from a key Status Experimental Description Calculates a 32 bit hash code from an input of type key_type . Syntax code = stdlib_hashmap_wrappers ( key ) Class Pure function Argument key : Shall be a scalar expression of type key_type .\nIt is an intent(in) argument. Result character The result is a scalar integer of kind int32 . Result value The result is a hash code created using the FNV-1a algorithm. Note fnv_1a_hasher is an implementation of the original FNV-1A hash code\nof Glenn Fowler, Landon Curt Noll, and Phong Vo.\nThis code is relatively fast on short keys, and is small enough that\nit will often be retained in the instruction cache if hashing is\nintermittent.\nAs a result it should give good performance for typical hash map\napplications.\nThis code does not pass any of the SMHasher tests, but the resulting\ndegradation in performance due to its larger number of collisions is\nexpected to be minor compared to its faster hashing rate. Example free_key - frees the memory associated with a key Status Experimental Description Deallocates the memory associated with a variable of type key_type . Syntax call stdlib_hashmap_wrappers ( key ) Class Subroutine. Argument key : shall be a scalar variable of type key_type . It\nis an intent(out) argument. Example get - extracts the data from a derived type Status Experimental Description Extracts the data from a key_type and stores it in the\nvariable value . Syntax call stdlib_hashmap_wrappers ( key, value ) Class Subroutine. Argument key : shall be a scalar expression of type key_type . It\nis an intent(in) argument. value : shall be an allocatable default character string variable,\nor an allocatable vector variable of type integer and kind int8 or int32 . Example hasher_fun - serves as a function prototype. Status Experimental Description Serves as a prototype for hashing functions with a single, key ,\nargument of type key_type returning an int32 hash value. Syntax type( stdlib_hashmap_wrappers ), pointer :: fun_pointer Class Pure function prototype Argument key : Shall be a rank one array expression of type integer(int8) .\nIt is an intent(in) argument. Result character The result is a scalar integer of kind int32 . Result value The result is a hash code. Note hasher_fun is a prototype for defining dummy arguments and function\npointers intended for use as a hash function for the hash maps. Example operator(==) - Compares two keys for equality Status Experimental Description Returns .true. if two keys are equal, and .false. otherwise. Syntax test = key1 == key2 Class Pure operator. Arguments key1 : shall be a scalar expression of type key_type . It \nis an intent(in) argument. key2 : shall be a scalar expression of type key_type . It \nis an intent(in) argument. Result character The result is a value of type default logical . Result value The result is .true. if the keys are equal, otherwise .falss. . Example seeded_nmhash32_hasher - calculates a hash code from a key Status Experimental Description Calculates a 32 bit hash code from an input of type key_type . Syntax code = stdlib_hashmap_wrappers ( key ) Class Pure function Argument key : Shall be a scalar expression of type key_type .\nIt is an intent(in) argument. Result character The result is a scalar integer of kind int32 . Result value The result is a hash code created using the nmhash32 algorithm. Note seeded_nmhash32_hasher is a wrapper to the NMHASH32_HASH of the\nmodule stdlib_hash_32bit , which supplies a fixed seed\nto the wrapped function. NMHASH32 is an implementation of the nmhash32 hash code of James Z. M. Gao.\nThis code has good, but not great, performance on long keys, poorer\nperformance on short keys.\nAs a result it should give fair performance for typical hash map\napplications.\nThis code passes the SMHasher tests. Example seeded_nmhash32x_hasher - calculates a hash code from a key Status Experimental Description Calculates a 32 bit hash code from an input of type key_type . Syntax code = stdlib_hashmap_wrappers ( key ) Class Pure function Argument key : Shall be a scalar expression of type key_type .\nIt is an intent(in) argument. Result character The result is a scalar integer of kind int32 . Result value The result is a hash code created using the nmhash32x algorithm. Note seeded_nmhash32x_hasher is a wrapper to the nmhash32x_hash of the\nmodule stdlib_hash_32bit , which supplies a fixed seed\nto the wrapped function. nmhash32x is an implementation of the nmhash32x hash code of James Z. M. Gao.\nThis code has good, but not great, performance on long keys, poorer\nperformance on short keys.\nAs a result it should give fair performance for typical hash map\napplications.\nThis code passes the SMHasher tests. Example seeded_water_hasher - calculates a hash code from a key Status Experimental Description Calculates a 32 bit hash code from an input of type key_type . Syntax code = stdlib_hashmap_wrappers ( key ) Class Pure function Argument key : Shall be a scalar expression of type key_type .\nIt is an intent(in) argument. Result character The result is a scalar integer of kind int32 . Result value The result is a hash code created using the waterhash algorithm. Note seeded_water_hasher is a wrapper to the water_hash of the\nmodule stdlib_hash_32bit , which supplies a fixed seed\nto the wrapped function. water_hash is an implementation of the waterhash hash code of Tommy Ettinger.\nThis code has excellent performance on long keys, and good performance\non short keys.\nAs a result it should give reasonable performance for typical hash\ntable applications.\nThis code passes the SMHasher tests. Example set - places the data in a derived type Status Experimental Description Places the data from value in a key_type . Syntax call stdlib_hashmap_wrappers ( key, value ) Class Subroutine. Argument key : shall be a scalar variable of type key_type . It\nis an intent(out) argument. value : shall be a default character string scalar expression,\nor a vector expression of type integer and kind int8 or int32 .\nIt is an intent(in) argument. Note Values of types other than a scalar default character or and int8 or int32 vector can be used as the basis of a key by transferring the\nvalue to an int8 vector. Example The stdlib_hashmaps module The stdlib_hashmaps module defines three public data types,\nassociated procedures and constants that implement two simple hash map\ntypes using separate chaining hashing and open addressing hashing. The\nderived type hashmap_type is the parent type to its two\nextensions: chaining_hashmap_type and open_hashmap_type .\nThe extension types provide \nprocedures to manipulate the structure of a hash map object: init , map_entry , rehash , remove , and set_other_data . They also provide procedures to inquire about\nentries in the hash map: get_other_data , and key_test . Finally they provide procedures to inquire about the\noverall structure and performance of the hash map object: calls , entries , get_other_data , loading , slots , and total_depth . The module also defines a number of public constants: probe_factor , load_factor , map_probe_factor , default_bits , max_bits , int_calls , int_depth , int_index , int_probes , success , alloc_fault , and array_size_error . Generic key interfaces for key_test , map_entry , get_other_data , remove , and set_other_data are povided so that the supported types\nof int8 arrays, int32 arrays and character scalars can be used in the\nkey field as well as the base key type.  So for key_test , key_key_test specifies key type for the key field, int8_key_test is int8 for the key field and so on.  Procedures other than key_key_test will call\nthe set function to generate a key type and pass to key_key_test . The stdlib_hashmaps module's public constants The module defines several categories of public constants. Some are\nused to parameterize the empirical slot expansion code. Others\nparameterize the slots table size. Some are used to define\ninteger kind values for different applications. Finally, some are used\nto report errors or success. The constants probe_factor , and map_probe_factor are used to\nparameterize the slot expansion code used to determine when in a\nin a procedure call the number \nof slots need to be increased to decrease the search path for an\nentry. The constant probe_factor is used to determine when\nthe ratio of the number of map probes to map calls is too large and \nthe slots need expansion. The constant map_probe_factor is used to\ndetermine when inserting a new entry the ratio of the number of map\nprobes to map calls is too large and the slots need expansion. The constants default_bits , and max_bits are used to parameterize the table's slots size. The default_bits constant defines the default initial number of slots\nwith a current value of 6 resulting in an initial 2**6 == 64 slots. This may optionally be overridden on hash map creation. The max_bits parameter sets the maximum table size as 2**max_bits with\na default value for max_bits of 30. The table will not work for a\nslots size greater than 2**30 . The constants int_calls , int_depth , int_index , and int_probes are used to define integer kind values for various contexts. The\nnumber of calls are reported and stored in entities of kind int_calls . Currently int_calls has the value of int64 . The\ntotal depth, the number of inquiries needed to access all elements\nof the table, is reported and stored in entities of kind int_depth . Currently int_depth has the value of int64 . The\nnumber of entries in the table, is reported and stored in entities of\nkind int_index . Currently int_index has the value of int32 .\nThe number of probes, hash map enquiries, are reported and stored in\nentities of kind int_probes . Currently int_probes has the value of int64 . The constant load_factor is only used by the open_hashmap_type . It\nspecifies the maximum fraction of the available slots that may be\nfilled before expansion occurs. The current load_factor = 0.5625 so\nthe current implementation of open_hashmap_type can only hold a\nlittle more than 2**29 entries. Finally the error codes success , alloc_fault , and array_size_error are used to report the error status of certain\nprocedure calls. The succes code indicates that no problems were\nfound. The alloc_fault code indicates that a memory allocation\nfailed. Finally the array_size_error indicates that on table\ncreation slots_bits is less than default_bits or\ngreater than max_bits . The stdlib_hashmaps module's derived types The stdlib_hashmaps module defines three public derived types and\nseven private types used in the implementation of the public\ntypes. The public types are the abstract hashmap_type and its\nextensions: chaining_hashmap_type and open_hashmap_type . The three\nprivate derived types, chaining_map_entry_type , chaining_map_entry_ptr , and chaining_map_entry_pool are used in\nthe implementation of the chaining_hashmap_type public type. The\nfour private derived types, open_map_entry_type , open_map_entry_list , open_map_entry_ptr , and open_map_entry_pool are used in the implementation of the open_hashmap_type public\ntype. Each of these types are described below. The hashmap_type abstract type The hashmap_type abstract type serves as the parent type for the two\ntypes chaining_hashmap_type and open_hashmap_type . It defines\neight private components: call_count - the number of procedure calls on the map; nbits - the number of bits used to address the slots; num_entries - the number of entries in the map; num_free - the number of entries in the free list of removed \n  entries; probe_count - the number of map probes since the last resizing or\n  initialization; total_probes - the number of probes of the map up to the last\n  resizing or initialization; and hasher - a pointer to the hash function used by the map. initialized - track if map has been initialized It also defines five non-overridable procedures: calls - returns the number of procedure calls on the map; entries - returns the number of entries in the map; map_probes - returns the number of map probes since\n  initialization; num_slots - returns the number of slots in the map; and slots_bits - returns the number of bits used to address the slots; and ten deferred procedures: get_all_keys - gets all the keys contained in a map; get_other_data - gets the value associated with a key; init - initializes the hash map; key_test - returns a logical flag indicating whether the key is \n  defined in the map. loading - returns the ratio of the number of entries to the number\n  of slots; map_entry - inserts a key and optionally a corresponding value into\n the map; rehash - rehashes the map with the provided hash function; remove - removes the entry associated wit the key; set_other_data - replaces the value associated with a key; total_depth - returns the number of probes needed to address all\n  the entries in the map; The type's definition is below: type , abstract :: hashmap_type private integer ( int_calls ) :: call_count = 0 integer ( int_calls ) :: probe_count = 0 integer ( int_calls ) :: total_probes = 0 integer ( int_index ) :: num_entries = 0 integer ( int_index ) :: num_free = 0 integer ( int32 ) :: nbits = default_bits procedure ( hasher_fun ), pointer , nopass :: hasher => fnv_1_hasher contains procedure , non_overridable , pass ( map ) :: calls procedure , non_overridable , pass ( map ) :: entries procedure , non_overridable , pass ( map ) :: map_probes procedure , non_overridable , pass ( map ) :: num_slots procedure , non_overridable , pass ( map ) :: slots_bits procedure ( get_all_keys ), deferred , pass ( map ) :: get_all_keys procedure ( init_map ), deferred , pass ( map ) :: init procedure ( loading ), deferred , pass ( map ) :: loading procedure ( rehash_map ), deferred , pass ( map ) :: rehash procedure ( total_depth ), deferred , pass ( map ) :: total_depth !! Generic interfaces for key types. procedure ( key_key_test ), deferred , pass ( map ) :: key_key_test procedure , non_overridable , pass ( map ) :: int8_key_test procedure , non_overridable , pass ( map ) :: int32_key_test procedure , non_overridable , pass ( map ) :: char_key_test procedure ( key_map_entry ), deferred , pass ( map ) :: key_map_entry procedure , non_overridable , pass ( map ) :: int8_map_entry procedure , non_overridable , pass ( map ) :: int32_map_entry procedure , non_overridable , pass ( map ) :: char_map_entry procedure ( key_get_other_data ), deferred , pass ( map ) :: key_get_other_data procedure , non_overridable , pass ( map ) :: int8_get_other_data procedure , non_overridable , pass ( map ) :: int32_get_other_data procedure , non_overridable , pass ( map ) :: char_get_other_data procedure ( key_remove_entry ), deferred , pass ( map ) :: key_remove_entry procedure , non_overridable , pass ( map ) :: int8_remove_entry procedure , non_overridable , pass ( map ) :: int32_remove_entry procedure , non_overridable , pass ( map ) :: char_remove_entry procedure ( key_set_other_data ), deferred , pass ( map ) :: key_set_other_data procedure , non_overridable , pass ( map ) :: int8_set_other_data procedure , non_overridable , pass ( map ) :: int32_set_other_data procedure , non_overridable , pass ( map ) :: char_set_other_data generic , public :: key_test => key_key_test , int8_key_test , int32_key_test , char_key_test generic , public :: map_entry => key_map_entry , int8_map_entry , int32_map_entry , char_map_entry generic , public :: get_other_data => key_get_other_data , int8_get_other_data , int32_get_other_data , char_get_other_data generic , public :: remove => key_remove_entry , int8_remove_entry , int32_remove_entry , char_remove_entry generic , public :: set_other_data => key_set_other_data , int8_set_other_data , int32_set_other_data , char_set_other_data end type hashmap_type The chaining_map_entry_type derived type Entities of the type chaining_map_entry_type are used to define\na linked list structure that stores the\nkey, its other data, the hash of the key, and the resulting index into\nthe inverse table. The type's definition is below: type :: chaining_map_entry_type ! Chaining hash map entry type private integer ( int_hash ) :: hash_val ! Full hash value type ( key_type ) :: key ! The entry's key class ( * ), allocatable :: other ! Other entry data integer ( int_index ) :: index ! Index into inverse table type ( chaining_map_entry_type ), pointer :: & next => null () ! Next bucket end type chaining_map_entry_type Currently the int_hash and int_index have the value of int32 . The chaining_map_entry_ptr derived type The type chaining_map_entry_ptr is used to define the elements of\nthe hash map that are either empty or link to the linked lists\ncontaining the elements of the table. The type's definition is below: type chaining_map_entry_ptr ! Wrapper for a pointer to a chaining ! map entry type object type ( chaining_map_entry_type ), pointer :: target => null () end type chaining_map_entry_ptr The chaining_map_entry_pool derived type The type chaining_map_entry_pool is used to implement a pool of\nallocated chaining_map_entry_type elements to save on allocation\ncosts. The type's definition is below: type :: chaining_map_entry_pool ! Type implementing a pool of allocated ! `chaining_map_entry_type` objects private ! Index of next bucket integer ( int_index ) :: next = 0 type ( chaining_map_entry_type ), allocatable :: more_map_entries (:) type ( chaining_map_entry_pool ), pointer :: lastpool => null () end type chaining_map_entry_pool The chaining_hashmap_type derived type The chaining_hashmap_type derived type extends the hashmap_type to\nimplements a separate chaining hash map. In addition to the components\nof the hashmap_type it provides the four components: cache - a pool of chaining_map_entry_pool objects used to reduce\nallocation costs; free_list - a free list of map entries; inverse - an array of chaining_map_entry_ptr bucket lists\n(inverses) storing entries at fixed locations once\nentered; and slots - an array of bucket lists serving as the hash map. It also implements all of the deferred procedures of the hashmap_type and a finalizer for its maps. The type's definition is\nas follows: type , extends ( hashmap_type ) :: chaining_hashmap_type private type ( chaining_map_entry_pool ), pointer :: cache => null () type ( chaining_map_entry_type ), pointer :: free_list => null () type ( chaining_map_entry_ptr ), allocatable :: inverse (:) type ( chaining_map_entry_ptr ), allocatable :: slots (:) contains procedure :: get_all_keys => get_all_chaining_keys procedure :: key_get_other_data => get_other_chaining_data procedure :: init => init_chaining_map procedure :: loading => chaining_loading procedure :: key_map_entry => map_chain_entry procedure :: rehash => rehash_chaining_map procedure :: key_remove_entry => remove_chaining_entry procedure :: key_set_other_data => set_other_chaining_data procedure :: total_depth => total_chaining_depth procedure :: key_key_test => chaining_key_test final :: free_chaining_map end type chaining_hashmap_type The open_map_entry_type derived type Entities of the type open_map_entry_type are used to define\na linked list structure that stores the\nkey, its other data, the hash of the key, and the resulting index into\nthe inverse table. The type's definition is below: type :: open_map_entry_type ! Open hash map entry type private integer ( int_hash ) :: hash_val ! Full hash value type ( key_type ) :: key ! The entry's key class ( * ), allocatable :: other ! Other entry data integer ( int_index ) :: index ! Index into inverse table end type open_map_entry_type Currently int_hash and int_index have the value of int32 . The open_map_entry_ptr derived type The type open_map_entry_ptr is used to define the elements of\nthe hash map that are either empty or link to the linked lists\ncontaining the elements of the table. The type's definition is below: type open_map_entry_ptr ! Wrapper for a pointer to a open ! map entry type object type ( open_map_entry_type ), pointer :: target => null () end type open_map_entry_ptr The open_hashmap_type derived type The open_hashmap_type derived type extends the hashmap_type to\nimplement an open addressing hash map. In addition to the components\nof the hashmap_type it provides the four components: cache - a pool of open_map_entry_pool objects used to reduce\nallocation costs; free_list - a free list of map entries; index_mask - an and mask used in linear addressing; inverse - an array of open_map_entry_ptr bucket lists\n(inverses) storing entries at fixed locations once\nentered; and slots - an array of bucket lists serving as the hash map. It also implements all of the deferred procedures of the hashmap_type and a finalizer for its maps. The type's definition is\nas follows: type , extends ( hashmap_type ) :: open_hashmap_type private integer ( int_index ) :: index_mask = 2_int_index ** default_bits - 1 type ( open_map_entry_pool ), pointer :: cache => null () type ( open_map_entry_list ), pointer :: free_list => null () type ( open_map_entry_ptr ), allocatable :: inverse (:) integer ( int_index ), allocatable :: slots (:) contains procedure :: get_all_keys => get_all_open_keys procedure :: key_get_other_data => get_other_open_data procedure :: init => init_open_map procedure :: loading => open_loading procedure :: key_map_entry => map_open_entry procedure :: rehash => rehash_open_map procedure :: key_remove_entry => remove_open_entry procedure :: key_set_other_data => set_other_open_data procedure :: total_depth => total_open_depth procedure :: key_key_test => open_key_test final :: free_open_map end type open_hashmap_type Table of stdlib_hashmap procedures The stdlib_hashmap module provides procedures in\nseveral categories: a procedure to initialize the map; a procedure to\nmodify the structure of a map; procedures to modify the content of a\nmap; procedures to report on the content of a map; and procedures\nto report on the structure of the map. The procedures in each category\nare listed below. Procedure to initialize a chaining hash map: map % init( [hasher, slots_bits, status] ) - Routine\n  to initialize a chaining hash map. Procedure to modify the structure of a map: map % rehash( hasher ) - Routine to change the hash function\n  for a map. Procedures to modify the content of a map: map % map_entry( key[, other, conflict] ) - Inserts an entry into the\n  hash map. map % remove( key[, existed] ) - Remove the entry, if any,\n  associated with the key . map % set_other_data( key, other[, exists] ) - Change the value \nassociated with the key . Procedures to report the content of a map: map % get_all_keys( all_keys ) - Returns all the keys\n  contained in the map; map % get_other_data( key, other[, exists] ) - Returns the value \n  associated with the key ; map % key_test( key, present) - Returns a flag indicating whether\n  the key is present in the map. Procedures to report on the structure of the map: map % calls() - the number of subroutine calls on the hash map. map % entries() - the number of entries in a hash map. map % loading() - the number of entries relative to the number of\n  slots in a hash map. map % map_probes() - the total number of table probes on a hash\n  map. map % slots() - Returns the number of allocated slots in a hash\n  map. map % total_depth() - Returns the total number of one's based\noffsets of slot entries from their slot index Specifications of the stdlib_hashmaps procedures calls - Returns the number of calls on the hash map Status Experimental Description Returns the number of procedure calls on a hash map. Syntax value = map % hashmap_type () Class Pure function Argument map (pass) - shall be an expression of class hashmap_type .\nIt is an intent(in) argument. Result character The result will be an integer of kind int_calls . Result value The result will be the number of procedure calls on the hash map. Example entries - Returns the number of entries in the hash map Status Experimental Description Returns the number of entries in a hash map. Syntax value = map % hashmap_type () Class Pure function Argument map (pass)  - shall be an expression of class hashmap_type .\nIt is an intent(in) argument. Result character The result will be an integer of kind int_index . Result value The result will be the number of entries in the hash map. Example get_all_keys - Returns all the keys contained in a map Status Experimental Description Returns all the keys contained in a map. Syntax call map % hashmap_type ( all_keys ) Class Subroutine Arguments map (pass): shall be a scalar variable of class chaining_hashmap_type or open_hashmap_type . It is an intent(in) argument. It will be \n  the hash map used to store and access the other data. all_keys : shall be a rank-1 allocatable array of type key_type . \n  It is an intent(out) argument. Example get_other_data - Returns other data associated with the key Status Experimental Description Returns the value associated with the key , Syntax value = map % hashmap_type ( key, other [, exists] ) Class Subroutine Arguments map (pass): shall be a scalar variable of class chaining_hashmap_type or open_hashmap_type . It is an intent(inout) argument. It will be \n  the hash map used to store and access the other data. key : shall be a of type key_type scalar, character scalar, int8 array\nor int32 array. It is an intent(in) argument. other : shall be a allocatable unlimited polymorphic scalar. (class(*), allocatable)  It is an intent(out) argument.\nIt is the value associated with the key . exists (optional): shall be a variable of type logical. It is an intent(out) argument. If .true. an entry with the given key exists in the map and other is defined. If .false. other is\nundefined. Example The following is an example of the retrieval of other data\n  associated with a key : init - initializes a hash map Status Experimental Description Initializes a hashmap_type object. Syntax call map % hashmap_type ( [hasher, slots_bits, status ] ) Class Subroutine Arguments map (pass): shall be a scalar variable of class chaining_hashmap_type or open_hashmap_type . It is an intent(out) argument. It will \n  be a hash map used to store and access the entries. hasher : (optional): shall be a procedure with interface hash_fun .\n  It is an intent(in) argument. It is the procedure to be used to\n  generate the hashes for the table from the keys of the entries. \n  Defaults to fnv_1_hasher if not provided. slots_bits (optional): shall be a scalar default integer \n  expression. It is an intent(in) argument. The initial number of\n  slots in the table will be 2**slots_bits . slots_bits shall be a positive default integer less than max_bits , otherwise processing stops with an informative\n  error code. If slots_bits is absent then the effective value for slots_bits is default_bits . status (optional): shall be a scalar integer variable of kind int32 . It is an intent(out) argument. On return if present it\nshall have an error code value. If map was successfully initialized then status has the value success . If allocation of memory for the map arrays fails then status has the value alloc_fault . If slot_bits < 6 or slots_bits > max_bits then status has the value of array_size_error . If status is absent, but status would have a value other than success , then processing stops with an informative stop code. Example key_test - indicates whether key is present Status Experimental Description Returns a logical flag indicating whether key is present for an\nentry in the map. Syntax call map % hashmap_type ( key, present ) Class Subroutine. Arguments map (pass): shall be a scalar variable of class chaining_hashmap_type or open_hashmap_type . \nIt is an intent(inout) argument. It is the hash map whose entries\nare examined. key : shall be a of type key_type scalar, character scalar, int8 array\nor int32 array. It is an intent(in) argument. It is a key whose \npresence in the map is being examined. present : shall be a scalar variable of type logical .\nIt is an intent(out) argument. It is a logical flag where .true. indicates that an entry with that key is present in the map and .false. indicates that no such entry is present. Example loading - Returns the ratio of entries to slots Status Experimental Description Returns the ratio of the number of entries relative to the number of\nslots in the hash map. Syntax value = map % hashmap_type ( ) Class Pure function Argument map (pass) - shall be an expression of class chaining_hashmap_type or open_hashmap_type . It is an intent(in) argument. Result character The result will be a default real. Result value The result will be the ratio of the number of entries relative to the\nnumber of slots in the hash map. Example map_entry - inserts an entry into the hash map Status Experimental Description Inserts an entry into the hash map if it is not already present. Syntax call map % hashmap_type ( key[, other, conflict ] ) Class Subroutine Arguments map (pass): shall be a scalar variable of class chaining_hashmap_type or open_hashmap_type . It\nis an intent(inout) argument. It is the hash map to receive the\nentry. key : shall be a of type key_type scalar, character scalar, int8 array\nor int32 array. It is an intent(in) argument. It is the key for the entry\nto be placed in the table. other (optional): shall be a scalar of any type, including derived types.\nIt is an intent(in) argument. If present it is the value to be\nassociated with the key . conflict (optional): shall be a scalar variable of type logical . It is an intent(out) argument. If present, a .true. value indicates that an entry with the value of key already exists\nand the entry was not entered into the map, a .false. value indicates\nthat key was not present in the map and the entry was added to the\nmap. If key is already present in map and the conflict argument has been\nprovided then the presence of other is ignored. If conflict has not \nbeen provided then it routine will error stop. Example map_probes - returns the number of hash map probes Status Experimental Description Returns the total number of table probes on the hash map. Syntax result = map % hashmap_type ( ) Class Pure function Argument map (pass): shall be a scalar expression of class hashmap_type . It is an intent(in) argument. It is the hash map of interest. Result character The result is a scalar integer of kind int_probes . Result value The result is the number of probes of map since initialization or\nrehashing. Example num_slots - returns the number of hash map slots. Status Experimental Description Returns the total number of slots on a hash map Syntax result = map % hashmap_type ( ) Class Pure function Argument map : shall be a scalar expression of class hashmap_type . It is an intent(in) argument. It is the\nhash map of interest. Result character The result is a scalar integer of kind int_index . Result value The result is the number of slots in map . Example rehash - changes the hashing function Status Experimental Description Changes the hashing function for the map entries to that of hasher . Syntax call map % hashmap_type ( hasher ) Class Subroutine Arguments map (pass): shall be a scalar variable of class chaining_hashmap_type or open_hashmap_type .\nIt is an intent(inout) argument. It is the hash map whose hashing \nmethod is to be changed. hasher : shall be a function of interface hasher_fun .\nIt is the hash method to be used by map . Example remove - removes an entry from the hash map Status Experimental Description Removes an entry from the hash map, map . Syntax call map % hashmap_type ( key[, existed ]) Class Subroutine Arguments map (pass): shall be a scalar variable of class chaining_hashmap_type or open_hashmap_type . \nIt is an intent(inout) argument. It is the hash map with the element \nto be removed. key : shall be a of type key_type scalar, character scalar, int8 array\nor int32 array. It is an intent(in) argument. It is the key identifying \nthe entry to be removed. existed (optional): shall be a scalar variable of type default\nlogical. It is an intent(out) argument. If present with the value .true. the entry existed in the map before removal, if .false. the\nentry was not present to be removed and the map is unchanged. If\nabsent, the procedure returns with no entry with the given key. Example set_other_data - replaces the other data for an entry Status Experimental Description Replaces the other data in the map for the entry with the key value, key . Syntax call map % hashmap_type ( key, other[, exists] ) Class Subroutine Arguments map (pass): shall be a scalar variable of class chaining_hashmap_type or open_hashmap_type . It\nis an intent(inout) argument. It will be a hash map used to store\nand access the entry's data. key : shall be a of type key_type scalar, character scalar, int8 array\nor int32 array. It is an intent(in) argument. It is the key to the \nentry whose other data is to be replaced. other (optional): shall be a scalar of any type, including derived types.\nIt is an intent(in) argument. If present it is the value to be\nassociated with the key . exists (optional): shall be a scalar variable of type logical .\nIt is an intent(out) argument. If present with the value .true. an entry with that key existed in the map and its other data was replaced.  If exists is .false. the key did\nnot exist and nothing was done. If key is not already present in map and exists has not \nbeen provided then the routine will error stop. Example slots_bits - returns the number of bits used to address the hash map slots Status Experimental Description Returns the total number of bits used to address the hash map slots. Syntax result = map % hashmap_type ( ) Class Pure function Argument map (pass): shall be a scalar expression of class hashmap_type . It is an intent(in) argument. It is the\nhash map of interest. Result character The result is a scalar integer of kind int_index . Result value The result is the number of bits used in addressing the slots in map . Example total_depth - returns the total depth of the hash map entries Status Experimental Description Returns the total number of one's based offsets of slot entries from\ntheir slot index for a hash map Syntax result = map % hashmap_type ( ) Class Pure function Argument map (pass): shall be a scalar expression of class hashmap_type . It is an intent(in) argument. It is the\nhash map of interest. Result character The result is a scalar integer of kind int_depth . Result value The result is the total number of one's based offsets of slot entries\nfrom their slot index the map. Example","tags":"","url":"page/specs/stdlib_hashmaps.html"},{"title":"intrinsics – LightConvex","text":"The stdlib_intrinsics module The stdlib_intrinsics module Introduction stdlib_sum function Description Syntax Status Class Argument(s) Output value or Result value stdlib_sum_kahan function Description Syntax Status Class Argument(s) Output value or Result value Example stdlib_dot_product function Description Syntax Status Class Argument(s) Output value or Result value stdlib_dot_product_kahan function Description Syntax Status Class Argument(s) Output value or Result value Introduction The stdlib_intrinsics module provides replacements for some of the well known intrinsic functions found in Fortran compilers for which either a faster and/or more accurate implementation is found which has also proven of interest to the Fortran community. stdlib_sum function Description The stdlib_sum function can replace the intrinsic sum for real , complex or integer arrays. It follows a chunked implementation which maximizes vectorization potential as well as reducing the round-off error. This procedure is recommended when summing large (e..g, >2**10 elements) arrays, for repetitive summation of smaller arrays consider the classical sum . Syntax res = stdlib_intrinsics (x [,mask] ) res = stdlib_intrinsics (x, dim [,mask] ) Status Experimental Class Pure function. Argument(s) x : N-D array of either real , complex or integer type. This argument is intent(in) . dim (optional): scalar of type integer with a value in the range from 1 to n, where n equals the rank of x . mask (optional): N-D array of logical values, with the same shape as x . This argument is intent(in) . Output value or Result value If dim is absent, the output is a scalar of the same type and kind as to that of x . Otherwise, an array of rank n-1, where n equals the rank of x , and a shape similar to that of x with dimension dim dropped is returned. stdlib_sum_kahan function Description The stdlib_sum_kahan function can replace the intrinsic sum for real or complex arrays. It follows a chunked implementation which maximizes vectorization potential complemented by an elemental kernel based on the kahan summation strategy to reduce the round-off error: elemental subroutine kahan_kernel_ < kind > ( a , s , c ) type ( < kind > ), intent ( in ) :: a type ( < kind > ), intent ( inout ) :: s type ( < kind > ), intent ( inout ) :: c type ( < kind > ) :: t , y y = a - c t = s + y c = ( t - s ) - y s = t end subroutine Syntax res = stdlib_intrinsics (x [,mask] ) res = stdlib_intrinsics (x, dim [,mask] ) Status Experimental Class Pure function. Argument(s) x : 1D array of either real or complex type. This argument is intent(in) . dim (optional): scalar of type integer with a value in the range from 1 to n, where n equals the rank of x . mask (optional): N-D array of logical values, with the same shape as x . This argument is intent(in) . Output value or Result value If dim is absent, the output is a scalar of the same type and kind as to that of x . Otherwise, an array of rank n-1, where n equals the rank of x , and a shape similar to that of x with dimension dim dropped is returned. Example stdlib_dot_product function Description The stdlib_dot_product function can replace the intrinsic dot_product for 1D real , complex or integer arrays. It follows a chunked implementation which maximizes vectorization potential as well as reducing the round-off error. This procedure is recommended when crunching large arrays, for repetitive products of smaller arrays consider the classical dot_product . Syntax res = stdlib_intrinsics (x, y) Status Experimental Class Pure function. Argument(s) x : 1D array of either real , complex or integer type. This argument is intent(in) . y : 1D array of the same type and kind as x . This argument is intent(in) . Output value or Result value The output is a scalar of type and kind same as to that of x and y . stdlib_dot_product_kahan function Description The stdlib_dot_product_kahan function can replace the intrinsic dot_product for 1D real or complex arrays. It follows a chunked implementation which maximizes vectorization potential, complemented by the same elemental kernel based on the kahan summation used for stdlib_sum to reduce the round-off error. Syntax res = stdlib_intrinsics (x, y) Status Experimental Class Pure function. Argument(s) x : 1D array of either real or complex type. This argument is intent(in) . y : 1D array of the same type and kind as x . This argument is intent(in) . Output value or Result value The output is a scalar of the same type and kind as to that of x and y .","tags":"","url":"page/specs/stdlib_intrinsics.html"},{"title":"io – LightConvex","text":"IO IO loadtxt - load a 2D array from a text file Status Description Syntax Arguments Return value Example open - open a file Status Description Syntax Arguments Return value Example savetxt - save a 2D array into a text file Status Description Syntax Arguments Output Example load_npy Status Description Syntax Arguments Return value Example save_npy Status Description Syntax Arguments Output Example get_line Status Description Syntax Arguments Example Formatting constants Status Description Example get_file - Read a whole ASCII file into a character or a string variable Status Description Syntax Class Arguments Return values Example loadtxt - load a 2D array from a text file Status Experimental Description Loads a rank-2 array from a text file. Syntax call stdlib_io (filename, array [, skiprows] [, max_rows] [, fmt] [, delimiter]) Arguments filename : Shall be  a character expression containing the file name from which to load the rank-2 array . array : Shall be an allocatable rank-2 array of type real , complex or integer . skiprows (optional): Skip the first skiprows lines. If skipping more rows than present, a 0-sized array will be returned. The default is 0. max_rows (optional): Read max_rows lines of content after skiprows lines. A negative value results in reading all lines. A value of zero results in no lines to be read. The default value is -1. fmt (optional): Fortran format specifier for the text read.  Defaults to the write format for the data type.  Setting fmt='*' will specify list directed read. delimiter (optional): Shall be a character expression of length 1 that contains the delimiter used to separate the columns. The default is ' ' . Return value Returns an allocated rank-2 array with the content of filename . Example open - open a file Status Experimental Description Returns the unit number of a file opened to read, to write, or to read and write. The file might be a text file or a binary file.\nText files are opened using a sequential access, while binary files are opened using a streamed access. Syntax u = stdlib_io (filename [, mode] [, iostat]) Arguments filename : Shall be a character expression containing the name of the file to open. mode (optional): Shall be a character expression containing characters describing the way in which the file will be used. The available modes are: Character Meaning 'r' open for reading (default) 'w' open for writing, truncating the file first 'x' open for exclusive creation, failing if the file already exists 'a' open for writing, appending to the end of the file if it exists '+' open for updating (reading and writing) 'b' binary mode 't' text mode (default) The default mode is 'rt' (i.e. open for reading a text file). The mode may include one of the four different methods for opening a file (i.e., 'r' , 'w' , 'x' , and 'a' ). These four methods can be associated with the character '+' to open the file for updating. In addition, it can be specified if the file should be handled as a binary file ( 'b' ) or a text file ( 't' ). iostat (optional): Shall be a scalar of type integer that receives the error status of open , if provided. If no error exists, iostat is zero. u : Shall be a scalar of type integer that specifies the unit number associated with the file filename . Return value The result is a scalar of type integer . Example savetxt - save a 2D array into a text file Status Experimental Description Saves a rank-2 array into a text file. Syntax call stdlib_io (filename, array [, delimiter]) Arguments filename : Shall be  a character expression containing the name of the file that will contain the 2D array . array : Shall be a rank-2 array of type real , complex or integer . delimiter (optional): Shall be a character expression of length 1 that contains the delimiter used to separate the columns. The default is ' ' . Output Provides a text file called filename that contains the rank-2 array . Example load_npy Status Experimental Description Loads an array from a npy formatted binary file. Syntax call stdlib_io_npy (filename, array[, iostat][, iomsg]) Arguments filename : Shall be  a character expression containing the file name from which to load the array .\n            This argument is intent(in) . array : Shall be an allocatable array of any rank of type real , complex or integer .\n         This argument is intent(out) . iostat : Default integer, contains status of loading to file, zero in case of success.\n          It is an optional argument, in case not present the program will halt for non-zero status.\n          This argument is intent(out) . iomsg : Deferred length character value, contains error message in case iostat is non-zero.\n         It is an optional argument, error message will be dropped if not present.\n         This argument is intent(out) . Return value Returns an allocated array with the content of filename in case of success. Example save_npy Status Experimental Description Saves an array into a npy formatted binary file. Syntax call stdlib_io_npy (filename, array[, iostat][, iomsg]) Arguments filename : Shall be  a character expression containing the name of the file that will contain the array .\n            This argument is intent(in) . array : Shall be an array of any rank of type real , complex or integer .\n         This argument is intent(in) . iostat : Default integer, contains status of saving to file, zero in case of success.\n          It is an optional argument, in case not present the program will halt for non-zero status.\n          This argument is intent(out) . iomsg : Deferred length character value, contains error message in case iostat is non-zero.\n         It is an optional argument, error message will be dropped if not present.\n         This argument is intent(out) . Output Provides a npy file called filename that contains the rank-2 array . Example get_line Status Experimental Description Read a whole line from a formatted unit into a string variable Syntax call stdlib_io (unit, line[, iostat][, iomsg]) call stdlib_io (line[, iostat][, iomsg]) Arguments unit : Formatted input unit.\n        This argument is intent(in) .\n        If unit is not specified standard input is used. line : Deferred length character or string_type variable.\n        This argument is intent(out) . iostat : Default integer, contains status of reading from unit, zero in case of success.\n          It is an optional argument, in case not present the program will halt for non-zero status.\n          This argument is intent(out) . iomsg : Deferred length character value, contains error message in case iostat is non-zero.\n         It is an optional argument, error message will be dropped if not present.\n         This argument is intent(out) . Example Formatting constants Status Experimental Description Formatting constants for printing out integer, floating point, and complex numbers at their full precision.\nProvides formats for all kinds as defined in the stdlib_kinds module. Example get_file - Read a whole ASCII file into a character or a string variable Status Experimental Description This subroutine interface reads the entirety of a specified ASCII file and returns its content as a string or an allocatable character variable. \nThe function provides an optional error-handling mechanism via the state_type class. If the err argument is not provided, exceptions will trigger an error stop . The function also supports an optional flag to delete the file after reading. Syntax call [[stdlib_io(module):get_file(subroutine)]] (filename, file [, err] [, delete=.false.]) Class Function Arguments filename : Shall be a character input containing the path to the ASCII file to read. It is an intent(in) argument. file : Shall be a type(string_type) or an allocatable character variable containing the full content of the specified file. It is an intent(out) argument. err (optional): Shall be a type(state_type) variable. It is an intent(out) argument used for error handling. delete (optional): Shall be a logical flag. If .true. , the file is deleted after reading. Default is .false. . It is an intent(in) argument. Return values Output variable file will contain the full content of the specified file. Raises STDLIB_IO_ERROR if the file is not found, cannot be opened, read, or deleted. \nExceptions trigger an error stop unless the optional err argument is provided. Example","tags":"","url":"page/specs/stdlib_io.html"},{"title":"kinds – LightConvex","text":"The stdlib_kinds module The stdlib_kinds module Introduction Constants provided by stdlib_kinds sp dp xdp qp int8 int16 int32 int64 lk c_bool Introduction The stdlib_kinds module provides kind parameters for the Fortran intrinsic data types, integer , logical , real , and complex . Constants provided by stdlib_kinds sp Single precision real kind parameter.\nProvides real kind parameter for floating point numbers with a minimal precision of 6 significant digits. dp Double precision real kind parameter.\nProvides real kind parameter for floating point numbers with a minimal precision of 15 significant digits. xdp Extended double precision real kind parameter.\nProvides real kind parameter for floating point numbers with a minimal precision of 18 significant digits.\nIf not available it has value -1 . qp Quadruple precision real kind parameter.\nProvides real kind parameter for floating point numbers with a minimal precision of 33 significant digits.\nIf not available it has value -1 . int8 Reexported intrinsic named constant int8 from iso_fortran_env . int16 Reexported intrinsic named constant int16 from iso_fortran_env . int32 Reexported intrinsic named constant int32 from iso_fortran_env . int64 Reexported intrinsic named constant int64 from iso_fortran_env . lk Kind parameter of the default logical data type. c_bool Reexported intrinsic named constant c_bool from iso_c_binding .","tags":"","url":"page/specs/stdlib_kinds.html"},{"title":"linalg – LightConvex","text":"Linear Algebra Linear Algebra BLAS and LAPACK Status Description Syntax Example Licensing diag - Create a diagonal array or extract the diagonal elements of an array Status Class Description Syntax Arguments Return value Example eye - Construct the identity matrix Status Class Description Syntax Arguments Return value Example trace - Trace of a matrix Status Description Syntax Arguments Return value Example outer_product - Computes the outer product of two vectors Status Description Syntax Arguments Return value Example kronecker_product - Computes the Kronecker product of two rank-2 arrays Status Description Syntax Arguments Return value Example cross_product - Computes the cross product of two vectors Status Description Syntax Arguments Return value Example is_square - Checks if a matrix is square Status Description Syntax Arguments Return value Example is_diagonal - Checks if a matrix is diagonal Status Description Syntax Arguments Return value Example is_symmetric - Checks if a matrix is symmetric Status Description Syntax Arguments Return value Example is_skew_symmetric - Checks if a matrix is skew-symmetric Status Description Syntax Arguments Return value Example hermitian - Compute the Hermitian version of a rank-2 matrix Status Description Syntax Arguments Return value Example is_hermitian - Checks if a matrix is Hermitian Status Description Syntax Arguments Return value Example is_triangular - Checks if a matrix is triangular Status Description Syntax Arguments Return value Example is_hessenberg - Checks if a matrix is hessenberg Status Description Syntax Arguments Return value Example solve - Solves a linear matrix equation or a linear system of equations. Status Description Syntax Arguments Return value Example solve_lu - Solves a linear matrix equation or a linear system of equations (subroutine interface). Status Description Syntax Arguments Return value Example lstsq - Computes the least squares solution to a linear matrix equation. Status Description Syntax Arguments Return value Example solve_lstsq - Compute the least squares solution to a linear matrix equation (subroutine interface). Status Description Syntax Arguments Return value Example lstsq_space - Compute internal working space requirements for the least squares solver. Status Description Syntax Arguments det - Computes the determinant of a square matrix Status Description Syntax Arguments Return value Example .det. - Determinant operator of a square matrix Status Description Syntax Arguments Return value Example qr - Compute the QR factorization of a matrix Status Description Syntax Arguments Return value Example qr_space - Compute internal working space requirements for the QR factorization. Status Description Syntax Arguments Example schur - Compute the Schur decomposition of a matrix Status Description Syntax Arguments Return value Example schur_space - Compute internal working space requirements for the Schur decomposition Status Description Syntax Arguments Return value eig - Eigenvalues and Eigenvectors of a Square Matrix Status Description Syntax Arguments Return value Example eigh - Eigenvalues and Eigenvectors of a Real symmetric or Complex Hermitian Square Matrix Status Description Syntax Arguments Return value Example eigvals - Eigenvalues of a Square Matrix Status Description Syntax Arguments Return Value Example eigvalsh - Eigenvalues of a Real Symmetric or Complex Hermitian Square Matrix Status Description Syntax Arguments Return value Example svd - Compute the singular value decomposition of a rank-2 array (matrix). Status Description Syntax Class Arguments Return values Example svdvals - Compute the singular values of a rank-2 array (matrix). Status Description Syntax Arguments Return values Example cholesky - Compute the Cholesky factorization of a rank-2 square array (matrix) Status Description Syntax Class Arguments Return values Example chol - Compute the Cholesky factorization of a rank-2 square array (matrix) Status Description Syntax Arguments Return values Example .inv. - Inverse operator of a square matrix Status Description Syntax Arguments Return value Example invert - Inversion of a square matrix Status Description Syntax Arguments Return value Example inv - Inverse of a square matrix. Status Description Syntax Arguments Return value Example pinv - Moore-Penrose pseudo-inverse of a matrix Status Description Syntax Arguments Return value Example pseudoinvert - Moore-Penrose pseudo-inverse of a matrix Status Description Syntax Arguments Return value Example .pinv. - Moore-Penrose Pseudo-Inverse operator Status Description Syntax Arguments Return value Example get_norm - Computes the vector norm of a generic-rank array. Status Description Syntax Arguments Return value Example norm - Computes the vector norm of a generic-rank array. Status Description Syntax Arguments Return value Example mnorm - Computes the matrix norm of a generic-rank array. Status Description Syntax Arguments Return value Example The stdlib linear algebra library provides high-level APIs for dealing with common linear algebra operations. BLAS and LAPACK Status Experimental Description BLAS and LAPACK backends provide efficient low level implementations of many linear algebra algorithms, and are employed for non-trivial operators. \nA Modern Fortran version of the Reference-LAPACK 3.10.1 implementation is provided as a backend. \nModern Fortran modules with full explicit typing features are provided after an automated conversion of the legacy codes: \n- [stdlib_linalg_blas(module)], [stdlib_linalg_lapack(module)] provide kind-agnostic interfaces to all functions.\n- Both libraries are available for 32- ( sp ), 64- ( dp ) and 128-bit ( qp ) real and complex numbers (the latter if available in the current build)\n- Free format, lower-case style\n- implicit none(type, external) applied to all procedures and modules\n- intent added and all pure procedures where possible\n- stdlib provides all procedures in two different flavors: (a) original BLAS/LAPACK names with a prefix stdlib_?<name> (ex: stdlib_dgemv , stdlib_sgemv ); (b) A generic, kind agnostic <name> , i.e. gemv . \n- F77-style parameter s removed, and all numeric constants have been generalized with KIND-dependent Fortran intrinsics. \n- preprocessor-based OpenMP directives retained.\nThe single-source module structure hopefully allows for cross-procedural inlining which is otherwise impossible without link-time optimization. When available, highly optimized libraries that take advantage of specialized processor instructions should be preferred over the stdlib implementation. \nExamples of such libraries are: OpenBLAS, MKL (TM), Accelerate, and ATLAS. In order to enable their usage, simply ensure that the following pre-processor macros are defined: STDLIB_EXTERNAL_BLAS wraps all BLAS procedures (except for the 128-bit ones) to an external library STDLIB_EXTERNAL_LAPACK wraps all LAPACK procedures (except for the 128-bit ones) to an external library These can be enabled during the build process. For example, with CMake, one can enable these preprocessor directives using add_compile_definitions(STDLIB_EXTERNAL_BLAS STDLIB_EXTERNAL_LAPACK) .\nThe same is possible from the fpm branch, where the cpp preprocessor is enabled by default. For example, the macros can be added to the project's manifest: # Link against appropriate external BLAS and LAPACK libraries, if necessary [build] link = [ \"blas\" , \"lapack\" ] [dependencies] stdlib = \"*\" # Macros are only needed if using an external library [preprocess] [preprocess.cpp] macros = [ \"STDLIB_EXTERNAL_BLAS\" , \"STDLIB_EXTERNAL_LAPACK\" ] or directly via compiler flags: fpm build --flag \"-DSTDLIB_EXTERNAL_BLAS -DSTDLIB_EXTERNAL_LAPACK -lblas -llapack\" . Syntax All procedures in the BLAS and LAPACK backends follow the standard interfaces from the Reference LAPACK . So, the online Users Guide should be consulted for the full API and descriptions of procedure arguments and their usage. The stdlib implementation makes both kind-agnostic and specific procedure interfaces available via modules\n[stdlib_linalg_blas(module)] and [stdlib_linalg_lapack(module)]. Because all procedures start with a letter that indicates the base datatype , the stdlib generic\ninterface drops the heading letter and contains all kind-dependent implementations. For example, the generic \ninterface to the axpy function looks like: !> AXPY: constant times a vector plus a vector. interface axpy module procedure stdlib_saxpy module procedure stdlib_daxpy module procedure stdlib_qaxpy module procedure stdlib_caxpy module procedure stdlib_zaxpy module procedure stdlib_waxpy end interface axpy The generic interface is the endpoint for using an external library. Whenever the latter is used, references\nto the internal module procedure s are replaced with interfaces to the external library, \nfor example: !> AXPY: constant times a vector plus a vector. interface axpy pure subroutine caxpy ( n , ca , cx , incx , cy , incy ) import sp , dp , qp , ilp , lk implicit none complex ( sp ), intent ( in ) :: ca , cx ( * ) integer ( ilp ), intent ( in ) :: incx , incy , n complex ( sp ), intent ( inout ) :: cy ( * ) end subroutine caxpy ! [....] module procedure stdlib_qaxpy end interface axpy Note that the 128-bit functions are only provided by stdlib and always point to the internal implementation. \nBecause 128-bit precision is identified as [stdlib_kinds(module):qp], initials for 128-bit procedures were \nlabelled as q (quadruple-precision reals) and w (\"wide\" or quadruple-precision complex numbers). \nExtended precision ([stdlib_kinds(module):xdp]) calculations are labelled as x (extended-precision reals).\nand y (extended-precision complex numbers). Example Licensing The Fortran Standard Library is distributed under the MIT License. LAPACK and its contained BLAS are a \nfreely-available software package. They are available from netlib via anonymous \nftp and the World Wide Web. Thus, they can be included in commercial software packages (and have been). \nThe license used for the BLAS and LAPACK backends is the modified BSD license . The header of the LICENSE.txt file has as its licensing requirements: Copyright ( c ) 1992-2013 The University of Tennessee and The University of Tennessee Research Foundation . All rights reserved . Copyright ( c ) 2000-2013 The University of California Berkeley . All rights reserved . Copyright ( c ) 2006-2013 The University of Colorado Denver . All rights reserved . $ COPYRIGHT $ Additional copyrights may follow $ HEADER $ Redistribution and use in source and binary forms , with or without modification , are permitted provided that the following conditions are met : - Redistributions of source code must retain the above copyright notice , this list of conditions and the following disclaimer . - Redistributions in binary form must reproduce the above copyright notice , this list of conditions and the following disclaimer listed in this license in the documentation and / or other materials provided with the distribution . - Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission . The copyright holders provide no reassurances that the source code provided does not infringe any patent , copyright , or any other intellectual property rights of third parties . The copyright holders disclaim any liability to any recipient for claims brought against recipient by any third party for infringement of that parties intellectual property rights . THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED . IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE . So the license for the LICENSE.txt code is compatible with the use of\nmodified versions of the code in the Fortran Standard Library under the MIT license. Credit for the BLAS , LAPACK libraries should be given to the LAPACK authors .\nAccording to the original license, we also changed the name of the routines and commented the changes made \nto the original. diag - Create a diagonal array or extract the diagonal elements of an array Status Stable Class Pure function. Description Create a diagonal array or extract the diagonal elements of an array Syntax d = stdlib_linalg (a [, k]) Arguments a : Shall be a rank-1 or or rank-2 array. If a is a rank-1 array (i.e. a vector) then diag returns a rank-2 array with the elements of a on the diagonal. If a is a rank-2 array (i.e. a matrix) then diag returns a rank-1 array of the diagonal elements. k (optional): Shall be a scalar of type integer and specifies the diagonal. The default k = 0 represents the main diagonal, k > 0 are diagonals above the main diagonal, k < 0 are diagonals below the main diagonal. Return value Returns a diagonal array or a vector with the extracted diagonal elements. Example eye - Construct the identity matrix Status Stable Class Pure function. Description Constructs the identity matrix. Syntax I = stdlib_linalg (dim1 [, dim2] [, mold]) Arguments dim1 : A scalar of type integer . This is an intent(in) argument and specifies the number of rows. dim2 : A scalar of type integer . This is an optional intent(in) argument specifying the number of columns. If not provided, the matrix is square ( dim1 = dim2 ). mold : A scalar of any supported integer , real , or complex type. This is an optional intent(in) argument. If provided, the returned identity matrix will have the same type and kind as mold . If not provided, the matrix will be of type real(real64) by default. Return value Returns the identity matrix, with ones on the main diagonal and zeros elsewhere. By default, the return value is of type real(real64) , which is recommended for arithmetic safety. If the mold argument is provided, the return value will match the type and kind of mold , allowing for arbitrary integer , real , or complex return types. Example !> Return default type (real64) A = eye ( 2 , 2 ) / 2 !! A == diag([0.5_dp, 0.5_dp]) !> Return 32-bit complex A = eye ( 2 , 2 , mold = ( 0.0 , 0.0 )) / 2 !! A == diag([(0.5,0.5), (0.5,0.5)]) trace - Trace of a matrix Status Stable Description Trace of a matrix (rank-2 array) Syntax result = stdlib_linalg (A) Arguments A : Shall be a rank-2 array. If A is not square, then trace(A) will return the sum of diagonal values from the square sub-section of A . Return value Returns the trace of the matrix, i.e. the sum of diagonal elements. Example outer_product - Computes the outer product of two vectors Status Experimental Description Computes the outer product of two vectors Syntax d = stdlib_linalg (u, v) Arguments u : Shall be a rank-1 array v : Shall be a rank-1 array Return value Returns a rank-2 array equal to u v&#94;T (where u, v are considered column vectors). The shape of the returned array is [size(u), size(v)] . Example kronecker_product - Computes the Kronecker product of two rank-2 arrays Status Experimental Description Computes the Kronecker product of two rank-2 arrays Syntax C = stdlib_linalg (A, B) Arguments A : Shall be a rank-2 array with dimensions M1, N1 B : Shall be a rank-2 array with dimensions M2, N2 Return value Returns a rank-2 array equal to A \\otimes B . The shape of the returned array is [M1*M2, N1*N2] . Example cross_product - Computes the cross product of two vectors Status Experimental Description Computes the cross product of two vectors Syntax c = stdlib_linalg (a, b) Arguments a : Shall be a rank-1 and size-3 array b : Shall be a rank-1 and size-3 array Return value Returns a rank-1 and size-3 array which is perpendicular to both a and b . Example is_square - Checks if a matrix is square Status Experimental Description Checks if a matrix is square Syntax d = stdlib_linalg (A) Arguments A : Shall be a rank-2 array Return value Returns a logical scalar that is .true. if the input matrix is square, and .false. otherwise. Example is_diagonal - Checks if a matrix is diagonal Status Experimental Description Checks if a matrix is diagonal Syntax d = stdlib_linalg (A) Arguments A : Shall be a rank-2 array Return value Returns a logical scalar that is .true. if the input matrix is diagonal, and .false. otherwise.\nNote that nonsquare matrices may be diagonal, so long as a_ij = 0 when i /= j . Example is_symmetric - Checks if a matrix is symmetric Status Experimental Description Checks if a matrix is symmetric Syntax d = stdlib_linalg (A) Arguments A : Shall be a rank-2 array Return value Returns a logical scalar that is .true. if the input matrix is symmetric, and .false. otherwise. Example is_skew_symmetric - Checks if a matrix is skew-symmetric Status Experimental Description Checks if a matrix is skew-symmetric Syntax d = stdlib_linalg (A) Arguments A : Shall be a rank-2 array Return value Returns a logical scalar that is .true. if the input matrix is skew-symmetric, and .false. otherwise. Example hermitian - Compute the Hermitian version of a rank-2 matrix Status Experimental Description Compute the Hermitian version of a rank-2 matrix. \nFor complex matrices, the function returns the conjugate transpose ( conjg(transpose(a)) ). \nFor real or integer matrices, the function returns the transpose ( transpose(a) ). Syntax h = stdlib_linalg (a) Arguments a : Shall be a rank-2 array of type integer , real , or complex . The input matrix a is not modified. Return value Returns a rank-2 array of the same shape and type as a . If a is of type complex , the Hermitian matrix is computed as conjg(transpose(a)) . \nFor real or integer types, it is equivalent to the intrinsic transpose(a) . Example is_hermitian - Checks if a matrix is Hermitian Status Experimental Description Checks if a matrix is Hermitian Syntax d = stdlib_linalg (A) Arguments A : Shall be a rank-2 array Return value Returns a logical scalar that is .true. if the input matrix is Hermitian, and .false. otherwise. Example is_triangular - Checks if a matrix is triangular Status Experimental Description Checks if a matrix is triangular Syntax d = stdlib_linalg (A,uplo) Arguments A : Shall be a rank-2 array uplo : Shall be a single character from {'u','U','l','L'} Return value Returns a logical scalar that is .true. if the input matrix is the type of triangular specified by uplo (upper or lower), and .false. otherwise.\nNote that the definition of triangular used in this implementation allows nonsquare matrices to be triangular.\nSpecifically, upper triangular matrices satisfy a_ij = 0 when j < i , and lower triangular matrices satisfy a_ij = 0 when j > i . Example is_hessenberg - Checks if a matrix is hessenberg Status Experimental Description Checks if a matrix is Hessenberg Syntax d = stdlib_linalg (A,uplo) Arguments A : Shall be a rank-2 array uplo : Shall be a single character from {'u','U','l','L'} Return value Returns a logical scalar that is .true. if the input matrix is the type of Hessenberg specified by uplo (upper or lower), and .false. otherwise.\nNote that the definition of Hessenberg used in this implementation allows nonsquare matrices to be Hessenberg.\nSpecifically, upper Hessenberg matrices satisfy a_ij = 0 when j < i-1 , and lower Hessenberg matrices satisfy a_ij = 0 when j > i+1 . Example solve - Solves a linear matrix equation or a linear system of equations. Status Stable Description This function computes the solution to a linear matrix equation , where is a square, full-rank, real or complex matrix. Result vector or array x returns the exact solution to within numerical precision, provided that the matrix is not ill-conditioned. \nAn error is returned if the matrix is rank-deficient or singular to working precision. \nThe solver is based on LAPACK's *GESV backends. Syntax Pure interface: x = stdlib_linalg (a, b) Expert interface: x = stdlib_linalg (a, b [, overwrite_a], err) Arguments a : Shall be a rank-2 real or complex square array containing the coefficient matrix. It is normally an intent(in) argument. If overwrite_a=.true. , it is an intent(inout) argument and is destroyed by the call. b : Shall be a rank-1 or rank-2 array of the same kind as a , containing the right-hand-side vector(s). It is an intent(in) argument. overwrite_a (optional): Shall be an input logical flag. if .true. , input matrix a will be used as temporary storage and overwritten. This avoids internal data allocation. This is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. The function is not pure if this argument is provided. Return value For a full-rank matrix, returns an array value that represents the solution to the linear system of equations. Raises LINALG_ERROR if the matrix is singular to working precision.\nRaises LINALG_VALUE_ERROR if the matrix and rhs vectors have invalid/incompatible sizes.\nIf err is not present, exceptions trigger an error stop . Example solve_lu - Solves a linear matrix equation or a linear system of equations (subroutine interface). Status Stable Description This subroutine computes the solution to a linear matrix equation , where is a square, full-rank, real or complex matrix. Result vector or array x returns the exact solution to within numerical precision, provided that the matrix is not ill-conditioned. \nAn error is returned if the matrix is rank-deficient or singular to working precision. \nIf all optional arrays are provided by the user, no internal allocations take place.\nThe solver is based on LAPACK's *GESV backends. Syntax Simple ( Pure ) interface: call stdlib_linalg (a, b, x) Expert ( Pure ) interface: call stdlib_linalg (a, b, x [, pivot, overwrite_a, err]) Arguments a : Shall be a rank-2 real or complex square array containing the coefficient matrix. It is normally an intent(in) argument. If overwrite_a=.true. , it is an intent(inout) argument and is destroyed by the call. b : Shall be a rank-1 or rank-2 array of the same kind as a , containing the right-hand-side vector(s). It is an intent(in) argument. x : Shall be a rank-1 or rank-2 array of the same kind and size as b , that returns the solution(s) to the system. It is an intent(inout) argument, and must have the contiguous property. pivot (optional): Shall be a rank-1 array of the same kind and matrix dimension as a , providing storage for the diagonal pivot indices. It is an intent(inout) arguments, and returns the diagonal pivot indices. overwrite_a (optional): Shall be an input logical flag. if .true. , input matrix a will be used as temporary storage and overwritten. This avoids internal data allocation. This is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. Return value For a full-rank matrix, returns an array value that represents the solution to the linear system of equations. Raises LINALG_ERROR if the matrix is singular to working precision.\nRaises LINALG_VALUE_ERROR if the matrix and rhs vectors have invalid/incompatible sizes.\nIf err is not present, exceptions trigger an error stop . Example lstsq - Computes the least squares solution to a linear matrix equation. Status Stable Description This function computes the least-squares solution to a linear matrix equation . Result vector x returns the approximate solution that minimizes the 2-norm , i.e., it contains the least-squares solution to the problem. Matrix A may be full-rank, over-determined, or under-determined. The solver is based on LAPACK's *GELSD backends. Syntax x = stdlib_linalg (a, b, [, cond, overwrite_a, rank, err]) Arguments a : Shall be a rank-2 real or complex array containing the coefficient matrix. It is an intent(inout) argument. b : Shall be a rank-1 or rank-2 array of the same kind as a , containing one or more right-hand-side vector(s), each in its leading dimension. It is an intent(in) argument. cond (optional): Shall be a scalar real value cut-off threshold for rank evaluation: s_i >= cond*maxval(s), i=1:rank . Shall be a scalar, intent(in) argument. overwrite_a (optional): Shall be an input logical flag. If .true. , input matrix A will be used as temporary storage and overwritten. This avoids internal data allocation. This is an intent(in) argument. rank (optional): Shall be an integer scalar value, that contains the rank of input matrix A . This is an intent(out) argument. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. Return value Returns an array value of the same kind and rank as b , containing the solution(s) to the least squares system. Raises LINALG_ERROR if the underlying Singular Value Decomposition process did not converge.\nRaises LINALG_VALUE_ERROR if the matrix and right-hand-side vector have invalid/incompatible sizes.\nExceptions trigger an error stop . Example solve_lstsq - Compute the least squares solution to a linear matrix equation (subroutine interface). Status Stable Description This subroutine computes the least-squares solution to a linear matrix equation . Result vector x returns the approximate solution that minimizes the 2-norm , i.e., it contains the least-squares solution to the problem. Matrix A may be full-rank, over-determined, or under-determined. The solver is based on LAPACK's *GELSD backends. Syntax call stdlib_linalg (a, b, x, [, real_storage, int_storage, [cmpl_storage, ] cond, singvals, overwrite_a, rank, err]) Arguments a : Shall be a rank-2 real or complex array containing the coefficient matrix. It is an intent(inout) argument. b : Shall be a rank-1 or rank-2 array of the same kind as a , containing one or more right-hand-side vector(s), each in its leading dimension. It is an intent(in) argument. x : Shall be an array of same kind and rank as b , and leading dimension of at least n , containing the solution(s) to the least squares system. It is an intent(inout) argument. real_storage (optional): Shall be a real rank-1 array of the same kind a , providing working storage for the solver. It minimum size can be determined with a call to stdlib_linalg . It is an intent(inout) argument. int_storage (optional): Shall be an integer rank-1 array, providing working storage for the solver. It minimum size can be determined with a call to stdlib_linalg . It is an intent(inout) argument. cmpl_storage (optional): For complex systems, it shall be a complex rank-1 array, providing working storage for the solver. It minimum size can be determined with a call to stdlib_linalg . It is an intent(inout) argument. cond (optional): Shall be a scalar real value cut-off threshold for rank evaluation: s_i >= cond*maxval(s), i=1:rank . Shall be a scalar, intent(in) argument. singvals (optional): Shall be a real rank-1 array of the same kind a and size at least min(m,n) , returning the list of singular values s(i)>=cond*maxval(s) from the internal SVD, in descending order of magnitude. It is an intent(out) argument. overwrite_a (optional): Shall be an input logical flag. If .true. , input matrix A will be used as temporary storage and overwritten. This avoids internal data allocation. This is an intent(in) argument. rank (optional): Shall be an integer scalar value, that contains the rank of input matrix A . This is an intent(out) argument. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. Return value Returns an array value that represents the solution to the least squares system. Raises LINALG_ERROR if the underlying Singular Value Decomposition process did not converge.\nRaises LINALG_VALUE_ERROR if the matrix and right-hand-side vector have invalid/incompatible sizes.\nExceptions trigger an error stop . Example lstsq_space - Compute internal working space requirements for the least squares solver. Status Stable Description This subroutine computes the internal working space requirements for the least-squares solver, stdlib_linalg . Syntax call stdlib_linalg (a, b, lrwork, liwork [, lcwork]) Arguments a : Shall be a rank-2 real or complex array containing the linear system coefficient matrix. It is an intent(in) argument. b : Shall be a rank-1 or rank-2 array of the same kind as a , containing the system's right-hand-side vector(s). It is an intent(in) argument. lrwork : Shall be an integer scalar, that returns the minimum array size required for the real working storage to this system. liwork : Shall be an integer scalar, that returns the minimum array size required for the integer working storage to this system. lcwork ( complex a , b ): For a complex system, shall be an integer scalar, that returns the minimum array size required for the complex working storage to this system. det - Computes the determinant of a square matrix Status Stable Description This function computes the determinant of a real or complex square matrix. This interface comes with a pure version det(a) , and a non-pure version det(a,overwrite_a,err) that\nallows for more expert control. Syntax c = stdlib_linalg (a [, overwrite_a, err]) Arguments a : Shall be a rank-2 square array overwrite_a (optional): Shall be an input logical flag. if .true. , input matrix a will be used as temporary storage and overwritten. This avoids internal data allocation.\n This is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value.  This is an intent(out) argument. Return value Returns a real scalar value of the same kind of a that represents the determinant of the matrix. Raises LINALG_ERROR if the matrix is singular.\nRaises LINALG_VALUE_ERROR if the matrix is non-square.\nExceptions are returned to the err argument if provided; an error stop is triggered otherwise. Example .det. - Determinant operator of a square matrix Status Stable Description This operator returns the determinant of a real square matrix. This interface is equivalent to the pure version of determinant stdlib_linalg . Syntax c = [[stdlib_linalg(module):operator(.det.)(interface)]] a Arguments a : Shall be a rank-2 square array of any real or complex kinds. It is an intent(in) argument. Return value Returns a real scalar value that represents the determinant of the matrix. Raises LINALG_ERROR if the matrix is singular.\nRaises LINALG_VALUE_ERROR if the matrix is non-square.\nExceptions trigger an error stop . Example qr - Compute the QR factorization of a matrix Status Experimental Description This subroutine computes the QR factorization of a real or complex matrix: where is orthonormal and is upper-triangular. Matrix has size [m,n] , with . The results are returned in output matrices and , that have the same type and kind as . \nGiven k = min(m,n) , one can write \\cdot ). \nBecause the lower rows of are zeros, a reduced problem may be solved. The size of \nthe input arguments determines what problem is solved: on full matrices ( shape(Q)==[m,m] , shape(R)==[m,n] ), \nthe full problem is solved. On reduced matrices ( shape(Q)==[m,k] , shape(R)==[k,n] ), the reduced problem is solved. Syntax call stdlib_linalg (a, q, r, [, storage] [, overwrite_a] [, err]) Arguments a : Shall be a rank-2 real or complex array containing the coefficient matrix of size [m,n] . It is an intent(in) argument, if overwrite_a=.false. . Otherwise, it is an intent(inout) argument, and is destroyed upon return. q : Shall be a rank-2 array of the same kind as a , containing the orthonormal matrix q . It is an intent(out) argument. It should have a shape equal to either [m,m] or [m,k] , whether the full or the reduced problem is sought for. r : Shall be a rank-2 array of the same kind as a , containing the upper triangular matrix r . It is an intent(out) argument. It should have a shape equal to either [m,n] or [k,n] , whether the full or the reduced problem is sought for. storage (optional): Shall be a rank-1 array of the same type and kind as a , providing working storage for the solver. Its minimum size can be determined with a call to stdlib_linalg . It is an intent(out) argument. overwrite_a (optional): Shall be an input logical flag (default: .false. ). If .true. , input matrix a will be used as temporary storage and overwritten. This avoids internal data allocation. It is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value. It is an intent(out) argument. Return value Returns the QR factorization matrices into the and arguments. Raises LINALG_VALUE_ERROR if any of the matrices has invalid or unsuitable size for the full/reduced problem.\nRaises LINALG_ERROR on insufficient user storage space.\nIf the state argument err is not present, exceptions trigger an error stop . Example qr_space - Compute internal working space requirements for the QR factorization. Status Experimental Description This subroutine computes the internal working space requirements for the QR factorization, stdlib_linalg . Syntax call stdlib_linalg (a, lwork, [, err]) Arguments a : Shall be a rank-2 real or complex array containing the coefficient matrix. It is an intent(in) argument. lwork : Shall be an integer scalar, that returns the minimum array size required for the working storage in stdlib_linalg to factorize a . err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. Example schur - Compute the Schur decomposition of a matrix Status Experimental Description This subroutine computes the Schur decomposition of a real or complex matrix: , where is unitary (orthonormal) and is upper-triangular (for complex matrices) or quasi-upper-triangular (for real matrices, with possible blocks on the diagonal). Matrix has size [n,n] . The results are returned in output matrices and . Matrix is the Schur form, and matrix is the unitary transformation matrix such that . If requested, the eigenvalues of can also be returned as a complex array of size [n] . Syntax call stdlib_linalg (a, t [, z,] [, eigvals] [, overwrite_a] [, storage] [, err]) Arguments a : Shall be a rank-2 real or complex array containing the matrix to be decomposed. It is an intent(inout) argument if overwrite_a = .true. ; otherwise, it is an intent(in) argument. t : Shall be a rank-2 array of the same kind as a , containing the Schur form of the matrix. It is an intent(out) argument and should have a shape of [n,n] . z : Shall be a rank-2 array of the same kind as a , containing the unitary matrix . It is an intent(out) argument and is optional. If provided, it should have the shape [n,n] . eigvals (optional): Shall be a rank-1 complex or real array of the same kind as a , containing the eigenvalues of (the diagonal elements of ), or their real component only. The array must be of size [n] . If not provided, the eigenvalues are not returned. It is an intent(out) argument. overwrite_a (optional): Shall be a logical flag (default: .false. ). If .true. , the input matrix a will be overwritten and destroyed upon return, avoiding internal data allocation. It is an intent(in) argument. storage (optional): Shall be a rank-1 array of the same type and kind as a , providing working storage for the solver. Its minimum size can be determined with a call to stdlib_linalg . It is an intent(inout) argument. err (optional): Shall be a type(linalg_state_type) value. It is an intent(out) argument. If not provided, exceptions trigger an error stop . Return value Returns the Schur decomposition matrices into the and arguments. If eigvals is provided, it will also return the eigenvalues of the matrix . Raises LINALG_VALUE_ERROR if any of the matrices have invalid or unsuitable size for the decomposition. Raises LINALG_VALUE_ERROR if the real component is only requested, but the eigenvalues have non-trivial imaginary parts.\nRaises LINALG_ERROR on insufficient user storage space. If the state argument err is not present, exceptions trigger an error stop . Example schur_space - Compute internal working space requirements for the Schur decomposition Status Experimental Description This subroutine computes the internal working space requirements for the Schur decomposition, stdlib_linalg . Syntax call stdlib_linalg (a, lwork, [, err]) Arguments a : Shall be a rank-2 real or complex array containing the matrix to be decomposed. It is an intent(in) argument. lwork : Shall be an integer scalar that returns the minimum array size required for the working storage in stdlib_linalg to decompose a . It is an intent(out) argument. err (optional): Shall be a type(linalg_state_type) value. It is an intent(out) argument. Return value Returns the required working storage size lwork for the Schur decomposition. This value can be used to pre-allocate a workspace array in case multiple Schur decompositions of the same matrix size are needed. If pre-allocated working arrays are provided, no internal memory allocations will take place during the decomposition. eig - Eigenvalues and Eigenvectors of a Square Matrix Status Stable Description This subroutine computes the solution to the eigenproblem , \nwhere is a square, full-rank, real or complex matrix, or to the generalized eigenproblem , \nwhere is a square matrix with the same type, kind and size as . Result array lambda returns the eigenvalues of . The user can request eigenvectors to be returned: if provided, on output left will contain the left eigenvectors, right the right eigenvectors of .\nBoth left and right are rank-2 arrays, where eigenvectors are stored as columns.\nThe solver is based on LAPACK's *GEEV (standard eigenproblem) and *GGEV (generalized eigenproblem) backends. Syntax For the standard eigenproblem: call stdlib_linalg (a, lambda [, right] [,left] [,overwrite_a] [,err]) For the generalized eigenproblem: call stdlib_linalg `(a, b, lambda [, right] [, left] [, overwrite_a] [, overwrite_b] [, err]) Arguments a : real or complex square array containing the coefficient matrix. If overwrite_a=.false. , it is an intent(in) argument. Otherwise, it is an intent(inout) argument and is destroyed by the call. b : real or complex square array containing the second coefficient matrix. If overwrite_b=.false. , it is an intent(in) argument.  Otherwise, it is an intent(inout) argument and is destroyed by the call. lambda : Shall be a complex or real rank-1 array of the same kind as a , containing the eigenvalues, or their real component only. It is an intent(out) argument. right (optional): Shall be a complex rank-2 array of the same size and kind as a , containing the right eigenvectors of a . It is an intent(out) argument. left (optional): Shall be a complex rank-2 array of the same size and kind as a , containing the left eigenvectors of a . It is an intent(out) argument. overwrite_a (optional): Shall be an input logical flag. if .true. , input matrix a will be used as temporary storage and overwritten. This avoids internal data allocation. This is an intent(in) argument. overwrite_b (optional): Shall be an input logical flag. If .true. , input matrix b will be used as temporary storage and overwritten. This avoids internal data allocation. This is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. Return value Raises LINALG_ERROR if the calculation did not converge.\nRaises LINALG_VALUE_ERROR if any matrix or arrays have invalid/incompatible sizes.\nRaises LINALG_VALUE_ERROR if the real component is only requested, but the eigenvalues have non-trivial imaginary parts.\nIf err is not present, exceptions trigger an error stop . Example eigh - Eigenvalues and Eigenvectors of a Real symmetric or Complex Hermitian Square Matrix Status Stable Description This subroutine computes the solution to the eigendecomposition ,\nwhere is a square, full-rank, real symmetric or complex Hermitian matrix. Result array lambda returns the real eigenvalues of . The user can request the orthogonal eigenvectors \nto be returned: on output vectors may contain the matrix of eigenvectors, returned as a column. Normally, only the lower triangular part of is accessed. On input, logical flag upper_a allows the user to request what triangular part of the matrix should be used. The solver is based on LAPACK's *SYEV and *HEEV backends. Syntax call stdlib_linalg (a, lambda [, vectors] [, upper_a] [, overwrite_a] [,err]) Arguments a : real or complex square array containing the coefficient matrix. It is an intent(in) argument. If overwrite_a=.true. , it is an intent(inout) argument and is destroyed by the call. lambda : Shall be a complex rank-1 array of the same precision as a , containing the eigenvalues. It is an intent(out) argument. vectors (optional): Shall be a rank-2 array of the same type, size and kind as a , containing the eigenvectors of a . It is an intent(out) argument. upper_a (optional): Shall be an input logical flag. If .true. , the upper triangular part of a will be accessed. Otherwise, the lower triangular part will be accessed. It is an intent(in) argument. overwrite_a (optional): Shall be an input logical flag. If .true. , input matrix a will be used as temporary storage and overwritten. This avoids internal data allocation. This is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. Return value Raises LINALG_ERROR if the calculation did not converge.\nRaises LINALG_VALUE_ERROR if any matrix or arrays have invalid/incompatible sizes.\nIf err is not present, exceptions trigger an error stop . Example eigvals - Eigenvalues of a Square Matrix Status Stable Description This function computes the eigenvalues for either a standard or generalized eigenproblem: Standard eigenproblem : , where is a square, full-rank real or complex matrix. Generalized eigenproblem : , where is a square matrix with the same type and kind as . The eigenvalues are stored in the result array lambda , which is complex (even for real input matrices). The solver uses LAPACK's *GEEV and *GGEV backends for the standard and generalized problems, respectively. Syntax For the standard eigenproblem: lambda = stdlib_linalg (a [, err]) For the generalized eigenproblem: lambda = stdlib_linalg (a, b [, err]) Arguments a : Shall be a real or complex square array containing the coefficient matrix. It is an intent(in) argument. b (optional): Shall be a real or complex square array containing the second coefficient matrix for the generalized problem. It is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. Return Value Returns a complex rank-1 array containing the eigenvalues of the problem. Raises LINALG_ERROR if the calculation did not converge. Raises LINALG_VALUE_ERROR if any matrix or arrays have invalid/incompatible sizes. If err is not present, exceptions trigger an error stop . Example eigvalsh - Eigenvalues of a Real Symmetric or Complex Hermitian Square Matrix Status Stable Description This function returns the eigenvalues to matrix : a where is a square, full-rank, real symmetric or complex Hermitian matrix.\nThe eigenvalues are solutions to the eigenproblem . Result array lambda is real , and returns the eigenvalues of . \nThe solver is based on LAPACK's *SYEV and *HEEV backends. Syntax lambda = stdlib_linalg (a, [, upper_a] [,err]) Arguments a : real or complex square array containing the coefficient matrix. It is an intent(in) argument. upper_a (optional): Shall be an input logical flag. If .true. , the upper triangular part of a will be used accessed. Otherwise, the lower triangular part will be accessed (default). It is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. Return value Returns a real array containing the eigenvalues of a . Raises LINALG_ERROR if the calculation did not converge.\nRaises LINALG_VALUE_ERROR if any matrix or arrays have invalid/incompatible sizes.\nIf err is not present, exceptions trigger an error stop . Example svd - Compute the singular value decomposition of a rank-2 array (matrix). Status Stable Description This subroutine computes the singular value decomposition of a real or complex rank-2 array (matrix) .\nThe solver is based on LAPACK's *GESDD backends. Result vector s returns the array of singular values on the diagonal of . \nIf requested, u contains the left singular vectors, as columns of .\nIf requested, vt contains the right singular vectors, as rows of . Syntax call stdlib_linalg (a, s, [, u, vt, overwrite_a, full_matrices, err]) Class Subroutine Arguments a : Shall be a rank-2 real or complex array containing the coefficient matrix of size [m,n] . It is an intent(inout) argument, but returns unchanged unless overwrite_a=.true. . s : Shall be a rank-1 real array, returning the list of k = min(m,n) singular values. It is an intent(out) argument. u (optional): Shall be a rank-2 array of same kind as a , returning the left singular vectors of a as columns. Its size should be [m,m] unless full_matrices=.false. , in which case, it can be [m,min(m,n)] . It is an intent(out) argument. vt (optional): Shall be a rank-2 array of same kind as a , returning the right singular vectors of a as rows. Its size should be [n,n] unless full_matrices=.false. , in which case, it can be [min(m,n),n] . It is an intent(out) argument. overwrite_a (optional): Shall be an input logical flag. If .true. , input matrix A will be used as temporary storage and overwritten. This avoids internal data allocation. By default, overwrite_a=.false. . It is an intent(in) argument. full_matrices (optional): Shall be an input logical flag. If .true. (default), matrices u and vt shall be full-sized. Otherwise, their secondary dimension can be resized to min(m,n) . See u , v for details. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. Return values Returns an array s that contains the list of singular values of matrix a .\nIf requested, returns a rank-2 array u that contains the left singular vectors of a along its columns.\nIf requested, returns a rank-2 array vt that contains the right singular vectors of a along its rows. Raises LINALG_ERROR if the underlying Singular Value Decomposition process did not converge.\nRaises LINALG_VALUE_ERROR if the matrix or any of the output arrays invalid/incompatible sizes.\nExceptions trigger an error stop , unless argument err is present. Example svdvals - Compute the singular values of a rank-2 array (matrix). Status Stable Description This subroutine computes the singular values of a real or complex rank-2 array (matrix) from its singular \nvalue decomposition . The solver is based on LAPACK's *GESDD backends. Result vector s returns the array of singular values on the diagonal of . Syntax s = stdlib_linalg (a [, err]) Arguments a : Shall be a rank-2 real or complex array containing the coefficient matrix of size [m,n] . It is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. Return values Returns an array s that contains the list of singular values of matrix a . Raises LINALG_ERROR if the underlying Singular Value Decomposition process did not converge.\nRaises LINALG_VALUE_ERROR if the matrix or any of the output arrays invalid/incompatible sizes.\nExceptions trigger an error stop , unless argument err is present. Example cholesky - Compute the Cholesky factorization of a rank-2 square array (matrix) Status Experimental Description This subroutine computes the Cholesky factorization of a real or complex rank-2 square array (matrix), , or . is symmetric or complex Hermitian, and , are lower- or upper-triangular, respectively. \nThe solver is based on LAPACK's *POTRF backends. Syntax call stdlib_linalg (a, c, lower [, other_zeroed] [, err]) Class Subroutine Arguments a : Shall be a rank-2 square real or complex array containing the coefficient matrix of size [n,n] . It is an intent(inout) argument, but returns unchanged if the argument c is present. c (optional): Shall be a rank-2 square real or complex of the same size and kind as a . It is an intent(out) argument, that returns the triangular Cholesky matrix L or U . lower : Shall be an input logical flag. If .true. , the lower triangular decomposition will be performed. If .false. , the upper decomposition will be performed. other_zeroed (optional): Shall be an input logical flag. If .true. , the unused part of the output matrix will contain zeroes. Otherwise, it will not be accessed. This saves cpu time. By default, other_zeroed=.true. . It is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value. It is an intent(out) argument. Return values The factorized matrix is returned in-place overwriting a if no other arguments are provided.\nOtherwise, it can be provided as a second argument c . In this case, a is not overwritten.\nThe logical flag lower determines whether the lower- or the upper-triangular factorization should be performed. Results are returned on the applicable triangular region of the output matrix, while the unused triangular region \nis filled by zeroes by default. Optional argument other_zeroed , if .false. allows the expert user to avoid zeroing the unused part; \nhowever, in this case, the unused region of the matrix is not accessed and will usually contain invalid values. Raises LINALG_ERROR if the underlying process did not converge.\nRaises LINALG_VALUE_ERROR if the matrix or any of the output arrays invalid/incompatible sizes.\nExceptions trigger an error stop , unless argument err is present. Example chol - Compute the Cholesky factorization of a rank-2 square array (matrix) Status Experimental Description This is a pure functional interface for the Cholesky factorization of a real or complex rank-2 square array (matrix) computed as , or . is symmetric or complex Hermitian, and , are lower- or upper-triangular, respectively. \nThe solver is based on LAPACK's *POTRF backends. Result matrix c has the same size and kind as a , and returns the lower or upper triangular factor. Syntax c = stdlib_linalg (a, lower [, other_zeroed]) Arguments a : Shall be a rank-2 square real or complex array containing the coefficient matrix of size [n,n] . It is an intent(inout) argument, but returns unchanged if argument c is present. lower : Shall be an input logical flag. If .true. , the lower triangular decomposition will be performed. If .false. , the upper decomposition will be performed. other_zeroed (optional): Shall be an input logical flag. If .true. , the unused part of the output matrix will contain zeroes. Otherwise, it will not be accessed. This saves cpu time. By default, other_zeroed=.true. . It is an intent(in) argument. Return values Returns a rank-2 array c of the same size and kind as a , that contains the triangular Cholesky matrix L or U . Raises LINALG_ERROR if the underlying process did not converge.\nRaises LINALG_VALUE_ERROR if the matrix or any of the output arrays invalid/incompatible sizes.\nExceptions trigger an error stop , unless argument err is present. Example .inv. - Inverse operator of a square matrix Status Stable Description This operator returns the inverse of a real or complex square matrix .\nThe inverse is defined such that . This interface is equivalent to the function stdlib_linalg . Syntax b = [[stdlib_linalg(module):operator(.inv.)(interface)]] a Arguments a : Shall be a rank-2 square array of any real or complex kinds. It is an intent(in) argument. Return value Returns a rank-2 square array with the same type, kind and rank as a , that contains the inverse of a . If an exception occurred on input errors, or singular matrix, NaN s will be returned.\nFor fine-grained error control in case of singular matrices prefer the subroutine and the function interfaces. Example invert - Inversion of a square matrix Status Stable Description This subroutine inverts a square real or complex matrix in-place.\nThe inverse is defined such that . On return, the input matrix a is replaced by its inverse.\nThe solver is based on LAPACK's *GETRF and *GETRI backends. Syntax call stdlib_linalg (a, [,inva] [, pivot] [, err]) Arguments a : Shall be a rank-2, square, real or complex array containing the coefficient matrix. \nIf inva is provided, it is an intent(in) argument.\nIf inva is not provided, it is an intent(inout) argument: on output, it is replaced by the inverse of a . inva (optional): Shall be a rank-2, square, real or complex array with the same size, and kind as a . \nOn output, it contains the inverse of a . pivot (optional): Shall be a rank-1 array of the same kind and matrix dimension as a , that contains the diagonal pivot indices on return. It is an intent(inout) argument. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. Return value Computes the inverse of the matrix , or in another matrix. Raises LINALG_ERROR if the matrix is singular or has invalid size.\nRaises LINALG_VALUE_ERROR if inva and a do not have the same size.\nIf err is not present, exceptions trigger an error stop . Example inv - Inverse of a square matrix. Status Stable Description This function returns the inverse of a square real or complex matrix in-place.\nThe inverse, , is defined such that . The solver is based on LAPACK's *GETRF and *GETRI backends. Syntax b stdlib_linalg (a, [, err]) Arguments a : Shall be a rank-2, square, real or complex array containing the coefficient matrix. It is an intent(inout) argument. err (optional): Shall be a type(linalg_state_type) value. It is an intent(out) argument. Return value Returns an array value of the same type, kind and rank as a , that contains the inverse matrix . Raises LINALG_ERROR if the matrix is singular or has invalid size.\nIf err is not present, exceptions trigger an error stop . Example pinv - Moore-Penrose pseudo-inverse of a matrix Status Experimental Description This function computes the Moore-Penrose pseudo-inverse of a real or complex matrix. The pseudo-inverse, , generalizes the matrix inverse and satisfies the conditions:\n- - - - The computation is based on singular value decomposition (SVD). Singular values below a relative \ntolerance threshold , where is the largest \nsingular value, are treated as zero. Syntax b = stdlib_linalg (a, [, rtol, err]) Arguments a : Shall be a rank-2, real or complex array of shape [m, n] containing the coefficient matrix. \nIt is an intent(in) argument. rtol (optional): Shall be a scalar real value specifying the relative tolerance for singular value cutoff. If rtol is not provided, the default relative tolerance is , where is the machine precision for the element type of a . It is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value. It is an intent(out) argument. Return value Returns an array value of the same type, kind, and rank as a with shape [n, m] , that contains the pseudo-inverse matrix . Raises LINALG_ERROR if the underlying SVD did not converge.\nRaises LINALG_VALUE_ERROR if a has invalid size.\nIf err is not present, exceptions trigger an error stop . Example pseudoinvert - Moore-Penrose pseudo-inverse of a matrix Status Experimental Description This subroutine computes the Moore-Penrose pseudo-inverse of a real or complex matrix.\nThe pseudo-inverse is a generalization of the matrix inverse and satisfies the following properties:\n- - - - The computation is based on singular value decomposition (SVD). Singular values below a relative \ntolerance threshold , where is the largest \nsingular value, are treated as zero. On return, matrix pinva [n, m] will store the pseudo-inverse of a [m, n] . Syntax call stdlib_linalg (a, pinva [, rtol] [, err]) Arguments a : Shall be a rank-2, real or complex array containing the coefficient matrix. It is an intent(in) argument. pinva : Shall be a rank-2 array of the same kind as a , and size equal to that of transpose(a) . On output, it contains the Moore-Penrose pseudo-inverse of a . rtol (optional): Shall be a scalar real value specifying the relative tolerance for singular value cutoff. If not provided, the default threshold is , where is the \nmachine precision for the element type of a . err (optional): Shall be a type(linalg_state_type) value. It is an intent(out) argument. Return value Computes the Moore-Penrose pseudo-inverse of the matrix , , and returns it in matrix pinva . Raises LINALG_ERROR if the underlying SVD did not converge.\nRaises LINALG_VALUE_ERROR if pinva and a have degenerate or incompatible sizes.\nIf err is not present, exceptions trigger an error stop . Example .pinv. - Moore-Penrose Pseudo-Inverse operator Status Experimental Description This operator returns the Moore-Penrose pseudo-inverse of a real or complex matrix .\nThe pseudo-inverse is computed using Singular Value Decomposition (SVD), and singular values \nbelow a given threshold are treated as zero. This interface is equivalent to the function stdlib_linalg . Syntax b = [[stdlib_linalg(module):operator(.pinv.)(interface)]] a Arguments a : Shall be a rank-2 array of any real or complex kinds, with arbitrary dimensions . It is an intent(in) argument. Return value Returns a rank-2 array with the same type, kind, and rank as a , that contains the Moore-Penrose pseudo-inverse of a . If an exception occurs, or if the input matrix is degenerate (e.g., rank-deficient), the returned matrix will contain NaN s.\nFor more detailed error handling, it is recommended to use the subroutine or function interfaces. Example get_norm - Computes the vector norm of a generic-rank array. Status Experimental Description This pure subroutine interface computes one of several vector norms of real or complex array , depending on \nthe value of the order input argument. may be an array of any rank. Result nrm returns a real , scalar norm value for the whole array; if dim is specified, nrm is a rank n-1 \narray with the same shape as and dimension dim dropped, containing all norms evaluated along dim . Syntax call stdlib_linalg (a, nrm, order, [, dim, err]) Arguments a : Shall be a rank-n real or complex array containing the data. It is an intent(in) argument. nrm : if dim is absent, shall be a scalar with the norm evaluated over all the elements of the array. Otherwise, an array of rank n-1 , and a shape similar\nto that of a with dimension dim dropped. order : Shall be an integer value or a character flag that specifies the norm type, as follows. It is an intent(in) argument. Integer input Character Input Norm type -huge(0) '-inf', '-Inf' Minimum absolute value ( \\min_i{ \\left 1 '1' 1-norm ( \\sum_i{ \\left 2 '2' Euclidean norm >=3 '3','4',... p-norm ( \\left( \\sum_i{ \\left huge(0) 'inf', 'Inf' Maximum absolute value ( \\max_i{ \\left dim (optional): Shall be a scalar integer value with a value in the range from 1 to n , where n is the rank of the array. It is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. If err is not present, the function is pure . Return value By default, the return value nrm is a scalar, and contains the norm as evaluated over all elements of the generic-rank array . \nIf the optional dim argument is present, nrm is a rank n-1 array with the same shape as except \nfor dimension dim , that is collapsed. Each element of nrm contains the 1D norm of the elements of , \nevaluated along dimension dim only. Raises LINALG_ERROR if the requested norm type is invalid.\nRaises LINALG_VALUE_ERROR if any of the arguments has an invalid size.\nIf err is not present, exceptions trigger an error stop . Example norm - Computes the vector norm of a generic-rank array. Status Experimental Description This function computes one of several vector norms of real or complex array , depending on \nthe value of the order input argument. may be an array of any rank. Syntax x = stdlib_linalg (a, order, [, dim, err]) Arguments a : Shall be a rank-n real or complex array containing the data. It is an intent(in) argument. order : Shall be an integer value or a character flag that specifies the norm type, as follows. It is an intent(in) argument. Integer input Character Input Norm type -huge(0) '-inf', '-Inf' Minimum absolute value ( \\min_i{ \\left 1 '1' 1-norm ( \\sum_i{ \\left 2 '2' Euclidean norm >=3 '3','4',... p-norm ( \\left( \\sum_i{ \\left huge(0) 'inf', 'Inf' Maximum absolute value ( \\max_i{ \\left dim (optional): Shall be a scalar integer value with a value in the range from 1 to n , where n is the rank of the array. It is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. If err is not present, the function is pure . Return value By default, the return value x is a scalar, and contains the norm as evaluated over all elements of the generic-rank array . \nIf the optional dim argument is present, x is a rank n-1 array with the same shape as except \nfor dimension dim , that is dropped. Each element of x contains the 1D norm of the elements of , \nevaluated along dimension dim only. Raises LINALG_ERROR if the requested norm type is invalid.\nRaises LINALG_VALUE_ERROR if any of the arguments has an invalid size.\nIf err is not present, exceptions trigger an error stop . Example mnorm - Computes the matrix norm of a generic-rank array. Status Experimental Description This function computes one of several matrix norms of real or complex array , depending on \nthe value of the order input argument. must be an array of rank 2 or higher. For arrays of rank > 2,\nmatrix norms are computed over specified dimensions. Syntax x = stdlib_linalg (a [, order, dim, err]) Arguments a : Shall be a rank-n real or complex array containing the data, where n >= 2. It is an intent(in) argument. order (optional): Shall be an integer value or a character flag that specifies the norm type, as follows. It is an intent(in) argument. Integer input Character Input Norm type 1 '1' 1-norm (maximum column sum) ( \\max_j \\sum_i{ \\left 2 '2' 2-norm (largest singular value) (not prov.) 'Euclidean','Frobenius','Fro' Frobenius norm ( \\sqrt{\\sum_{i,j}{ \\left huge(0) 'inf', 'Inf', 'INF' Infinity norm (maximum row sum) ( \\max_i \\sum_j{ \\left dim (optional): For arrays of rank > 2, shall be an integer array of size 2 specifying the dimensions over which to compute the matrix norm. Default value is [1,2] . It is an intent(in) argument. err (optional): Shall be a type(linalg_state_type) value. This is an intent(out) argument. Return value For rank-2 input arrays, the return value x is a scalar containing the matrix norm.\nFor arrays of rank > 2, if the optional dim argument is present, x is a rank n-2 array with the same shape as except \nfor dimensions dim(1) and dim(2) , which are dropped. Each element of x contains the matrix norm of the corresponding submatrix of ,\nevaluated over the specified dimensions only, with the given order. If an invalid norm type is provided, defaults to 1-norm and raises LINALG_ERROR .\nRaises LINALG_VALUE_ERROR if any of the arguments has an invalid size.\nIf err is not present, exceptions trigger an error stop . Example","tags":"","url":"page/specs/stdlib_linalg.html"},{"title":"linalg_state_type – LightConvex","text":"Linear Algebra -- State and Error Handling Module Linear Algebra -- State and Error Handling Module Introduction Derived types provided The linalg_state_type derived type Type-bound procedures Status Example Error flags provided Comparison operators provided Introduction The stdlib_linalg_state module provides a derived type holding information on the state of linear algebra operations, and procedures for expert control of linear algebra workflows. \nAll linear algebra procedures are engineered to support returning an optional linalg_state_type variable to hold such information, as a form of expert API. If the user does not require state information but fatal errors are encountered during the execution of linear algebra routines, the program will undergo a hard stop.\nInstead, if the state argument is present, the program will never stop but will return detailed error information into the state handler. Derived types provided The linalg_state_type derived type The linalg_state_type is an extension of the state_type derived type, containing an integer error flag and fixed-size character strings to store an error message and the location of the error state change. \nFixed-size string storage was chosen to facilitate the compiler's memory allocation and ultimately ensure maximum computational performance. A similarly named generic interface, linalg_state_type , is provided to allow the developer to create diagnostic messages and raise error flags easily. The call starts with an error flag or the location of the event and is followed by an arbitrary list of integer , real , complex , or character variables. Numeric variables may be provided as either scalars or rank-1 (array) inputs. Type-bound procedures The following convenience type-bound procedures are inherited from state_type and available:\n- print() returns an allocatable character string containing state location, message, and error flag; \n- print_message() returns an allocatable character string containing the state message; \n- ok() returns a logical flag that is .true. in case of successful state ( flag==LINALG_SUCCESS );\n- error() returns a logical flag that is .true. in case of an error state ( flag/=LINALG_SUCCESS ). Status Experimental Example Error flags provided The module provides the following state flags, mapped to the general state_type error flags: \n- LINALG_SUCCESS : Successful execution (equivalent to STDLIB_SUCCESS )\n- LINALG_VALUE_ERROR : Numerical errors (such as infinity, not-a-number, range bounds) are encountered (equivalent to STDLIB_VALUE_ERROR ).\n- LINALG_ERROR : Linear Algebra errors are encountered, such as non-converging iterations, and impossible operations (equivalent to STDLIB_LINALG_ERROR ).\n- LINALG_INTERNAL_ERROR : Provided as a developer safeguard for internal errors that should never occur (equivalent to STDLIB_INTERNAL_ERROR ). Comparison operators provided The module provides overloaded comparison operators for all comparisons of a linalg_state_type variable with an integer error flag: < , <= , == , >= , > , /= .","tags":"","url":"page/specs/stdlib_linalg_state_type.html"},{"title":"logger – LightConvex","text":"Loggers Loggers Introduction The stdlib_logger constants The derived type: logger_type Status Description Syntax Private attributes The stdlib_logger variable Public logger_type methods Specification of the logger_type methods add_log_file - open a file and add its unit to self % log_units Status Description Syntax Class Arguments Example add_log_unit - add a unit to the array self % log_units Status Description Syntax Class. Arguments Example configuration - report a logger's configuration Status Description Syntax Class Arguments Example configure - configure the logging process Status Description Syntax Class Arguments Example log_debug - Writes the string message to self % log_units Status Description Syntax Behavior Class Arguments Example log_error - Writes the string message to self % log_units Status Description Syntax Behavior Class Arguments Example log_information - Writes the string message to self % log_units Status Description Syntax Behavior Class Arguments Example log_io_error - Write the string message to self % log_units Status Description Behavior Syntax Class Arguments Example log_message - write the string message to self % log_units Status Description Behavior Syntax Class Arguments Example log_text_error - send a message to self % log_units describing an error Status Description Behavior Syntax Class Arguments Example log_units_assigned - returns the number of active I/O units Status Description Syntax Class Argument Result character Result value Example log_warning - write the string message to log_units Status Description Behavior Syntax Class Arguments Example remove_log_unit - remove unit from self % log_units Status Description Syntax Class Arguments Example Introduction This module defines a derived type, its methods, a variable, and\nconstants to be used for the reporting of errors, displaying messages,\nand other information. The derived type, logger_type , is to be used\nto define both global and local logger variables. The logger_type methods serve to configure the loggers and use the logger variables to\nreport messages to a variable specific list of I/O units termed log_units . The variable, global_logger , of type logger_type ,\nis intended to serve as the default global logger. The constants serve\nas error flags returned by the optional integer stat argument. The logger variables have the option to: change which units receive the log messages; report which units receive the log messages; select which types of messages are logged; precede messages by a blank line; precede messages by a time stamp of the form yyyy-mm-dd hh:mm:ss.sss ; precede messages with the names of a module and procedure; follow a message with the stat and errmsg of the error report\n  that prompted the log message; follow a message with the iostat and iomsg of the I/O error\n  report that prompted the log message; label a message with one of 'DEBUG: ' , 'INFO: ' , 'WARN: ' , 'ERROR: ' , or 'I/O ERROR: ' ; indent subsequent lines of the messages; and format the text to fit within a maximum column width. While every effort has been made to make the code process and\nasynchronous I/O safe, it is always best to have each process write to\nits own dedicated logger file.\nFor thread parallelism (e.g., with OpenMP), it is advised to put the\nlogger call in a guarding region (e.g., in an OpenMP critical region). Note: Loggers of type logger_type normally report their messages to I/O\nunits in the internal list termed log_units . However if log_units is empty then the messages go to the output_unit of the intrinsic\nmodule iso_fortran_env . The stdlib_logger constants The module defines nine distinct public integer constants for\nreporting errors in the stat arguments of some of the module's\nprocedures. The constants, termed error codes, are as follows: Error Code Description success no error was detected close_failure a close statement for an I/O unit failed index_invalid_error the column was invalid for the given line non_sequential_error the I/O unit did not have SEQUENTIAL access open_failure an open statement failed read_only_error an output unit did not have an access specifier of 'WRITE' or 'READWRITE' unformatted_in_error the unit did not have a form of 'FORMATTED' unopened_in_error the unit was not opened write_fault one of the writes to log_units failed The module also defines eight distinct public integer constants for\nselecting the messages that are logged. These constants, termed\nseverity levels, are (sorted following their increasing order of\nseverity): all_level , debug_level , information_level , warning_level , error_level , io_error_level , text_error_level ,\nand none_level .\nAll log messages with a level (e.g., debug_level ) lower than a\nspecified severity level (e.g., information_level ) will be ignored.\nThe levels error_level and io_error_level have the same severity.\nThe default severity level is information_level . The derived type: logger_type Status Experimental Description Serves to define 'logger' variables to be used in reporting\nsignificant events encountered during the execution of a program. Syntax type( stdlib_logger ) :: variable Private attributes Attribute Type Description Initial value add_blank_line Logical Flag to precede output with a blank line .false. indent_lines Logical Flag to indent subsequent lines by four columns .true. level Integer Severity level information_level log_units Integer array List of I/O units used for output Unallocated max_width Integer Maximum column width of output 0 time_stamp Logical Flag to precede output by a time stamp .true. units Integer Count of the number of active output units 0 The stdlib_logger variable The module defines one public variable, global_logger , of type logger_type . As might be guessed from its name, global_logger is\nintended to serve as the default logger for use throughout an\napplication. Public logger_type methods The module defines twelve public procedures: one function and eleven\nsubroutines.  The\nmethods are: Method Class Description add_log_file Subroutine Opens a file using newunit , and adds the resulting unit to the log_units list add_log_unit Subroutine Adds an existing unit to the log_units list configuration Subroutine Reports the details of the logging configuration configure Subroutine Configures the details of the logging process log_debug Subroutine Sends a message prepended by 'DEBUG: ' log_error Subroutine Sends a message prepended by 'ERROR: ' optionally followed by a stat or errmsg log_information Subroutine Sends a message prepended by 'INFO: ' log_io_error Subroutine Sends a message prepended by 'I/O ERROR: ' optionally followed by an iostat or iomsg log_message Subroutine Sends a message log_text_error Subroutine Sends a message describing an error found in a line of text log_units_assigned Function Returns the number of active I/O units in log_units log_warning Subroutine Sends a message prepended by 'WARN: ' remove_log_unit Subroutine Removes the unit number from the log_units array Specification of the logger_type methods add_log_file - open a file and add its unit to self % log_units Status Experimental Description Opens a formatted, sequential access, output file, filename using newunit and adds the resulting unit number to the logger's log_units array. Syntax call self % logger_type ( filename [, unit, action, position, status, stat ] ) Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(inout) argument. It shall be the logger to add the file to its log_units . filename : shall be a scalar default character expression. It is\nan intent(in) argument. It shall be the name of the file to be opened. unit (optional): shall be a scalar default integer variable. It is an intent(out) argument. It will be the unit number returned by the newunit specifier of the open statement for filename . action (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It shall be the action specifier of the open statement and must have one of the values 'WRITE' or 'READWRITE' . It has the default value of 'WRITE' . position (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It shall be the position specifier of the open statement and must have one of\n  the values 'ASIS' , 'REWIND' , or 'APPEND' . It has the default\n  value of 'REWIND' . status (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It shall be the status specifier of the open statement and must have one of\n  the values 'OLD' , 'NEW' , 'REPLACE' , or 'UNKNOWN' . It has the\n  default value of 'REPLACE' . stat (optional): shall be a scalar default integer variable. It\n  is an intent(out) argument. If present, on return it will have the\n  value success if filename could be opened, the value read_only_error if the action specifier is \"READ\" , or the value open_failure if filename could not be opened. If absent and filename could not be opened then processing will stop with an informative message as the stop code. Example add_log_unit - add a unit to the array self % log_units Status Experimental Description Adds unit to the array of self % log_units . The unit shall\nbe the unit number for an opened, sequential, formatted file with an action specifier of 'WRITE' or 'READWRITE' . Failure of unit to meet\nthose requirements will cause stat , if present, to not be success and unit will not be added to log_units . In this case, if stat is\nnot present, cause processing to stop with an informative string as\nthe stop code. Syntax call self % logger_type ( unit [, stat ] ) Class. Subroutine. Arguments self : shall be a scalar variable of type logger_type . It is an intent(inout) argument. It shall be the logger to direct its output\nto unit . unit : shall be a scalar default integer expression. It is an intent(in) argument. It shall be the unit number for an opened,\n  sequential, formatted file with an action specifier of 'WRITE' or 'READWRITE' . stat (optional): shall be a scalar default integer variable. It is\n  an intent(out) argument. If absent  and unit could not be added\n  to self's log_units processing will stop with an informative\n  message as the stop code. If present it shall have the value of one\n  of the module's error codes indicating any errors found with unit . The codes are\n  * success - no problem found\n  * non_sequential_error - unit did not have an access specifier of 'SEQUENTIAL' * read_only_error - unit had an action specifier of 'READ' when it needs a specifier of 'WRITE' or 'READWRITE' * unformatted_in_error - unit did not have a form specifier of 'FORMATTED' * unopened_in_error - unit was not opened Example configuration - report a logger's configuration Status Experimental Description Reports the configuration of a logger. Syntax call self % logger_type ( [ add_blankline, indent, level, max_width, time_stamp, log_units ] ) Class Pure subroutine Arguments self : shall be a scalar expression of type logger_type . It is an intent(in) argument. It shall be the logger whose configuration is reported. add_blank_line (optional): shall be a scalar default logical\n  variable. It is an intent(out) argument. A value of .true. starts output with a blank line, and .false. otherwise. indent (optional): shall be a scalar default logical variable. It\n  is an intent(out) argument. A value of .true. indents subsequent\n  lines by four spaces, and .false. otherwise. level (optional): shall be a scalar default integer variable. It is an intent(out) argument. The value corresponds to the severity level for\n  ignoring a message. max_width (optional): shall be a scalar default integer\n  variable. It is an intent(out) argument. A positive value bigger\n  than four defines the maximum width of the output, otherwise there\n  is no maximum width. time_stamp (optional): shall be a scalar default logical\n  variable. It is an intent(out) argument. A value of .true. precedes output with a time stamp of the form 'yyyy-mm-dd\n  hh:mm:ss.sss', and .false. otherwise. log_units (optional): shall be a rank one allocatable array\n  variable of type default integer. It is an intent(out) argument. On return it shall be the elements of the self 's log_units array. If there were no elements in self 's log_units , a\n  zero-sized array is returned. Example module example_mod use stdlib_logger type ( logger_type ) :: logger contains subroutine example_sub ( unit , ...) integer , intent ( in ) :: unit integer , allocatable :: log_units (:) call logger % configuration ( log_units = log_units ) if ( size ( log_units ) == 0 ) then call add_logger_unit ( unit ) end if end subroutine example_sub end module example_mod configure - configure the logging process Status Experimental Description Configures the logging process for self. Syntax call self % logger_type ( [ add_blank_line, indent, level, max_width, time_stamp ] ) Class Pure subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(inout) argument. It shall be the logger to be configured. add_blank_line (optional): shall be a scalar default logical\n  expression. It is an intent(in) argument. Set to .true. to start\n  output with a blank line, and to .false. otherwise. indent (optional): shall be a scalar default logical\n  expression. It is an intent(in) argument. Set to .true. to\n  indent subsequent lines by four spaces, and to .false. to\n  not indent. level (optional): shall be a scalar default integer expression. It is\n  an intent(in) argument. Set the severity level for ignoring a log\n  message. max_width (optional): shall be a scalar default integer\n  expression. It is an intent(in) argument. Set to a positive value\n  bigger than four to define the maximum width of the output,\n  otherwise there is no maximum width. time_stamp (optional): shall be a scalar default logical\n  expression. It is an intent(in) argument. Set to .true. to\n  precede output with a time stamp of the form 'yyyy-mm-dd\n  hh:mm:ss.sss', and to .false. otherwise. Example log_debug - Writes the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with optional additional text. Syntax call self % logger_type ( message [, module, procedure ] ) Behavior If time stamps are active, a time stamp is written, followed\nby module and procedure if present, and then message is written with the prefix 'DEBUG: ' . It is ignored if the level of self is higher than debug_level . Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. Note message may have embedded new_line calls. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_information call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_information call. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( selection ) integer , intent ( out ) :: selection character ( 128 ) :: errmsg , message integer :: stat write ( * , '(a)' ) \"Enter an integer to select a widget\" read ( * , '(i0)' ) selection write ( message , '(a, i0)' ) & \"The user selected \" , selection call logger % log_DEBUG ( message , & module = 'EXAMPLE_MOD' , procedure = 'EXAMPLE_SUB' ) end subroutine example_sub end module example_mod log_error - Writes the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with optional additional text. Syntax call self % logger_type ( message [, module, procedure, stat, errmsg ] ) Behavior If time stamps are active for self , a time stamp is written,\nfollowed by module and procedure if present, then message is written with the prefix 'ERROR: ' , and then\nif stat or errmsg are present they are written. It is ignored if the level of self is higher than error_level . Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. Note message may have embedded new_line calls. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_error call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_error call. stat (optional): shall be a scalar default integer expression. It\n  is an intent(in) argument. It should be the stat specifier of\n  the subroutine call or intrinsic statement that prompted the log_error call. errmsg (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the errmsg specifier of the subroutine call or intrinsic statement\n  that prompted the log_error call. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( size ) integer , intent ( in ) :: size character ( 128 ) :: errmsg , message integer :: stat allocate ( a ( size ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then write ( message , '(a, i0)' ) & \"Allocation of A failed with SIZE = \" , size call logger % log_error ( message , & module = 'EXAMPLE_MOD' , & procedure = 'EXAMPLE_SUB' , & stat = stat , & errmsg = errmsg ) end if end subroutine example_sub end module example_mod log_information - Writes the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with optional additional text. Syntax call self % logger_type ( message [, module, procedure ] ) Behavior If time stamps are active, a time stamp is written, followed\nby module and procedure if present, and then message is written with the prefix 'INFO: ' . It is ignored if the level of self is higher than information_level . Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. Note message may have embedded new_line calls. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_information call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_information call. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( selection ) integer , intent ( out ) :: selection character ( 128 ) :: errmsg , message integer :: stat write ( * , '(a)' ) \"Enter an integer to select a widget\" read ( * , '(i0)' ) selection write ( message , '(a, i0)' ) & \"The user selected \" , selection call logger % log_information ( message , & module = 'EXAMPLE_MOD' , procedure = 'EXAMPLE_SUB' ) end subroutine example_sub end module example_mod log_io_error - Write the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with\noptional additional text. Behavior If time stamps are active, a time stamp is written\nfirst. Then if module or procedure are present, they are\nwritten. Then message is written with the prefix 'I/O ERROR: ' . Then if iostat or iomsg are present they are\nwritten. It is ignored if the level of self is higher than io_error_level . Syntax call self % logger_type ( message [, module, procedure, iostat, iomsg ] ) Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. Note message may have embedded new_line calls. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_io_error call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_io_error call. iostat (optional): shall be a scalar default integer\n  expression. It is an intent(in) argument. It should be the iostat specifier of the subroutine call or intrinsic statement\n  that prompted the log_io_error call. iomsg (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the iomsg specifier of the subroutine call or intrinsic statement\n  that prompted the log_io_error call. Example log_message - write the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with\n  optional additional text. Behavior If time stamps are active, a time stamp is written,\nthen module and procedure are written if present,\nfollowed by prefix \\\\ ': ' , if present, and finally message . No severity level is applied to log_message . Syntax call self % logger_type ( message [, module, procedure, prefix ] ) Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. Note message may have embedded new_line calls. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_message call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_message call. prefix (optional): shall be a scalar default character expression.\nIt is an intent(in) argument. It will precede message with an ': ' appended. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( selection ) integer , intent ( out ) :: selection integer :: stat write ( * , '(a)' ) \"Enter an integer to select a widget\" read ( * , '(i0)' ) selection write ( message , '(a, i0)' ) & \"The user selected \" , selection call logger % log_message ( message , & module = 'EXAMPLE_MOD' , & procedure = 'EXAMPLE_SUB' , & prefix = ` INFO ' ) end subroutine example_sub end module example_mod log_text_error - send a message to self % log_units describing an error Status Experimental Description log_text_error sends a message to self % log_units describing an error found in a line of text. Behavior If time stamps are active first a time stamp is\nwritten. Then if filename or line_number are present they are\nwritten with column . Then line is written. Then a caret, '&#94;', is\nwritten below line at the column indicated by column . Then summary is written below the caret. It is ignored if the level of self is higher than text_error_level . Syntax call self % logger_type ( line, column, summary [, filename, line_number, caret, stat ] ) Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. line : shall be a scalar default character expression. It is an intent(in) argument. It should be the line of text in which the\n  error was found. column : shall be a scalar default integer expression. It is an intent(in) argument. It should be the one's based column at which\n  the error begins. summary : shall be a scalar default character expression. It is an intent(in) argument. It should be a description of the error in line . filename (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the file, if any, in which line was found. line_number (optional): shall be a scalar default integer\n  expression. It is an intent(in) argument. It should be the line\n  number in filename associated with line . caret (optional): shall be a scalar default single character\n  expression. It is an intent(in) argument. If present it will be\n  placed below line on output to indicate the starting location of\n  the error. It has a default value of '&#94;'. stat (optional): shall be a scalar default integer variable. It\n  is an intent(out) argument. If present it will have the value of success if no errors were encountered, the value index_invalid_error if column is less than one or greater than len(line)+1 , or the value write_fault if the writes to any of log_units failed. If stat is absent and would not have the value success then processing will stop with an informative stop code. Example log_units_assigned - returns the number of active I/O units Status Experimental Description Returns the number of active I/O units in self % log_units Syntax result = self % logger_type () Class Elemental function Argument self : shall be a scalar expression of type logger_type . It is an intent(in) argument. It is the logger whose state is queried. Result character The result shall be a scalar of type default integer. Result value The result is the number of I/O units in self % log_units . Example module example_mod use stdlib_logger type ( logger_type ) :: logger contains subroutine example_sub ( unit , ...) integer , intent ( in ) :: unit integer , allocatable :: log_units (:) if ( logger % log_units_assigned () == 0 ) then call logger % add_log_unit ( unit ) end if end subroutine example_sub end module example_mod log_warning - write the string message to log_units Status Experimental Description Writes the string message to log_units with\n  optional additional text. Behavior If time stamps are active, a time stamp is written,\nthen module and procedure if present, then message is written with the prefix WARN: ' . Syntax call self % logger_type ( message [, module, procedure ] ) Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. Note message may have embedded new_line calls. module : (optional) shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_warning call. procedure : (optional) shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_warning call. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( size , stat ) integer , intent ( in ) :: size integer , intent ( out ) :: stat allocate ( a ( size ) ) if ( stat /= 0 ) then write ( message , '(a, i0)' ) & \"Allocation of A failed with SIZE = \" , size call logger % log_warning ( message , & module = 'EXAMPLE_MOD' , & procedure = 'EXAMPLE_SUB' ) end if end subroutine example_sub end module example_mod remove_log_unit - remove unit from self % log_units Status Experimental Description Remove unit from the self % log_units list. If close_unit is present and .true. then the corresponding file is\nclosed. If unit is not in self % log_units then nothing is done. Syntax call self % logger_type ( unit [, close_unit, stat ] ) Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(inout) argument. It is the logger whose log_units is to be\nmodified. unit : shall be a scalar default integer expression. It is an intent(in) argument. It should be one of the I/O unit numbers\n  in self % log_units . If it is not, then nothing is done. close_unit (optional): shall be a scalar default logical\n  expression. It is an intent(in) argument. If .true and unit is\n  in self % log_units then unit will be closed, otherwise the I/O unit\n  will be unaffected. stat (optional): shall be a scalar default integer variable. It is\n  an intent(out) argument. If present it has the default value of success , but has the value close_failure if close_unit is\n  present with the value .true. , and unit is initially in log_units , and closing unit fails. If stat is absent and\n  closing the unit fails then processing stops with an informative\n  stop code. Example module example_mod use stdlib_logger , global => global_logger contains subroutine example_sub ( unit , ...) integer , intent ( in ) :: unit call global % remove_log_unit ( unit ) end subroutine example_sub end module example_mod","tags":"","url":"page/specs/stdlib_logger.html"},{"title":"math – LightConvex","text":"The stdlib_math module The stdlib_math module Introduction Procedures and Methods provided clip function Description Syntax Status Class Argument(s) Output value or Result value Examples Example 1: Example 2: swap subroutine Description Syntax Status Class Argument(s) Note Examples gcd function Description Syntax Status Class Argument(s) Output value or Result value Examples Example 1: linspace - Create a linearly spaced rank one array Description Syntax Status Class Argument(s) Output value or Result value Examples Example 1: Example 2: logspace - Create a logarithmically spaced rank one array Description Syntax Status Class Argument(s) Output value or Result value Examples Example 1: Example 2: Example 3: arange function Status Class Description Syntax Arguments Warning Return value Example arg function Status Class Description Syntax Arguments Return value Example argd function Status Class Description Syntax Arguments Return value Example argpi function Status Class Description Syntax Arguments Return value Example deg2rad Status Class Description Syntax Arguments Return value Example rad2deg Status Class Description Syntax Arguments Return value Example is_close function Description Syntax Status Class Arguments Result value Example all_close function Description Syntax Status Class Arguments Result value Example diff function Description Syntax Status Class Arguments Result value Example meshgrid subroutine Description Syntax Status Class Arguments Example Introduction stdlib_math module provides general purpose mathematical functions. Procedures and Methods provided clip function Description Returns a value which lies in the given interval [ xmin , xmax ] (interval is xmin and xmax inclusive) and is closest to the input value x . Syntax res = stdlib_math (x, xmin, xmax) Status Experimental Class Elemental function. Argument(s) x : scalar of either integer or real type. This argument is intent(in) . xmin : scalar of either integer or real type. This argument is intent(in) . xmax : scalar of either integer or real type, which must be greater than or equal to xmin . This argument is intent(in) . Note: All arguments must have same type and same kind . Output value or Result value The output is a scalar of type and kind same as to that of the arguments. Examples Example 1: Here inputs are of type integer and kind int32 Example 2: Here inputs are of type real and kind sp swap subroutine Description Swaps the values in lhs and rhs . Syntax call stdlib_math (lhs, rhs) Status Experimental Class Elemental subroutine. Argument(s) lhs : scalar or array of any of the intrinsic types integer , real , complex , logical , character , string_type , bitset type. This argument is intent(inout) . rhs : scalar or array of any of the intrinsic types integer , real , complex , logical , character , string_type , bitset type. This argument is intent(inout) . Note All arguments must have same type and same kind . WARNING : For fix size characters with different length, the swap subroutine will truncate the longest amongst lhs and rhs . To avoid truncation it is possible to pass a subsection of the string. Examples gcd function Description Returns the greatest common divisor of two integers. Syntax res = stdlib_math (a, b) Status Experimental Class Elemental function. Argument(s) a : One integer with intent(in) to get the divisor for. b : Another integer with intent(in) to get the divisor for. Note: All arguments must be integers of the same kind . Output value or Result value Returns an integer of the same kind as that of the arguments. Examples Example 1: linspace - Create a linearly spaced rank one array Description Returns a linearly spaced rank 1 array from [ start , end ]. Optionally, you can specify the length of the returned array by passing n . Syntax res = stdlib_math (start, end [, n]) Status Experimental Class Pure function. Argument(s) start : Shall be scalar of any numeric type or kind. This argument is intent(in) . end : Shall be the same type and kind as start . This argument is intent(in) . n : Shall be an integer specifying the length of the output. This argument is optional and intent(in) . Output value or Result value The output is a rank 1 array whose length is either 100 (default value) or n . If n == 1, return a rank 1 array whose only element is end .\nIf n <= 0, return a rank 1 array with length 0. If start / end are real or complex types, the result will be of the same type and kind as start / end .\nIf start / end are integer types, the result will default to a real(dp) array. Examples Example 1: Here inputs are of type complex and kind dp Example 2: Here inputs are of type integer and kind int16 , with the result defaulting to real(dp) . logspace - Create a logarithmically spaced rank one array Description Returns a logarithmically spaced rank 1 array from [ base &#94; start , base &#94; end ]. The default size of the array is 50. Optionally, you can specify the length of the returned array by passing n . You can also specify the base used to compute the range (default 10). Syntax res = stdlib_math (start, end [, n [, base]]) Status Experimental Class Pure function. Argument(s) start : Shall be a scalar of any numeric type. All kinds are supported for real and complex arguments. For integers, only the default kind is currently implemented. This argument is intent(in) . end : Shall be the same type and kind as start . This argument is intent(in) . n : Shall be an integer specifying the length of the output. This argument is optional and intent(in) . base : Shall be a scalar of any numeric type. All kinds are supported for real and complex arguments. For integers, only the default kind is currently implemented. This argument is optional and intent(in) . Output value or Result value The output is a rank 1 array whose length is either 50 (default value) or n . If n == 1, return a rank 1 array whose only element is base &#94; end .\nIf n <= 0, return a rank 1 array with length 0 The type and kind of the output is dependent on the type and kind of the passed parameters. For function calls where the base is not specified: logspace(start, end) / logspace(start, end, n) , the type and kind of\nthe output follows the same scheme as above for linspace . If start / end are real or complex types, the result will be the same type and kind as start / end .\nIf start / end are integer types, the result will default to a real(dp) array. For function calls where the base is specified, the type and kind of the result is in accordance with the following table: start / end n base output real(KIND) Integer real(KIND) real(KIND) \"          \" \"       \" complex(KIND) complex(KIND) \"          \" \"       \" Integer real(KIND) complex(KIND) \"       \" real(KIND) complex(KIND) \"             \" \"       \" complex(KIND) complex(KIND) \"             \" \"       \" Integer complex(KIND) Integer \"        \" real(KIND) real(KIND) \"              \" \"        \" complex(KIND) complex(KIND) \"              \" \"        \" Integer Integer Examples Example 1: Here inputs are of type complex and kind dp . n and base is not specified and thus default to 50 and 10, respectively. Example 2: Here inputs are of type integer and default kind. base is not specified and thus defaults to 10. Example 3: Here start / end are of type real and double precision. base is type complex and also double precision. arange function Status Experimental Class Pure function. Description Creates a rank-1 array of the integer/real type with fixed-spaced values of given spacing, within a given interval. Syntax result = stdlib_math (start [, end, step]) Arguments All arguments should be the same type and kind. start : Shall be an integer/real scalar.\nThis is an intent(in) argument. The default start value is 1 . end : Shall be an integer/real scalar.\nThis is an intent(in) and optional argument. The default end value is the inputted start value. step : Shall be an integer/real scalar and large than 0 . \nThis is an intent(in) and optional argument. The default step value is 1 . Warning If step = 0 , the step argument will be corrected to 1/1.0 by the internal process of the arange function. If step < 0 , the step argument will be corrected to abs(step) by the internal process of the arange function. Return value Returns a rank-1 array of fixed-spaced values. For integer type arguments, the length of the result vector is (end - start)/step + 1 . For real type arguments, the length of the result vector is floor((end - start)/step) + 1 . Example arg function Status Experimental Class Elemental function. Description arg computes the phase angle (radian version) of complex scalar in the interval (-π,π]. \nThe angles in θ are such that z = abs(z)*exp((0.0, θ)) . Syntax result = stdlib_math (z) Arguments z : Shall be a complex scalar/array.\nThis is an intent(in) argument. Return value Returns the real type phase angle (radian version) of the complex argument z . Notes: Although the angle of the complex number 0 is undefined, arg((0,0)) returns the value 0 . Example argd function Status Experimental Class Elemental function. Description argd computes the phase angle (degree version) of complex scalar in the interval (-180.0,180.0]. \nThe angles in θ are such that z = abs(z)*exp((0.0, θ*π/180.0)) . Syntax result = stdlib_math (z) Arguments z : Shall be a complex scalar/array.\nThis is an intent(in) argument. Return value Returns the real type phase angle (degree version) of the complex argument z . Notes: Although the angle of the complex number 0 is undefined, argd((0,0)) returns the value 0 . Example argpi function Status Experimental Class Elemental function. Description argpi computes the phase angle (IEEE circular version) of complex scalar in the interval (-1.0,1.0]. \nThe angles in θ are such that z = abs(z)*exp((0.0, θ*π)) . Syntax result = stdlib_math (z) Arguments z : Shall be a complex scalar/array.\nThis is an intent(in) argument. Return value Returns the real type phase angle (circular version) of the complex argument z . Notes: Although the angle of the complex number 0 is undefined, argpi((0,0)) returns the value 0 . Example deg2rad Status Experimental Class Elemenal function. Description deg2rad converts phase angles from degrees to radians. Syntax result = stdlib_math (theta) Arguments theta : Shall be a real scalar/array. Return value Returns the real phase angle in radians. Example rad2deg Status Experimental Class Elemenal function. Description rad2deg converts phase angles from radians to degrees. Syntax result = stdlib_math (theta) Arguments theta : Shall be a real scalar/array. Return value Returns the real phase angle in degrees. Example is_close function Description Returns a boolean scalar/array where two scalars/arrays are element-wise equal within a tolerance. !> For `real` type is_close ( a , b , rel_tol , abs_tol ) = abs ( a - b ) <= max ( rel_tol * ( abs ( a ), abs ( b )), abs_tol ) !> and for `complex` type is_close ( a , b , rel_tol , abs_tol ) = is_close ( a % re , b % re , rel_tol , abs_tol ) . and . & is_close ( a % im , b % im , rel_tol , abs_tol ) Syntax bool = stdlib_math (a, b [, rel_tol, abs_tol, equal_nan]) Status Experimental. Class Elemental function. Arguments Note: All real/complex arguments must have same kind . If the value of rel_tol/abs_tol is negative (not recommended), \nit will be corrected to abs(rel_tol/abs_tol) by the internal process of is_close . a : Shall be a real/complex scalar/array.\nThis argument is intent(in) . b : Shall be a real/complex scalar/array.\nThis argument is intent(in) . rel_tol : Shall be a real scalar/array.\nThis argument is intent(in) and optional , which is sqrt(epsilon(..)) by default. abs_tol : Shall be a real scalar/array.\nThis argument is intent(in) and optional , which is 0.0 by default. equal_nan : Shall be a logical scalar/array.\nThis argument is intent(in) and optional , which is .false. by default.\nWhether to compare NaN values as equal. If .true. , NaN values in a will be considered equal to NaN values in b . Result value Returns a logical scalar/array. Example all_close function Description Returns a boolean scalar where two arrays are element-wise equal within a tolerance. Syntax bool = stdlib_math (a, b [, rel_tol, abs_tol, equal_nan]) Status Experimental. Class Pure function. Arguments Note: All real/complex arguments must have same kind . If the value of rel_tol/abs_tol is negative (not recommended), \nit will be corrected to abs(rel_tol/abs_tol) by the internal process of all_close . a : Shall be a real/complex array.\nThis argument is intent(in) . b : Shall be a real/complex array.\nThis argument is intent(in) . rel_tol : Shall be a real scalar.\nThis argument is intent(in) and optional , which is sqrt(epsilon(..)) by default. abs_tol : Shall be a real scalar.\nThis argument is intent(in) and optional , which is 0.0 by default. equal_nan : Shall be a logical scalar.\nThis argument is intent(in) and optional , which is .false. by default.\nWhether to compare NaN values as equal. If .true. , NaN values in a will be considered equal to NaN values in b . Result value Returns a logical scalar. Example diff function Description Computes differences between adjacent elements of an array. Syntax For a rank-1 array: y = stdlib_math (x [, n, prepend, append]) and for a rank-2 array: y = stdlib_math (x [, n, dim, prepend, append]) Status Experimental. Class Pure function. Arguments x : The array to take a difference of.\nShall be a real/integer and rank-1/rank-2 array.\nThis argument is intent(in) . n : How many times to iteratively calculate the difference.\nShall be an integer scalar.\nThis argument is intent(in) and optional , and has value of 1 by default. dim : The dimension of the input array along which to calculate the difference.\nIts value must be between 1 and rank(x) .\nShall be an integer scalar.\nThis argument is intent(in) and optional and has a value of 1 by default. prepend , append : Arrays to prepend or append to a along axis prior to performing the difference.\nThe dimension and shape must match a except along axis.\nShall be a real/integer and rank-1/rank-2 array.\nThis argument is intent(in) and optional , which is no value by default. Note: The x , prepend and append arguments must have the same type , kind and rank . If the value of n is less than or equal to 0 (which is not recommended), the return value of diff is x . If the value of dim is not equal to 1 or 2 (which is not recommended), 1 will be used by the internal process of diff . Result value Returns the finite difference of the input array.\nShall be a real/integer and rank-1/rank-2 array.\nWhen both prepend and append are not present, the result y has one fewer element than x alongside the dimension dim . Example meshgrid subroutine Description Computes a list of coordinate matrices from coordinate vectors. For $n \\geq 1$ coordinate vectors $(x_1, x_2, ..., x_n)$ of sizes $(s_1, s_2, ..., s_n)$, meshgrid computes $n$ coordinate matrices $(X_1, X_2, ..., X_n)$ with identical shape corresponding to the selected indexing:\n- Cartesian indexing (default behavior): the shape of the coordinate matrices is $(s_2, s_1, s_3, s_4, ... s_n)$.\n- matrix indexing: the shape of the coordinate matrices is $(s_1, s_2, s_3, s_4, ... s_n)$. Syntax For a 2D problem in Cartesian indexing: call stdlib_math (x, y, xm, ym) For a 3D problem in Cartesian indexing: call stdlib_math (x, y, z, xm, ym, zm) For a 3D problem in matrix indexing: call stdlib_math (x, y, z, xm, ym, zm, indexing=\"ij\") The subroutine can be called in n -dimensional situations, as long as n is inferior to the maximum allowed array rank. Status Experimental. Class Subroutine. Arguments For a n -dimensional problem, with n >= 1 : x1, x2, ..., xn : The coordinate vectors.\nShall be real/integer and rank-1 arrays.\nThese arguments are intent(in) . xm1, xm2, ..., xmn : The coordinate matrices.\nShall be arrays of type real or integer of adequate shape:\n- for Cartesian indexing, the shape of the coordinate matrices must be [size(x2), size(x1), size(x3), ..., size(xn)] .\n- for matrix indexing, the shape of the coordinate matrices must be [size(x1), size(x2), size(x3), ..., size(xn)] . These argument are intent(out) . indexing : the selected indexing.\nShall be an integer equal to stdlib_meshgrid_xy for Cartesian indexing (default), or stdlib_meshgrid_ij for matrix indexing. stdlib_meshgrid_xy and stdlib_meshgrid_ij are public constants defined in the module.\nThis argument is intent(in) and optional , and is equal to stdlib_meshgrid_xy by default. Example","tags":"","url":"page/specs/stdlib_math.html"},{"title":"optval – LightConvex","text":"Default values for optional arguments Default values for optional arguments optval - fallback value for optional arguments Status Description Syntax Arguments Return value Example optval - fallback value for optional arguments Status Experimental Description Returns x if it is present, otherwise default . This function is intended to be called in a procedure with one or more optional arguments, in order to conveniently fall back to a default value if an optional argument is not present. Syntax result = stdlib_optval (x, default) Arguments x : Shall be of type integer , real , complex , or logical , or a scalar of type character . default : Shall have the same type, kind, and rank as x . Return value If x is present, the result is x , otherwise the result is default . Example","tags":"","url":"page/specs/stdlib_optval.html"},{"title":"quadrature – LightConvex","text":"Numerical integration Numerical integration trapz - integrate sampled values using trapezoidal rule Status Description Syntax Arguments Return value Example trapz_weights - trapezoidal rule weights for given abscissas Status Description Syntax Arguments Return value Example simps - integrate sampled values using Simpson's rule Status Description Syntax Arguments Return value Example simps_weights - Simpson's rule weights for given abscissas Status Description Syntax Arguments Return value Example gauss_legendre - Gauss-Legendre quadrature (a.k.a. Gaussian quadrature) nodes and weights Status Description Syntax Arguments Example gauss_legendre_lobatto - Gauss-Legendre-Lobatto quadrature nodes and weights Status Description Syntax Arguments Example trapz - integrate sampled values using trapezoidal rule Status Experimental Description Returns the trapezoidal rule integral of an array y representing discrete samples of a function. The integral is computed assuming either equidistant abscissas with spacing dx or arbitrary abscissas x . Syntax result = stdlib_quadrature (y, x) result = stdlib_quadrature (y, dx) Arguments y : Shall be a rank-one array of type real . x : Shall be a rank-one array of type real having the same kind and size as y . dx : Shall be a scalar of type real having the same kind as y . Return value The result is a scalar of type real having the same kind as y . If the size of y is zero or one, the result is zero. Example trapz_weights - trapezoidal rule weights for given abscissas Status Experimental Description Given an array of abscissas x , computes the array of weights w such that if y represented function values tabulated at x , then sum(w*y) produces a trapezoidal rule approximation to the integral. Syntax result = stdlib_quadrature (x) Arguments x : Shall be a rank-one array of type real . Return value The result is a real array with the same size and kind as x . If the size of x is one, then the sole element of the result is zero. Example simps - integrate sampled values using Simpson's rule Status Experimental Description Returns the Simpson's rule integral of an array y representing discrete samples of a function. The integral is computed assuming either equidistant abscissas with spacing dx or arbitrary abscissas x . Simpson's ordinary (\"1/3\") rule is used for odd-length arrays. For even-length arrays, Simpson's 3/8 rule is also utilized in a way that depends on the value of even . If even is negative (positive), the 3/8 rule is used at the beginning (end) of the array. If even is zero or not present, the result is as if the 3/8 rule were first used at the beginning of the array, then at the end of the array, and these two results were averaged. Syntax result = stdlib_quadrature (y, x [, even]) result = stdlib_quadrature (y, dx [, even]) Arguments y : Shall be a rank-one array of type real . x : Shall be a rank-one array of type real having the same kind and size as y . dx : Shall be a scalar of type real having the same kind as y . even : (Optional) Shall be a default-kind integer . Return value The result is a scalar of type real having the same kind as y . If the size of y is zero or one, the result is zero. If the size of y is two, the result is the same as if trapz had been called instead. Example simps_weights - Simpson's rule weights for given abscissas Status Experimental Description Given an array of abscissas x , computes the array of weights w such that if y represented function values tabulated at x , then sum(w*y) produces a Simpson's rule approximation to the integral. Simpson's ordinary (\"1/3\") rule is used for odd-length arrays. For even-length arrays, Simpson's 3/8 rule is also utilized in a way that depends on the value of even . If even is negative (positive), the 3/8 rule is used at the beginning (end) of the array and the 1/3 rule used elsewhere. If even is zero or not present, the result is as if the 3/8 rule were first used at the beginning of the array, then at the end of the array, and then these two results were averaged. Syntax result = stdlib_quadrature (x [, even]) Arguments x : Shall be a rank-one array of type real . even : (Optional) Shall be a default-kind integer . Return value The result is a real array with the same size and kind as x . If the size of x is one, then the sole element of the result is zero. If the size of x is two, then the result is the same as if trapz_weights had been called instead. Example gauss_legendre - Gauss-Legendre quadrature (a.k.a. Gaussian quadrature) nodes and weights Status Experimental Description Computes Gauss-Legendre quadrature (also known as simply Gaussian quadrature) nodes and weights,\n for any N (number of nodes).\nUsing the nodes x and weights w , you can compute the integral of some function f as follows: integral = sum(f(x) * w) . Only double precision is supported - if lower precision is required, you must do the appropriate conversion yourself.\nAccuracy has been validated up to N=64 by comparing computed results to tablulated values known to be accurate to machine precision\n(maximum difference from those values is 2 epsilon). Syntax subroutine stdlib_quadrature (x, w[, interval]) Arguments x : Shall be a rank-one array of type real(real64) . It is an output argument, representing the quadrature nodes. w : Shall be a rank-one array of type real(real64) , with the same dimension as x . \nIt is an output argument, representing the quadrature weights. interval : (Optional) Shall be a two-element array of type real(real64) . \nIf present, the nodes and weigts are calculated for integration from interval(1) to interval(2) .\nIf not specified, the default integral is -1 to 1. Example gauss_legendre_lobatto - Gauss-Legendre-Lobatto quadrature nodes and weights Status Experimental Description Computes Gauss-Legendre-Lobatto quadrature nodes and weights,\n for any N (number of nodes).\nUsing the nodes x and weights w , you can compute the integral of some function f as follows: integral = sum(f(x) * w) . Only double precision is supported - if lower precision is required, you must do the appropriate conversion yourself.\nAccuracy has been validated up to N=64 by comparing computed results to tablulated values known to be accurate to machine precision\n(maximum difference from those values is 2 epsilon). Syntax subroutine stdlib_quadrature (x, w[, interval]) Arguments x : Shall be a rank-one array of type real(real64) . It is an output argument, representing the quadrature nodes. w : Shall be a rank-one array of type real(real64) , with the same dimension as x . \nIt is an output argument, representing the quadrature weights. interval : (Optional) Shall be a two-element array of type real(real64) . \nIf present, the nodes and weigts are calculated for integration from interval(1) to interval(2) .\nIf not specified, the default integral is -1 to 1. Example","tags":"","url":"page/specs/stdlib_quadrature.html"},{"title":"random – LightConvex","text":"Statistical Distributions -- Pseudorandom Number Generator Module Statistical Distributions -- Pseudorandom Number Generator Module random_seed - set or get a value of seed to the probability distribution pseudorandom number generator Status Description Syntax Arguments Return value Example dist_rand - Get a random integer with specified kind Status Description Syntax Arguments Return value Example random_seed - set or get a value of seed to the probability distribution pseudorandom number generator Status Experimental Description Set or get the seed value before calling the probability distribution pseudorandom number generator for variates. Syntax call stdlib_random (put, get) Arguments put : argument has intent(in) and may be a scalar of type integer . get : argument has intent(out) and is a scalar of type integer . Return value Return a scalar of type integer . Example dist_rand - Get a random integer with specified kind Status Experimental Description Generate an integer pseudorandom number in a specific range [-2&#94;k, 2&#94;k - 1] according to the input integer kind n. This pseudorandom number will be operated by bit opeartors instead of normal arithmetic operators. Syntax result = stdlib_random (n) Arguments n : argument has intent(in) is a scalar of type integer . Return value Return a scalar of type integer . Example","tags":"","url":"page/specs/stdlib_random.html"},{"title":"selection – LightConvex","text":"The stdlib_selection module The stdlib_selection module Overview of selection Overview of the module select - find the k-th smallest value in an input array Status Description Syntax Class Arguments Notes Example arg_select - find the index of the k-th smallest value in an input array Status Description Syntax Class Arguments Notes Example Comparison with using sort Overview of selection Suppose you wish to find the value of the k-th smallest entry in an array of size N, or\nthe index of that value. While it could be done by sorting the whole array\nusing stdlib_sorting or stdlib_sorting from stdlib_sorting and then finding the k-th entry, that would\nrequire O(N x LOG(N)) time. However selection of a single entry can be done in\nO(N) time, which is much faster for large arrays.  This is useful, for example,\nto quickly find the median of an array, or some other percentile. The Fortran Standard Library therefore provides a module, stdlib_selection ,\nwhich implements selection algorithms. Overview of the module The module stdlib_selection defines two generic subroutines: select is used to find the k-th smallest entry of an array. The input\narray is also modified in-place, and on return will be partially sorted\nsuch that all(array(1:k) <= array(k))) and all(array(k) <= array((k+1):size(array))) is true.\nThe user can optionally specify left and right indices to constrain the search\nfor the k-th smallest value. This can be useful if you have previously called select to find a smaller or larger rank (that will have led to partial sorting of array , thus implying some constraints on the location). arg_select is used to find the index of the k-th smallest entry of an array.\nIn this case the input array is not modified, but the user must provide an\ninput index array with the same size as array , having indices that are a permutation of 1:size(array) , which is modified instead. On return the index array is modified\nsuch that all(array(index(1:k)) <= array(index(k))) and all(array(k) <= array(k+1:size(array))) .\nThe user can optionally specify left and right indices to constrain the search\nfor the k-th smallest value. This can be useful if you have previously called arg_select to find a smaller or larger rank (that will have led to partial sorting of index , thus implying some constraints on the location). select - find the k-th smallest value in an input array Status Experimental Description Returns the k-th smallest value of array(:) , and also partially sorts array(:) such that all(array(1:k) <= array(k)) and all(array(k) <= array((k+1):size(array))) Syntax call stdlib_selection ( array, k, kth_smallest [, left, right ] ) Class Generic subroutine. Arguments array : shall be a rank one array of any of the types: integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(sp) , real(dp) , real(xdp) , real(qp) . It is an intent(inout) argument. k : shall be a scalar with any of the types: integer(int8) , integer(int16) , integer(int32) , integer(int64) . It\nis an intent(in) argument. We search for the k -th smallest entry of array(:) . kth_smallest : shall be a scalar with the same type as array . It is an intent(out) argument. On return it contains the k-th smallest entry of array(:) . left (optional): shall be a scalar with the same type as k . It is an intent(in) argument. If specified then we assume the k-th smallest value is\ndefinitely contained in array(left:size(array)) . If left is not present,\nthe default is 1. This is typically useful if multiple calls to select are\nmade, because the partial sorting of array implies constraints on where we\nneed to search. right (optional): shall be a scalar with the same type as k . It is an intent(in) argument. If specified then we assume the k-th smallest value is\ndefinitely contained in array(1:right) . If right is not present, the\ndefault is size(array) . This is typically useful if multiple calls to select are made, because the partial sorting of array implies constraints\non where we need to search. Notes Selection of a single value should have runtime of O( size(array) ), so it is\nasymptotically faster than sorting array entirely. The test program at the\nend of this document shows that is the case. The code does not support NaN elements in array ; it will run, but there is\nno consistent interpretation given to the order of NaN entries of array compared to other entries. select was derived from code in the Coretran library by Leon Foks,\nhttps://github.com/leonfoks/coretran. Leon Foks has given permission for the\ncode here to be released under stdlib's MIT license. Example arg_select - find the index of the k-th smallest value in an input array Status Experimental Description Returns the index of the k-th smallest value of array(:) , and also partially sorts\nthe index-array indx(:) such that all(array(indx(1:k)) <= array(indx(k))) and all(array(indx(k)) <= array(indx((k+1):size(array)))) Syntax call stdlib_selection ( array, indx, k, kth_smallest [, left, right ] ) Class Generic subroutine. Arguments array : shall be a rank one array of any of the types: integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(sp) , real(dp) , real(xdp) , real(qp) . It is an intent(in) argument. On input it is\nthe array in which we search for the k-th smallest entry. indx : shall be a rank one array with the same size as array , containing all integers\nfrom 1:size(array) in any order. It is of any of the types: integer(int8) , integer(int16) , integer(int32) , integer(int64) . It is an intent(inout) argument. On return its elements will define a partial sorting of array(:) such that: all( array(indx(1:k-1)) <= array(indx(k)) ) and all(array(indx(k)) <= array(indx(k+1:size(array)))) . k : shall be a scalar with the same type as indx . It is an intent(in) argument. We search for the k -th smallest entry of array(:) . kth_smallest : a scalar with the same type as indx . It is an intent(out) argument,\nand on return it contains the index of the k-th smallest entry of array(:) . left (optional): shall be a scalar with the same type as k . It is an intent(in) argument. If specified then we assume the k-th smallest value is definitely contained\nin array(indx(left:size(array))) . If left is not present, the default is 1.\nThis is typically useful if multiple calls to arg_select are made, because\nthe partial sorting of indx implies constraints on where we need to search. right (optional): shall be a scalar with the same type as k . It is an intent(in) argument. If specified then we assume the k-th smallest value is definitely contained\nin array(indx(1:right)) . If right is not present, the default is size(array) . This is typically useful if multiple calls to arg_select are\nmade, because the reordering of indx implies constraints on where we need to\nsearch. Notes arg_select does not modify array , unlike select . The partial sorting of indx is not stable, i.e., indices that map to equal\nvalues of array may be reordered. The code does not support NaN elements in array ; it will run, but there is\nno consistent interpretation given to the order of NaN entries of array compared to other entries. While it is essential that indx contains a permutation of the integers 1:size(array) , \nthe code does not check for this. For example if size(array) == 4 , then we could have indx = [4, 2, 1, 3] or indx = [1, 2, 3, 4] , but not indx = [2, 1, 2, 4] . It is the user's\nresponsibility to avoid such errors. Selection of a single value should have runtime of O( size(array) ), so it is\nasymptotically faster than sorting array entirely. The test program at the end of\nthese documents confirms that is the case. arg_select was derived using code from the Coretran library by Leon Foks,\nhttps://github.com/leonfoks/coretran. Leon Foks has given permission for the\ncode here to be released under stdlib's MIT license. Example Comparison with using sort The following program compares the timings of select and arg_select for\ncomputing the median of an array, vs using sort from stdlib .  In theory we\nshould see a speed improvement with the selection routines which grows like\nLOG(size( array )). The results seem consistent with expectations when the array is large; the program prints: select ; N = 1 ; PASS ; Relative-speedup-vs-sort : 1 . 90928173 arg_select ; N = 1 ; PASS ; Relative-speedup-vs-sort : 1 . 76875830 select ; N = 11 ; PASS ; Relative-speedup-vs-sort : 1 . 14835048 arg_select ; N = 11 ; PASS ; Relative-speedup-vs-sort : 1 . 00794709 select ; N = 101 ; PASS ; Relative-speedup-vs-sort : 2 . 31012774 arg_select ; N = 101 ; PASS ; Relative-speedup-vs-sort : 1 . 92877376 select ; N = 1001 ; PASS ; Relative-speedup-vs-sort : 4 . 24190664 arg_select ; N = 1001 ; PASS ; Relative-speedup-vs-sort : 3 . 54580402 select ; N = 10001 ; PASS ; Relative-speedup-vs-sort : 5 . 61573362 arg_select ; N = 10001 ; PASS ; Relative-speedup-vs-sort : 4 . 79348087 select ; N = 100001 ; PASS ; Relative-speedup-vs-sort : 7 . 28823519 arg_select ; N = 100001 ; PASS ; Relative-speedup-vs-sort : 6 . 03007460","tags":"","url":"page/specs/stdlib_selection.html"},{"title":"sorting – LightConvex","text":"The stdlib_sorting module The stdlib_sorting module Overview of sorting Overview of the module The parameters int_index and int_index_low The module subroutines Licensing The ORD_SORT subroutine The SORT_INDEX subroutine The SORT subroutine The RADIX_SORT subroutine Specifications of the stdlib_sorting procedures ord_sort - sorts an input array Status Description Syntax Class Arguments Notes Example sort - sorts an input array Status Description Syntax Class Arguments Notes Example radix_sort - sorts an input array Status Description Syntax Class Arguments Notes Example sort_index - creates an array of sorting indices for an input array, while also sorting the array. Status Description Syntax Class Arguments Notes Examples Performance benchmarks Overview of sorting The sorting of collections of data is useful in the analysis of those\ncollections.\nWith its absence of generics and limited polymorphism, it is\nimpractical, in current Fortran, to provide sorting routines for\narbitrary collections of arbitrary types of data.\nHowever Fortran's arrays are by far its most widely used collection,\nand arrays of arbitrary types of data can often be sorted in terms of\na single component of intrinsic type.\nThe Fortran Standard Library therefore provides a module, stdlib_sorting , with procedures to sort arrays of simple intrinsic\nnumeric types, i.e. the different kinds of integers and reals, the\ndefault assumed length character, and the stdlib_string_type module's string_type type. Overview of the module The module stdlib_sorting defines several public entities, two\ndefault integer parameters, int_index and int_index_low , and four overloaded\nsubroutines: ORD_SORT , SORT , RADIX_SORT and SORT_INDEX . The\noverloaded subroutines also each have several specific names for\nversions corresponding to different types of array arguments. The parameters int_index and int_index_low The parameters int_index and int_index_low are used to specify the kind of integer used\nin indexing the various arrays. Currently the module sets int_index and int_index_low to the value of int64 and int32 from the stdlib_kinds module, respectively. The module subroutines The stdlib_sorting module provides three different overloaded\nsubroutines intended to sort three different kinds of arrays of\ndata: ORD_SORT is intended to sort simple arrays of intrinsic data\n  that have significant sections that were partially ordered before\n  the sort; SORT_INDEX is based on ORD_SORT , but in addition to sorting the\n  input array, it returns indices that map the original array to its\n  sorted version. This enables related arrays to be re-ordered in the\n  same way; SORT is intended to sort simple arrays of intrinsic data\n  that are effectively unordered before the sort; RADIX_SORT is intended to sort fixed width intrinsic data \n  types (integers and reals). Licensing The Fortran Standard Library is distributed under the MIT\nLicense. However components of the library may be based on code with\nadditional licensing restrictions. In particular ORD_SORT , SORT_INDEX , and SORT are translations of codes with their\nown distribution restrictions. The ORD_SORT and SORT_INDEX subroutines are essentially\ntranslations to Fortran 2008 of the \"Rust\" sort of the Rust Language\ndistributed as part of slice.rs .\nThe header of the slice.rs file has as its licensing requirements: Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\nfile at the top-level directory of this distribution and at\nhttp://rust-lang.org/COPYRIGHT.\n\nLicensed under the Apache License, Version 2.0 <LICENSE-APACHE or\nhttp://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n<LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\noption. This file may not be copied, modified, or distributed\nexcept according to those terms. So the license for the slice.rs code is compatible with the use of\nmodified versions of the code in the Fortran Standard Library under\nthe MIT license. The SORT subroutine is essentially a translation to Fortran\n2008 of the\n[ introsort ]((http://www.cs.rpi.edu/~musser/gp/introsort.ps) of David\nMusser.  David Musser has given permission to include a variant of introsort in the Fortran Standard Library under the MIT license\nprovided we cite: Musser, D.R., “Introspective Sorting and Selection Algorithms,”\nSoftware—Practice and Experience, Vol. 27(8), 983–993 (August 1997). as the official source of the algorithm. The ORD_SORT subroutine ORD_SORT is a translation of the \"Rust\" sort sorting algorithm\ncontained in [ slice.rs ]\n(https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs). \"Rust\" sort , in turn, is inspired by the [ timsort algorithm]\n(http://svn.python.org/projects/python/trunk/Objects/listsort.txt)\nthat Tim Peters created for the Python Language. ORD_SORT is a hybrid stable comparison algorithm combining merge sort ,\nand insertion sort . It has always at worst O(N Ln(N)) runtime\nperformance in sorting random data, having a performance about 15-25%\nslower than SORT on such data. However it has much better\nperformance than SORT on partially sorted data, having O(N)\nperformance on uniformly increasing or decreasing data. When sorting in an increasing order, ORD_SORT begins by traversing the array\nstarting in its tail attempting to identify runs in the array, where a run is\neither a uniformly decreasing sequence, ARRAY(i-1) > ARRAY(i) , or a\nnon-decreasing, ARRAY(i-1) <= ARRAY(i) , sequence. First delimited decreasing\nsequences are reversed in their order. Then, if the sequence has less than MIN_RUN elements, previous elements in the array are added to the run using insertion sort until the run contains MIN_RUN elements or the array is\ncompletely processed. As each run is identified the start and length of the run\nare then pushed onto a stack and the stack is then processed using merge until\nit obeys the stack invariants: len(i-2) > len(i-1) + len(i) len(i-1) > len(i) ensuring that processing the stack is, at worst, of order O(N\nLn(N)) . However, because of the identification of decreasing and\nnon-decreasing runs, processing of structured data can be much faster,\nwith processing of uniformly decreasing or non-decreasing arrays being\nof order O(N). The result in our tests is that ORD_SORT is about\n25% slower than SORT on purely random data, depending on\nthe compiler, but can be Ln(N) faster than SORT on highly\nstructured data. As a modified merge sort , ORD_SORT requires the\nuse of a \"scratch\" array, that may be provided as an optional work argument or allocated internally on the stack. Arrays can be also sorted in a decreasing order by providing the argument reverse\n= .true. . The SORT_INDEX subroutine The SORT and ORD_SORT subroutines can sort rank 1 isolated\narrays of intrinsic types, but do nothing for the coordinated sorting\nof related data, e.g., multiple related rank 1 arrays, higher rank\narrays, or arrays of derived types. For such related data, what is\nuseful is an array of indices that maps a rank 1 array to its sorted\nform. For such a sort, a stable sort is useful, therefore the module\nprovides a subroutine, SORT_INDEX , that generates such an array of\nindices based on the ORD_SORT algorithm, in addition to sorting\nthe input array. The logic of SORT_INDEX parallels that of ORD_SORT , with\nadditional housekeeping to keep the array of indices consistent with\nthe sorted positions of the input array. Because of this additional\nhousekeeping it has slower runtime performance than ORD_SORT . SORT_INDEX requires the use of two \"scratch\" arrays, that may be\nprovided as optional work and iwork arguments or allocated\ninternally on the stack. The SORT subroutine SORT uses the introsort sorting algorithm of David Musser. introsort is a hybrid unstable comparison algorithm combining quicksort , insertion sort , and heap sort . While this algorithm's\nruntime performance is always O(N Ln(N)), it is relatively fast on\nrandomly ordered data, but does not show the improvement in\nperformance on partly sorted data found for ORD_SORT . First it examines the array and estimates the depth of recursion a\nquick sort would require for ideal (random) data, D =\nCeiling(Ln(N)/Ln(2)) . It then defines a limit to the number of quicksort recursions to be allowed in processing, D_limit = factor * D , where factor is currently 2, and\ncalls introsort proper. introsort proper then: Examines the number of elements remaining to be sorted, and, if\n   they are less than 16, sorts them using insertion sort and returns; If they are not less than 16, checks whether the current depth of\n   recursion exceeds D_limit and, if it does, processes the remaining\n   elements with heap sort and returns; If the current depth of recursion does not exceed D_limit , then\n   in effect does a quicksort step: Partitions the remaining array using a median of three, Calls introsort proper on the leftmost partition, Calls introsort proper on the rightmost partition, and then\n  returns. The resulting algorithm is of order O(N Ln(N)) run time performance\nfor all inputs. Because it relies on quicksort , the coefficient of\nthe O(N Ln(N)) behavior is typically small compared to other sorting\nalgorithms on random data. On partially sorted data it can show either\nslower heap sort performance, or enhanced performance by up to a\nfactor of six. Still, even when it shows enhanced performance, its\nperformance on partially sorted data is typically an order of\nmagnitude slower than ORD_SORT . Its memory requirements are also\nlow, being of order O(Ln(N)), while the memory requirements of ORD_SORT and SORT_INDEX are of order O(N). The RADIX_SORT subroutine RADIX_SORT is a implementation of LSD radix sort ,\nusing 256 as the radix. It only works for fixed width data,\nthus integers and reals. RADIX_SORT is always of O(N) runtime performance\nfor any input data. For large and random data, it is about five (or more)\ntimes faster than other sort subroutines. The RADIX_SORT needs a buffer that have same size of the input data.\nYour can provide it using work argument, if not the subroutine will\nallocate the buffer and deallocate before return. Specifications of the stdlib_sorting procedures ord_sort - sorts an input array Status Experimental Description Returns an input array with the elements sorted in order of\nincreasing, or decreasing, value. Syntax call stdlib_sorting ( array[, work, reverse ] ) Class Generic subroutine. Arguments array : shall be a rank one array of any of the types: integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(sp) , real(dp) , real(qp) , character(*) , type(string_type) , type(bitset_64) , or type(bitset_large) .\nIt is an intent(inout) argument. On input it is\nthe array to be sorted. If both the type of array is real and at\nleast one of the elements is a NaN , then the ordering of the result\nis undefined. Otherwise on return its elements will be sorted in order\nof non-decreasing value. work (optional): shall be a rank one array of the same type as\narray, and shall have at least size(array)/2 elements. It is an intent(out) argument. It is intended to be used as \"scratch\"\nmemory for internal record keeping. If associated with an array in\nstatic storage, its use can significantly reduce the stack memory\nrequirements for the code. Its contents on return are undefined. reverse (optional): shall be a scalar of type default logical. It\nis an intent(in) argument. If present with a value of .true. then array will be sorted in order of non-increasing values in stable\norder. Otherwise index will sort array in order of non-decreasing\nvalues in stable order. Notes ORD_SORT implements a hybrid sorting algorithm combining merge sort , and insertion sort . For most purposes it behaves like\na merge sort , providing worst case O(N Ln(N)) run time performance\nfor most random arrays, that is typically slower than SORT .\nHowever, if the array has significant runs of decreasing or\nnon-decreasing values, performance can be much better than SORT , with O(N) behavior on uniformly decreasing, or\nnon-decreasing arrays. The optional work array replaces \"scratch\"\nmemory that would otherwise be allocated on the stack. If array is of\nany type REAL the order of its elements on return undefined if any\nelement of array is a NaN .  Sorting of CHARACTER(*) and STRING_TYPE arrays are based on the operators > and < , and not on the\nfunction LGT . Example sort - sorts an input array Status Experimental Description Returns an input array with the elements sorted in order of increasing, or\ndecreasing, value. Syntax call stdlib_sorting ( array[, reverse] ) Class Pure generic subroutine. Arguments array : shall be a rank one array of any of the types: integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(sp) , real(dp) , real(qp) . character(*) , type(string_type) , type(bitset_64) , or type(bitset_large) .\nIt is an intent(inout) argument. On return its\ninput elements will be sorted in order of non-decreasing value. reverse (optional): shall be a scalar of type default logical. It\nis an intent(in) argument. If present with a value of .true. then array will be sorted in order of non-increasing values in unstable\norder. Otherwise index will sort array in order of non-decreasing\nvalues in unstable order. Notes SORT implements a hybrid sorting algorithm combining quicksort , merge sort , and insertion sort . For most purposes it\nbehaves like a quicksort with a median of three partition, providing\ngood, O(N Ln(N)) , run time performance for most random arrays, but\ndefaulting to merge sort if the structure of the array results in\nthe quicksort not converging as rapidly as expected. If array is of\nany type REAL , the behavior of the sorting is undefined if any\nelement of array is a NaN .  Sorting of CHARACTER(*) and STRING_TYPE arrays are based on the operators < , <= , > , and >= , and not on the functions LLT , LLE , LGT , or LGE . Example radix_sort - sorts an input array Status Experimental Description Returns an input array with the elements sorted in order of increasing, or\ndecreasing, value. Syntax call stdlib_sorting ( array[, work, reverse] ) Class Generic subroutine. Arguments array : shall be a rank one array of any of the types: integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(sp) , real(dp) . It is an intent(inout) argument. On return its\ninput elements will be sorted in order of non-decreasing value. work (optional): shall be a rank one array of the same type as\narray, and shall have at least size(array) elements. It is an intent(inout) argument, and its contents on return are undefined. reverse (optional): shall be a scalar of type default logical . It\nis an intent(in) argument. If present with a value of .true. then array will be sorted in order of non-increasing values in unstable\norder. Otherwise index will sort array in order of non-decreasing\nvalues in unstable order. Notes radix_sort implements a LSD radix sort algorithm with a 256 radix. For any\ninput data it provides O(N) run time performance. If array is of\nany type real the order of its elements on return undefined if any\nelement of array is a NaN . Example sort_index - creates an array of sorting indices for an input array, while also sorting the array. Status Experimental Description Returns the input array sorted in the direction requested while\nretaining order stability, and an integer array whose elements would\nsort the input array to produce the output array . Syntax call stdlib_sorting ( array, index[, work, iwork, reverse ] ) Class Generic subroutine. Arguments array : shall be a rank one array of any of the types: integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(sp) , real(dp) , real(qp) , character(*) , type(string_type) , type(bitset_64) , or type(bitset_large) .\nIt is an intent(inout) argument. On input it\nwill be an array whose sorting indices are to be determined. On return\nit will be the sorted array. index : shall be a rank one integer array of kind int_index or int_index_low and of\nthe size of array . It is an intent(out) argument. On return it\nshall have values that are the indices needed to sort the original\narray in the desired direction. work (optional): shall be a rank one array of any of the same type as array , and shall have at least size(array)/2 elements. It is an intent(out) argument. It is intended to be used as \"scratch\"\nmemory for internal record keeping. If associated with an array in\nstatic storage, its use can significantly reduce the stack memory\nrequirements for the code. Its contents on return are undefined. iwork (optional): shall be a rank one integer array of the same kind\nof the array index , and shall have at least size(array)/2 elements. It\nis an intent(out) argument.  It is intended to be used as \"scratch\"\nmemory for internal record keeping. If associated with an array in\nstatic storage, its use can significantly reduce the stack memory\nrequirements for the code. Its contents on return are undefined. reverse (optional): shall be a scalar of type default logical. It\nis an intent(in) argument. If present with a value of .true. then index will sort array in order of non-increasing values in stable\norder. Otherwise index will sort array in order of non-decreasing\nvalues in stable order. Notes SORT_INDEX implements the hybrid sorting algorithm of ORD_SORT ,\nkeeping the values of index consistent with the elements of array as it is sorted. As a merge sort based algorithm, it is a stable\nsorting comparison algorithm. The optional work and iwork arrays\nreplace \"scratch\" memory that would otherwise be allocated on the\nstack. If array is of any kind of REAL the order of the elements in index and array on return are undefined if any element of array is a NaN . Sorting of CHARACTER(*) and STRING_TYPE arrays are\nbased on the operator > , and not on the function LGT . It should be emphasized that the order of array will typically be\ndifferent on return Examples Sorting a rank one array with sort_index : Sorting a related rank one array: subroutine sort_related_data ( a , b , work , index , iwork ) ! Sort `a`, and  also  sort `b` to be reorderd the same way as `a` integer , intent ( inout ) :: a (:) integer ( int32 ), intent ( inout ) :: b (:) ! The same size as a integer ( int32 ), intent ( out ) :: work (:) integer ( int_index ), intent ( out ) :: index (:) integer ( int_index ), intent ( out ) :: iwork (:) ! Find the indices to sort a call sort_index ( a , index ( 1 : size ( a )),& work ( 1 : size ( a ) / 2 ), iwork ( 1 : size ( a ) / 2 )) ! Sort b based on the sorting of a b (:) = b ( index ( 1 : size ( a )) ) end subroutine sort_related_data Sorting a rank 2 array based on the data in a column subroutine sort_related_data ( array , column , work , index , iwork ) ! Reorder rows of `array` such that `array(:, column)` is  sorted integer , intent ( inout ) :: array (:,:) integer ( int32 ), intent ( in ) :: column integer ( int32 ), intent ( out ) :: work (:) integer ( int_index ), intent ( out ) :: index (:) integer ( int_index ), intent ( out ) :: iwork (:) integer , allocatable :: dummy (:) integer :: i allocate ( dummy ( size ( array , dim = 1 ))) ! Extract a column of `array` dummy (:) = array (:, column ) ! Find the indices to sort the column call sort_index ( dummy , index ( 1 : size ( dummy )),& work ( 1 : size ( dummy ) / 2 ), iwork ( 1 : size ( dummy ) / 2 )) ! Sort a based on the sorting of its column do i = 1 , size ( array , dim = 2 ) array (:, i ) = array ( index ( 1 : size ( array , dim = 1 )), i ) end do end subroutine sort_related_data Sorting an array of a derived type based on the data in one component subroutine sort_a_data ( a_data , a , work , index , iwork ) ! Sort `a_data` in terms of its component `a` type ( a_type ), intent ( inout ) :: a_data (:) integer ( int32 ), intent ( inout ) :: a (:) integer ( int32 ), intent ( out ) :: work (:) integer ( int_index ), intent ( out ) :: index (:) integer ( int_index ), intent ( out ) :: iwork (:) ! Extract a component of `a_data` a ( 1 : size ( a_data )) = a_data (:) % a ! Find the indices to sort the component call sort_index ( a ( 1 : size ( a_data )), index ( 1 : size ( a_data )),& work ( 1 : size ( a_data ) / 2 ), iwork ( 1 : size ( a_data ) / 2 )) ! Sort a_data based on the sorting of that component a_data (:) = a_data ( index ( 1 : size ( a_data )) ) end subroutine sort_a_data Performance benchmarks We have performed benchmarks of the procedures on nine different\ninteger arrays each of size 2**16 : Blocks - the array is divided into six blocks, each of distinct\n  uniformly increasing integers. Decreasing - values decrease uniformly from 2**16-1 to 0 . Identical - all integers have the same value of 10. Increasing - values increase uniformly from 0 to 2**16-1 . Random dense - the integers are generated randomly from a set of\n  values from 0 to 2**14-1 so duplicates are dense. Random order - a set of integers from 0 to 2**16 - 1 in random\n  order. Random sparse - the integers are generated randomly from a set of\n  values from 0 to 2**18-1 so duplicates are sparse. Random-3 - the increasing array has 3 random exchanges of individual\n  elements. Random-10 - the final ten elements of the increasing array are\n  replaced by random values. On three different default character arrays, each of length 4 and of\nsize `20**4, with characters drawn from the set \"a\"-\"p\": Char. Decreasing - values decrease uniformly from \"pppp\" to \"aaaa\" . Char. Increasing - values decrease uniformly from \"aaaa\" to \"pppp\" . Char. Random - the set of strings from \"aaaa\" to \"pppp\" in\n  random order. On three different string_type arrays, each of length 4 elements and\nof size 16**3 , with characters drawn from the set \"a\"-\"p\": String Decreasing - values decrease uniformly from \"ppp\" to \"aaa\" . String Increasing - values decrease uniformly from \"aaa\" to \"ppp\" . String Random - the set of strings from \"aaa\" to \"ppp\" in\n  random order. These benchmarks have been performed on two different compilers, both\non WSL with Ubuntu-20.04, Intel(R) Core(TM) i7-10700 CPU @ 2.9GHz, with\n32 GB DDR4 memory. The first compiler is GNU Fortran (GCC) 9.4.0, with\nthe following results. Type Elements Array Name Method Time (s) Integer 65536 Blocks Ord_Sort 0.001048 Integer 65536 Decreasing Ord_Sort 0.000204 Integer 65536 Identical Ord_Sort 0.000097 Integer 65536 Increasing Ord_Sort 0.000096 Integer 65536 Random dense Ord_Sort 0.006580 Integer 65536 Random order Ord_Sort 0.006886 Integer 65536 Random sparse Ord_Sort 0.006821 Integer 65536 Random 3 Ord_Sort 0.000461 Integer 65536 Random 10 Ord_Sort 0.000226 Character 65536 Char. Decrease Ord_Sort 0.000824 Character 65536 Char. Increase Ord_Sort 0.000370 Character 65536 Char. Random Ord_Sort 0.016020 String_type 4096 String Decrease Ord_Sort 0.000465 String_type 4096 String Increase Ord_Sort 0.000169 String_type 4096 String Random Ord_Sort 0.004194 Integer 65536 Blocks Radix_Sort 0.001610 Integer 65536 Decreasing Radix_Sort 0.001076 Integer 65536 Identical Radix_Sort 0.001074 Integer 65536 Increasing Radix_Sort 0.001060 Integer 65536 Random dense Radix_Sort 0.001161 Integer 65536 Random order Radix_Sort 0.001069 Integer 65536 Random sparse Radix_Sort 0.001005 Integer 65536 Random 3 Radix_Sort 0.001057 Integer 65536 Random 10 Radix_Sort 0.001046 Integer 65536 rand-real32 Radix_Sort 0.001429 Integer 65536 Blocks Sort 0.004269 Integer 65536 Decreasing Sort 0.005108 Integer 65536 Identical Sort 0.006257 Integer 65536 Increasing Sort 0.002093 Integer 65536 Random dense Sort 0.006032 Integer 65536 Random order Sort 0.006030 Integer 65536 Random sparse Sort 0.006126 Integer 65536 Random 3 Sort 0.007930 Integer 65536 Random 10 Sort 0.014729 Character 65536 Char. Decrease Sort 0.020623 Character 65536 Char. Increase Sort 0.008028 Character 65536 Char. Random Sort 0.014258 String_type 4096 String Decrease Sort 0.005542 String_type 4096 String Increase Sort 0.001987 String_type 4096 String Random Sort 0.003267 Integer 65536 Blocks Sort_Index 0.000686 Integer 65536 Decreasing Sort_Index 0.000529 Integer 65536 Identical Sort_Index 0.000218 Integer 65536 Increasing Sort_Index 0.000214 Integer 65536 Random dense Sort_Index 0.008044 Integer 65536 Random order Sort_Index 0.008042 Integer 65536 Random sparse Sort_Index 0.008148 Integer 65536 Random 3 Sort_Index 0.000677 Integer 65536 Random 10 Sort_Index 0.000387 Character 65536 Char. Decrease Sort_Index 0.000932 Character 65536 Char. Increase Sort_Index 0.000487 Character 65536 Char. Random Sort_Index 0.017231 String_type 4096 String Decrease Sort_Index 0.000489 String_type 4096 String Increase Sort_Index 0.000183 String_type 4096 String Random Sort_Index 0.004102 The second compiler is Intel(R) Fortran Intel(R) 64 Compiler Classic\nfor applications running on Intel(R) 64, Version 2021.7.0 Build\n20220726_000000, with the following results: Type Elements Array Name Method Time (s) Integer 65536 Blocks Ord_Sort 0.000135 Integer 65536 Decreasing Ord_Sort 0.000053 Integer 65536 Identical Ord_Sort 0.000033 Integer 65536 Increasing Ord_Sort 0.000034 Integer 65536 Random dense Ord_Sort 0.003291 Integer 65536 Random order Ord_Sort 0.003546 Integer 65536 Random sparse Ord_Sort 0.003313 Integer 65536 Random 3 Ord_Sort 0.000145 Integer 65536 Random 10 Ord_Sort 0.000070 Character 65536 Char. Decrease Ord_Sort 0.000696 Character 65536 Char. Increase Ord_Sort 0.000338 Character 65536 Char. Random Ord_Sort 0.015255 String_type 4096 String Decrease Ord_Sort 0.001276 String_type 4096 String Increase Ord_Sort 0.000153 String_type 4096 String Random Ord_Sort 0.024705 Integer 65536 Blocks Radix_Sort 0.001038 Integer 65536 Decreasing Radix_Sort 0.000910 Integer 65536 Identical Radix_Sort 0.000441 Integer 65536 Increasing Radix_Sort 0.000803 Integer 65536 Random dense Radix_Sort 0.000363 Integer 65536 Random order Radix_Sort 0.000741 Integer 65536 Random sparse Radix_Sort 0.000384 Integer 65536 Random 3 Radix_Sort 0.000877 Integer 65536 Random 10 Radix_Sort 0.000801 Integer 65536 rand-real32 Radix_Sort 0.000604 Integer 65536 Blocks Sort 0.001342 Integer 65536 Decreasing Sort 0.001391 Integer 65536 Identical Sort 0.001485 Integer 65536 Increasing Sort 0.000447 Integer 65536 Random dense Sort 0.002778 Integer 65536 Random order Sort 0.002896 Integer 65536 Random sparse Sort 0.003136 Integer 65536 Random 3 Sort 0.002996 Integer 65536 Random 10 Sort 0.005752 Character 65536 Char. Decrease Sort 0.021973 Character 65536 Char. Increase Sort 0.008391 Character 65536 Char. Random Sort 0.015155 String_type 4096 String Decrease Sort 0.034014 String_type 4096 String Increase Sort 0.010464 String_type 4096 String Random Sort 0.015748 Integer 65536 Blocks Sort_Index 0.000381 Integer 65536 Decreasing Sort_Index 0.000085 Integer 65536 Identical Sort_Index 0.000046 Integer 65536 Increasing Sort_Index 0.000046 Integer 65536 Random dense Sort_Index 0.004020 Integer 65536 Random order Sort_Index 0.004059 Integer 65536 Random sparse Sort_Index 0.004073 Integer 65536 Random 3 Sort_Index 0.000215 Integer 65536 Random 10 Sort_Index 0.000101 Character 65536 Char. Decrease Sort_Index 0.000680 Character 65536 Char. Increase Sort_Index 0.000356 Character 65536 Char. Random Sort_Index 0.016231 String_type 4096 String Decrease Sort_Index 0.001219 String_type 4096 String Increase Sort_Index 0.000125 String_type 4096 String Random Sort_Index 0.018631","tags":"","url":"page/specs/stdlib_sorting.html"},{"title":"sparse – LightConvex","text":"The stdlib_sparse module The stdlib_sparse module Introduction Sparse matrix derived types The sparse_type abstract derived type Status Description COO: The COOrdinates compressed sparse format Status Description CSR: The Compressed Sparse Row or Yale format Status Description CSC: The Compressed Sparse Column format Status Description ELLPACK: ELL-pack storage format Status Description SELL-C: The Sliced ELLPACK with Constant blocks format Status Description add- sparse matrix data accessors Status Description Syntax Arguments at- sparse matrix data accessors Status Description Syntax Arguments Example spmv - Sparse Matrix-Vector product Status Description Syntax Arguments Sparse matrix to matrix conversions Status Description Syntax Arguments Syntax Arguments Example Syntax Arguments Note Syntax Arguments Syntax Arguments Syntax Arguments Syntax Arguments Syntax Arguments Syntax Arguments Syntax Arguments Syntax Arguments Example Introduction The stdlib_sparse module provides derived types for standard sparse matrix data structures. It also provides math kernels such as sparse matrix-vector product and conversion between matrix types. Sparse matrix derived types The sparse_type abstract derived type Status Experimental Description The parent sparse_type is as an abstract derived type holding the basic common meta data needed to define a sparse matrix, as well as shared APIs. All sparse matrix flavors are extended from the sparse_type . type , public , abstract :: sparse_type integer :: nrows !! number of rows integer :: ncols !! number of columns integer :: nnz !! number of non-zero values integer :: storage !! assumed storage symmetry end type The storage integer label should be assigned from the module's internal enumerator containing the following three enums: enum , bind ( C ) enumerator :: sparse_full !! Full Sparse matrix (no symmetry considerations) enumerator :: sparse_lower !! Symmetric Sparse matrix with triangular inferior storage enumerator :: sparse_upper !! Symmetric Sparse matrix with triangular supperior storage end enum In the following, all sparse kinds will be presented in two main flavors: a data-less type <matrix>_type useful for topological graph operations. And real/complex valued types <matrix>_<kind>_type containing the data buffer for the matrix values. The following rectangular matrix will be used to showcase how each sparse matrix holds the data internally: COO : The COOrdinates compressed sparse format Status Experimental Description The COO , triplet or ijv format defines all non-zero elements of the matrix by explicitly allocating the i,j index and the value of the matrix. While some implementations use separate row and col arrays for the index, here we use a 2D array in order to promote fast memory acces to ij . type ( COO_sp_type ) :: COO call COO % malloc ( 4 , 5 , 10 ) COO % data (:) = real ([ 9 , - 3 , 4 , 7 , 8 , - 1 , 8 , 4 , 5 , 6 ]) COO % index ( 1 : 2 , 1 ) = [ 1 , 1 ] COO % index ( 1 : 2 , 2 ) = [ 1 , 5 ] COO % index ( 1 : 2 , 3 ) = [ 2 , 1 ] COO % index ( 1 : 2 , 4 ) = [ 2 , 2 ] COO % index ( 1 : 2 , 5 ) = [ 3 , 2 ] COO % index ( 1 : 2 , 6 ) = [ 3 , 3 ] COO % index ( 1 : 2 , 7 ) = [ 3 , 4 ] COO % index ( 1 : 2 , 8 ) = [ 4 , 1 ] COO % index ( 1 : 2 , 9 ) = [ 4 , 3 ] COO % index ( 1 : 2 , 10 ) = [ 4 , 4 ] CSR : The Compressed Sparse Row or Yale format Status Experimental Description The Compressed Sparse Row or Yale format CSR stores the matrix structure by compressing the row indices with a counter pointer rowptr enabling to know the first and last non-zero column index col of the given row. type ( CSR_sp_type ) :: CSR call CSR % malloc ( 4 , 5 , 10 ) CSR % data (:) = real ([ 9 , - 3 , 4 , 7 , 8 , - 1 , 8 , 4 , 5 , 6 ]) CSR % col (:) = [ 1 , 5 , 1 , 2 , 2 , 3 , 4 , 1 , 3 , 4 ] CSR % rowptr (:) = [ 1 , 3 , 5 , 8 , 11 ] CSC : The Compressed Sparse Column format Status Experimental Description The Compressed Sparse Colum CSC is similar to the CSR format but values are accesed first by column, thus an index counter is given by colptr which enables to know the first and last non-zero row index of a given colum. type ( CSC_sp_type ) :: CSC call CSC % malloc ( 4 , 5 , 10 ) CSC % data (:) = real ([ 9 , 4 , 4 , 7 , 8 , - 1 , 5 , 8 , 6 , - 3 ]) CSC % row (:) = [ 1 , 2 , 4 , 2 , 3 , 3 , 4 , 3 , 4 , 1 ] CSC % colptr (:) = [ 1 , 4 , 6 , 8 , 10 , 11 ] ELLPACK : ELL-pack storage format Status Experimental Description The ELL format stores data in a dense matrix of $nrows \\times K$ in column major order. By imposing a constant number of elements per row $K$, this format will incur in additional zeros being stored, but it enables efficient vectorization as memory acces is carried out by constant sized strides. type ( ELL_sp_type ) :: ELL call ELL % malloc ( num_rows = 4 , num_cols = 5 , num_nz_row = 3 ) ELL % data ( 1 , 1 : 3 ) = real ([ 9 , - 3 , 0 ]) ELL % data ( 2 , 1 : 3 ) = real ([ 4 , 7 , 0 ]) ELL % data ( 3 , 1 : 3 ) = real ([ 8 , - 1 , 8 ]) ELL % data ( 4 , 1 : 3 ) = real ([ 4 , 5 , 6 ]) ELL % index ( 1 , 1 : 3 ) = [ 1 , 5 , 0 ] ELL % index ( 2 , 1 : 3 ) = [ 1 , 2 , 0 ] ELL % index ( 3 , 1 : 3 ) = [ 2 , 3 , 4 ] ELL % index ( 4 , 1 : 3 ) = [ 1 , 3 , 4 ] SELL-C : The Sliced ELLPACK with Constant blocks format Status Experimental Description The Sliced ELLPACK format SELLC is a variation of the ELLPACK format. This modification reduces the storage size compared to the ELLPACK format but maintaining its efficient data access scheme. It can be seen as an intermediate format between CSR and ELLPACK . For more details read the reference add - sparse matrix data accessors Status Experimental Description Type-bound procedures to enable adding data in a sparse matrix. Syntax call matrix%add(i,j,v) or call matrix%add(i(:),j(:),v(:,:)) Arguments i : Shall be an integer value or rank-1 array. It is an intent(in) argument. j : Shall be an integer value or rank-1 array. It is an intent(in) argument. v : Shall be a real or complex value or rank-2 array. The type shall be in accordance to the declared sparse matrix object. It is an intent(in) argument. at - sparse matrix data accessors Status Experimental Description Type-bound procedures to enable requesting data from a sparse matrix. Syntax v = matrix%at(i,j) Arguments i : Shall be an integer value. It is an intent(in) argument. j : Shall be an integer value. It is an intent(in) argument. v : Shall be a real or complex value in accordance to the declared sparse matrix object. If the ij tuple is within the sparse pattern, v contains the value in the data buffer. If the ij tuple is outside the sparse pattern, v is equal 0 . If the ij tuple is outside the matrix pattern (nrows,ncols) , v is NaN . Example spmv - Sparse Matrix-Vector product Status Experimental Description Provide sparse matrix-vector product kernels for the current supported sparse matrix types. Syntax call stdlib_sparse_spmv (matrix,vec_x,vec_y [,alpha,beta,op]) Arguments matrix : Shall be a real or complex sparse type matrix. It is an intent(in) argument. vec_x : Shall be a rank-1 or rank-2 array of real or complex type array. It is an intent(in) argument. vec_y : Shall be a rank-1 or rank-2 array of real or complex type array. . It is an intent(inout) argument. alpha , optional : Shall be a scalar value of the same type as vec_x . Default value alpha=1 . It is an intent(in) argument. beta , optional : Shall be a scalar value of the same type as vec_x . Default value beta=0 . It is an intent(in) argument. op , optional : In-place operator identifier. Shall be a character(1) argument. It can have any of the following values: N : no transpose, T : transpose, H : hermitian or complex transpose. These values are provided as constants by the stdlib_sparse module: sparse_op_none , sparse_op_transpose , sparse_op_hermitian Sparse matrix to matrix conversions Status Experimental Description This module provides facility functions for converting between storage formats. Syntax call stdlib_sparse_conversion (coo[,sort_data]) Arguments COO : Shall be any COO type. The same object will be returned with the arrays reallocated to the correct size after removing duplicates. It is an intent(inout) argument. sort_data , optional : Shall be a logical argument to determine whether data in the COO graph should be sorted while sorting the index array, default .false. . It is an intent(in) argument. Syntax call stdlib_sparse_conversion (sparse,row,col[,data,nrows,ncols,num_nz_rows,chunk]) Arguments sparse : Shall be a COO , CSR , ELL or SELLC type. The graph object will be returned with a canonical shape after sorting and removing duplicates from the (row,col,data) triplet. If the graph is COO_type no data buffer is allowed. It is an intent(inout) argument. row : rows index array. It is an intent(in) argument. col : columns index array. It is an intent(in) argument. data , optional : real or complex data array. It is an intent(in) argument. nrows , optional : number of rows, if not given it will be computed from the row array. It is an intent(in) argument. ncols , optional : number of columns, if not given it will be computed from the col array. It is an intent(in) argument. num_nz_rows , optional : number of non zeros per row, only valid in the case of an ELL matrix, by default it will computed from the largest row. It is an intent(in) argument. chunk , optional : chunk size, only valid in the case of a SELLC matrix, by default it will be taken from the SELLC default attribute chunk size. It is an intent(in) argument. Example Syntax call stdlib_sparse_conversion (matrix,diagonal) Arguments matrix : Shall be a dense , COO , CSR or ELL type. It is an intent(in) argument. diagonal : A rank-1 array of the same type as the matrix . It is an intent(inout) and allocatable argument. Note If the diagonal array has not been previously allocated, the diag subroutine will allocate it using the nrows of the matrix . Syntax call stdlib_sparse_conversion (dense,coo) Arguments dense : Shall be a rank-2 array of real or complex type. It is an intent(in) argument. coo : Shall be a COO type of real or complex type. It is an intent(out) argument. Syntax call stdlib_sparse_conversion (coo,dense) Arguments coo : Shall be a COO type of real or complex type. It is an intent(in) argument. dense : Shall be a rank-2 array of real or complex type. It is an intent(out) argument. Syntax call stdlib_sparse_conversion (coo,csr) Arguments coo : Shall be a COO type of real or complex type. It is an intent(in) argument. csr : Shall be a CSR type of real or complex type. It is an intent(out) argument. Syntax call stdlib_sparse_conversion (coo,csc) Arguments coo : Shall be a COO type of real or complex type. It is an intent(in) argument. csc : Shall be a CSC type of real or complex type. It is an intent(out) argument. Syntax call stdlib_sparse_conversion (csr,coo) Arguments csr : Shall be a CSR type of real or complex type. It is an intent(in) argument. coo : Shall be a COO type of real or complex type. It is an intent(out) argument. Syntax call stdlib_sparse_conversion (csr,sellc[,chunk]) Arguments csr : Shall be a CSR type of real or complex type. It is an intent(in) argument. sellc : Shall be a SELLC type of real or complex type. It is an intent(out) argument. chunk , optional : chunk size for the Sliced ELLPACK format. It is an intent(in) argument. Syntax call stdlib_sparse_conversion (csr,ell[,num_nz_rows]) Arguments csr : Shall be a CSR type of real or complex type. It is an intent(in) argument. ell : Shall be a ELL type of real or complex type. It is an intent(out) argument. num_nz_rows , optional : number of non zeros per row. If not give, it will correspond to the size of the longest row in the CSR matrix. It is an intent(in) argument. Syntax call stdlib_sparse_conversion (csc,coo) Arguments csc : Shall be a CSC type of real or complex type. It is an intent(in) argument. coo : Shall be a COO type of real or complex type. It is an intent(out) argument. Example","tags":"","url":"page/specs/stdlib_sparse.html"},{"title":"specialfunctions – LightConvex","text":"Special functions Special functions legendre - Calculate Legendre polynomials Status Description Syntax Arguments Return value dlegendre - Calculate first derivatives of Legendre polynomials Status Description Syntax Arguments Return value legendre - Calculate Legendre polynomials Status Experimental Description Computes the value of the n-th Legendre polynomial at a specified point.\nCurrently only 64 bit floating point is supported. This is an elemental function. Syntax result = stdlib_specialfunctions (n, x) Arguments n : Shall be a scalar of type real(real64) . x : Shall be a scalar or array (this function is elemental) of type real(real64) . Return value The function result will be the value of the n -th Legendre polynomial, evaluated at x . dlegendre - Calculate first derivatives of Legendre polynomials Status Experimental Description Computes the value of the first derivative of the n-th Legendre polynomial at a specified point.\nCurrently only 64 bit floating point is supported. This is an elemental function. Syntax result = stdlib_specialfunctions (n, x) Arguments n : Shall be a scalar of type real(real64) . x : Shall be a scalar or array (this function is elemental) of type real(real64) . Return value The function result will be the value of the first derivative of the n -th Legendre polynomial, evaluated at x .","tags":"","url":"page/specs/stdlib_specialfunctions.html"},{"title":"specialfunctions_activations – LightConvex","text":"Special functions - Neural Networks activations and their gradients Special functions - Neural Networks activations and their gradients Gaussian - Gaussian function Status Description Syntax Class Arguments Return value Example Gaussian_grad - Gradient of the Gaussian function Status Description Syntax Class Arguments Return value Elu - Exponential Linear Unit function Status Description Syntax Class Arguments Return value Example Elu_grad - Gradient of the Exponential Linear Unit function Status Description Syntax Class Arguments Return value Relu - Rectified Linear Unit function Status Description Syntax Class Arguments Return value Example Relu_grad - Gradient of the Rectified Linear Unit function Status Description Syntax Class Arguments Return value leaky_relu - leaky Rectified Linear Unit function Status Description Syntax Class Arguments Return value Example leaky_relu_grad - Gradient of the leaky Rectified Linear Unit function Status Description Syntax Class Arguments Return value Gelu - Gaussian Error Linear Unit function Status Description Syntax Class Arguments Return value Example Gelu_grad - Gradient of the Gaussian Error Linear Unit function Status Description Syntax Class Arguments Return value Gelu_approx - Approximation of the Gaussian Error Linear Unit function Status Description Syntax Class Arguments Return value Gelu_approx_grad - Gradient of the Approximated Gaussian Error Linear Unit function Status Description Syntax Class Arguments Return value Selu - Scaled Exponential Linear Unit function Status Description Syntax Class Arguments Return value Example selu_grad - Gradient of the Scaled Exponential Linear Unit function Status Description Syntax Class Arguments Return value Sigmoid - Sigmoid function Status Description Syntax Class Arguments Return value Sigmoid_grad - Gradient of the Sigmoid function Status Description Syntax Class Arguments Return value SiLU - Sigmoid Linear Unit function Status Description Syntax Class Arguments Return value Example Silu_grad - Gradient of the Sigmoid Linear Unit function Status Description Syntax Class Arguments Return value Step - Step function Status Description Syntax Class Arguments Return value Example step_grad - Gradient of the Step function Status Description Syntax Class Arguments Return value softmax - softmax function Status Description Syntax Class Arguments Return value Example softmax_grad - Gradient of the softmax function Status Description Syntax Class Arguments Return value softplus - softplus function Status Description Syntax Class Arguments Return value Example softplus_grad - Gradient of the softplus function Status Description Syntax Class Arguments Return value Fast tanh - Approximation of the hyperbolic tangent function Status Description Syntax Class Arguments Return value fast_tanh_grad - Gradient of the approximation of the hyperbolic tangent function Status Description Syntax Class Arguments Return value Fast erf - Approximation of the error function Status Description Syntax Class Arguments Return value Gaussian - Gaussian function Status Experimental Description Computes the gaussian function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Example Gaussian_grad - Gradient of the Gaussian function Status Experimental Description Computes the gradient of the gaussian function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Elu - Exponential Linear Unit function Status Experimental Description Computes the gaussian function: Syntax result = stdlib_specialfunctions (x,a) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. a : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Example Elu_grad - Gradient of the Exponential Linear Unit function Status Experimental Description Computes the gradient of the gaussian function: Syntax result = stdlib_specialfunctions (x,a) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. a : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Relu - Rectified Linear Unit function Status Experimental Description Computes the Rectified Linear Unit function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Example Relu_grad - Gradient of the Rectified Linear Unit function Status Experimental Description Computes the gradient of the gaussian function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. leaky_relu - leaky Rectified Linear Unit function Status Experimental Description Computes the gaussian function: Syntax result = stdlib_specialfunctions (x,a) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. a : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Example leaky_relu_grad - Gradient of the leaky Rectified Linear Unit function Status Experimental Description Computes the gradient of the leaky_relu function: Syntax result = stdlib_specialfunctions (x,a) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. a : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as the input argument. Gelu - Gaussian Error Linear Unit function Status Experimental Description Computes the Gaussian Error Linear Unit function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Example Gelu_grad - Gradient of the Gaussian Error Linear Unit function Status Experimental Description Computes the gradient of the gaussian error linear unit function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Gelu_approx - Approximation of the Gaussian Error Linear Unit function Status Experimental Description Computes a fast approximation of the Gaussian Error Linear Unit function using a fast $\\text{erf}$ approximation: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Gelu_approx_grad - Gradient of the Approximated Gaussian Error Linear Unit function Status Experimental Description Computes the gradient of the gaussian error linear unit function using a fast $\\text{erf}$ approximation: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Selu - Scaled Exponential Linear Unit function Status Experimental Description Applies the Scaled Exponential Linear Unit activation function: Where, and Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Example selu_grad - Gradient of the Scaled Exponential Linear Unit function Status Experimental Description Applies the gradient of the Scaled Exponential Linear Unit activation function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Sigmoid - Sigmoid function Status Experimental Description Computes the sigmoid function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Sigmoid_grad - Gradient of the Sigmoid function Status Experimental Description Computes the gradient of the Sigmoid function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. SiLU - Sigmoid Linear Unit function Status Experimental Description Computes the Sigmoid Linear Unit function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Example Silu_grad - Gradient of the Sigmoid Linear Unit function Status Experimental Description Computes the gradient of the Sigmoid function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Step - Step function Status Experimental Description Computes the step function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Example step_grad - Gradient of the Step function Status Experimental Description Computes the gradient of the Sigmoid function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. softmax - softmax function Status Experimental Description Computes the softmax function: Syntax result = stdlib_specialfunctions (x,dim) Class Pure function for ranks 1 to 4. Arguments x : Shall be an array of rank 1 to 4 of any real kind. dim : integer scalar indicating upon which dimension to apply the normalization. Return value The function returns an array with the same rank and kind as the input argument x . Example softmax_grad - Gradient of the softmax function Status Experimental Description Computes the gradient of the softmax function: Syntax result = stdlib_specialfunctions (x,dim) Class Pure function for ranks 1 to 4. Arguments x : Shall be an array of rank 1 to 4 of any real kind. dim : integer scalar indicating upon which dimension to apply the normalization. Return value The function returns a value with the same type and kind as input argument. softplus - softplus function Status Experimental Description Computes the softplus function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Example softplus_grad - Gradient of the softplus function Status Experimental Description Computes the gradient of the softplus function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Fast tanh - Approximation of the hyperbolic tangent function Status Experimental Description Computes an approximated but faster solution to: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. fast_tanh_grad - Gradient of the approximation of the hyperbolic tangent function Status Experimental Description Computes the gradient of the fast_tanh function: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument. Fast erf - Approximation of the error function Status Experimental Description Computes an approximated but faster solution to: Syntax result = stdlib_specialfunctions (x) Class Elemental function Arguments x : Shall be a scalar or array of any real kind. Return value The function returns a value with the same type and kind as input argument.","tags":"","url":"page/specs/stdlib_specialfunctions_activations.html"},{"title":"specialfunctions_gamma – LightConvex","text":"Special functions gamma Special functions gamma gamma - Calculate the gamma function Status Description Syntax Class Arguments Return value Example log_gamma - Calculate the natural logarithm of the gamma function Status Description Syntax Class Arguments Return value Example log_factorial - calculate the logarithm of a factorial Status Description Syntax Class Arguments Return value Example lower_incomplete_gamma - calculate lower incomplete gamma integral Status Description Syntax Class Arguments Return value Example upper_incomplete_gamma - calculate the upper incomplete gamma integral Status Description Syntax Class Arguments Return value Example log_lower_incomplete_gamma - calculate the natural logarithm of the lower incomplete gamma integral Status Description Syntax Class Arguments Return value log_upper_incomplete_gamma - calculate logarithm of the upper incomplete gamma integral Status Description Syntax Class Arguments Return value regularized_gamma_p - calculate the gamma quotient P Status Description Syntax Class Arguments Return value Example regularized_gamma_q - calculate the gamma quotient Q Status Description Syntax Class Arguments Return value Example gamma - Calculate the gamma function Status Experimental Description The gamma function is defined as the analytic continuation of a convergent improper integral function on the whole complex plane except zero and negative integers: Fortran 2018 standard implements the intrinsic gamma function of real type argument in single and double precisions. Here the gamma function is extended to both integer and complex arguments. The values of the gamma function with integer arguments are exact. The values of the gamma function with complex arguments are approximated in single and double precisions by using Lanczos approximation. Syntax result = stdlib_specialfunctions_gamma (x) Class Elemental function Arguments x : should be a positive integer or a complex type number Return value The function returns a value with the same type and kind as input argument. Example log_gamma - Calculate the natural logarithm of the gamma function Status Experimental Description Mathematically, logarithm of gamma function is a special function with complex arguments by itself. Due to the different branch cut structures and a different principal branch, natural logarithm of gamma function log_gamma(z) with complex argument is different from the ln(Gamma(z)). The two have the same real part but different imaginary part. Fortran 2018 standard implements intrinsic log_gamma function of absolute value of real type argument in single and double precision. Here the log_gamma function is extended to both integer and complex arguments. The values of log_gamma function with complex arguments are approximated in single and double precisions by using Stirling's approximation. Syntax result = stdlib_specialfunctions_gamma (x) Class Elemental function Arguments x : Shall be a positive integer or a complex type number. Return value The function returns real single precision values for integer input arguments, while it returns complex values with the same kind as complex input arguments. Example log_factorial - calculate the logarithm of a factorial Status Experimental Description Compute the natural logarithm of factorial, log(n!) Syntax result = stdlib_specialfunctions_gamma (x) Class Elemental function Arguments x : Shall be a positive integer type number. Return value The function returns real type values with single precision. Example lower_incomplete_gamma - calculate lower incomplete gamma integral Status Experimental Description The lower incomplete gamma function is defined as: When x < 0, p must be positive integer. Syntax result = stdlib_specialfunctions_gamma (p, x) Class Elemental function Arguments p : is a positive integer or real type argument. x : is a real type argument. Return value The function returns a real type value with the same kind as argument x. Example upper_incomplete_gamma - calculate the upper incomplete gamma integral Status Experimental Description The upper incomplete gamma function is defined as: When x < 0, p must be a positive integer. Syntax result = stdlib_specialfunctions_gamma (p, x) Class Elemental function Arguments p : is a positive integer or real type argument. x : is a real type argument. Return value The function returns a real type value with the same kind as argument x. Example log_lower_incomplete_gamma - calculate the natural logarithm of the lower incomplete gamma integral Status Experimental Description Compute the natural logarithm of the absolute value of the lower incomplete gamma function. Syntax result = stdlib_specialfunctions_gamma (p, x) Class Elemental function Arguments p : is a positive integer or real type argument. x : is a real type argument. Return value The function returns a real type value with the same kind as argument x. log_upper_incomplete_gamma - calculate logarithm of the upper incomplete gamma integral Status Experimental Description Compute the natural logarithm of the absolute value of the upper incomplete gamma function. Syntax result = stdlib_specialfunctions_gamma (p, x) Class Elemental function Arguments p : is a positive integer or real type argument. x : is a real type argument. Return value The function returns a real type value with the same kind as argument x. regularized_gamma_p - calculate the gamma quotient P Status Experimental Description The regularized gamma quotient P, also known as normalized incomplete gamma function, is defined as: The values of regularized gamma P is in the range of [0, 1] Syntax result = stdlib_specialfunctions_gamma (p, x) Class Elemental function Arguments p : is a positive integer or real type argument. x : is a real type argument. Return value The function returns a real type value with the same kind as argument x. Example regularized_gamma_q - calculate the gamma quotient Q Status Experimental Description The regularized gamma quotient Q is defined as: The values of regularized gamma Q is in the range of [0, 1] Syntax result = stdlib_specialfunctions_gamma (p, x) Class Elemental function Arguments p : is a positive integer or real type argument. x : is a real type argument. Return value The function returns a real type value with the same kind as argument x. Example","tags":"","url":"page/specs/stdlib_specialfunctions_gamma.html"},{"title":"specialmatrices – LightConvex","text":"The stdlib_specialmatrices module The stdlib_specialmatrices module Introduction List of derived types for special matrices Tridiagonal matrices Status Description Syntax Example Symmetric tridiagonal matrices Status Description Syntax Example Hermitian tridiagonal matrices Status Description Syntax Example Specialized drivers for linear algebra tasks Matrix-vector products with spmv Status Description Syntax Arguments Examples Utility functions dense : converting a special matrix to a standard Fortran array Status Description Syntax Arguments transpose : Transposition of a special matrix Status Description Syntax Arguments hermitian : Complex-conjugate transpose of a special matrix Status Description Syntax Arguments Operator overloading (+, -, *) Status Description Syntax Introduction The stdlib_specialmatrices module provides derived types and specialized drivers for highly structured matrices often encountered in scientific computing as well as control and signal processing applications.\nThese include: Tridiagonal matrices Symmetric Tridiagonal matrices Hermitian Tridiagonal matrices Circulant matrices (not yet supported) Toeplitz matrices (not yet supported) Hankel matrices (not yet supported) In addition, it also provides a Poisson2D matrix type (not yet supported) corresponding to the sparse block tridiagonal matrix obtained from discretizing the Laplace operator on a 2D grid with the standard second-order accurate central finite-difference scheme. List of derived types for special matrices Below is a list of the currently supported derived types corresponding to different special matrices.\nNote that this module is under active development and this list will eventually grow. Tridiagonal matrices Status Experimental Description Tridiagonal matrices are ubiquituous in scientific computing and often appear when discretizing 1D differential operators.\nA generic tridiagonal matrix has the following structure: Hence, only one vector of size n and two of size n-1 need to be stored to fully represent the matrix.\nThis particular structure also lends itself to specialized implementations for many linear algebra tasks.\nInterfaces to the most common ones will soon be provided by stdlib_specialmatrices .\nTridiagonal matrices are available with all supported data types as tridiagonal_<kind>_type , for example: tridiagonal_sp_type : Tridiagonal matrix of size n with real / single precision data. tridiagonal_dp_type : Tridiagonal matrix of size n with real / double precision data. tridiagonal_xdp_type : Tridiagonal matrix of size n with real / extended precision data. tridiagonal_qp_type : Tridiagonal matrix of size n with real / quadruple precision data. tridiagonal_csp_type : Tridiagonal matrix of size n with complex / single precision data. tridiagonal_cdp_type : Tridiagonal matrix of size n with complex / double precision data. tridiagonal_cxdp_type : Tridiagonal matrix of size n with complex / extended precision data. tridiagonal_cqp_type : Tridiagonal matrix of size n with complex / quadruple precision data. Syntax To construct a tridiagonal matrix from already allocated arrays dl (lower diagonal, size n-1 ), dv (main diagonal, size n ) and du (upper diagonal, size n-1 ): A = stdlib_specialmatrices (dl, dv, du) To construct a tridiagonal matrix of size n x n with constant diagonal elements dl , dv , and du : A = stdlib_specialmatrices (dl, dv, du, n) Example Symmetric tridiagonal matrices Status Experimental Description Symmetric tridiagonal matrices are ubiquituous in scientific computing and often appear when discretizing 1D differential operators.\nA generic symmetric tridiagonal matrix has the following structure: Hence, only one vector of size n and two of size n-1 need to be stored to fully represent the matrix.\nThis particular structure also lends itself to specialized implementations for many linear algebra tasks.\nInterfaces to the most common ones will soon be provided by stdlib_specialmatrices .\nSymmetric tridiagonal matrices are available with all supported data types as symtridiagonal_<kind>_type , for example: symtridiagonal_sp_type : Symmetric tridiagonal matrix of size n with real / single precision data. symtridiagonal_dp_type : Symmetric tridiagonal matrix of size n with real / double precision data. symtridiagonal_xdp_type : Symmetric tridiagonal matrix of size n with real / extended precision data. symtridiagonal_qp_type : Symmetric tridiagonal matrix of size n with real / quadruple precision data. symtridiagonal_csp_type : Symmetric tridiagonal matrix of size n with complex / single precision data. symtridiagonal_cdp_type : Symmetric tridiagonal matrix of size n with complex / double precision data. symtridiagonal_cxdp_type : Symmetric tridiagonal matrix of size n with complex / extended precision data. symtridiagonal_cqp_type : Symmetric tridiagonal matrix of size n with complex / quadruple precision data. Syntax To construct a symmetric tridiagonal matrix from already allocated arrays dv (main diagonal, size n , only its real part is being referenced) and ev (upper diagonal, size n-1 ): A = stdlib_specialmatrices (dv, ev) To construct a symmetric tridiagonal matrix of size n x n with constant diagonal elements dv , and ev : A = stdlib_specialmatrices (dv, ev, n) Example Hermitian tridiagonal matrices Status Experimental Description Hermitian tridiagonal matrices are ubiquituous in scientific computing.\nA generic hermitian tridiagonal matrix has the following structure: where , and the overbar denotes the complex conjugate operation.\nHence, only one vector of size n and two of size n-1 need to be stored to fully represent the matrix.\nThis particular structure also lends itself to specialized implementations for many linear algebra tasks.\nInterfaces to the most common ones will soon be provided by stdlib_specialmatrices .\nHermitian tridiagonal matrices are available with all supported data types as hermtridiagonal_<kind>_type , for example: hermtridiagonal_csp_type : Hermitian tridiagonal matrix of size n with complex / single precision data. hermtridiagonal_cdp_type : Hermitian tridiagonal matrix of size n with complex / double precision data. hermtridiagonal_cxdp_type : Hermitian tridiagonal matrix of size n with complex / extended precision data. hermtridiagonal_cqp_type : Hermitian tridiagonal matrix of size n with complex / quadruple precision data. Syntax To construct a hermitian tridiagonal matrix from already allocated arrays dv (main diagonal, size n ) and ev (upper diagonal, size n-1 ): A = stdlib_specialmatrices (dv, ev) To construct a hermitian tridiagonal matrix of size n x n with constant diagonal elements dv , and ev : A = stdlib_specialmatrices (dv, ev, n) Note that only the real parts of the diagonal elements dv are being used to construct the corresponding Hermitian matrix. Example Specialized drivers for linear algebra tasks Below is a list of all the specialized drivers for linear algebra tasks currently provided by the stdlib_specialmatrices module. Matrix-vector products with spmv Status Experimental Description With the exception of extended precision and quadruple precision , all the types provided by stdlib_specialmatrices benefit from specialized kernels for matrix-vector products accessible via the common spmv interface. For tridiagonal matrices, the LAPACK lagtm backend is being used. Syntax call stdlib_specialmatrices (A, x, y [, alpha, beta, op]) Arguments A : Shall be a matrix of one of the types provided by stdlib_specialmatrices . It is an intent(in) argument. x : Shall be a rank-1 or rank-2 array with the same kind as A . It is an intent(in) argument. y : Shall be a rank-1 or rank-2 array with the same kind as A . It is an intent(inout) argument. alpha (optional) : Scalar value of the same type as x . It is an intent(in) argument. By default, alpha = 1 . beta (optional) : Scalar value of the same type as y . It is an intent(in) argument. By default beta = 0 . op (optional) : In-place operator identifier. Shall be a character(1) argument. It can have any of the following values: N : no transpose, T : transpose, H : hermitian or complex transpose. Warning Due to limitations of the underlying lapack driver, currently alpha and beta can only take one of the values [-1, 0, 1] for tridiagonal , symtridiagonal and hermtridiagonal matrices. See lagtm for more details. Examples Utility functions dense : converting a special matrix to a standard Fortran array Status Experimental Description Utility function to convert all the matrix types provided by stdlib_specialmatrices to a standard rank-2 array of the appropriate kind. Syntax B = stdlib_specialmatrices (A) Arguments A : Shall be a matrix of one of the types provided by stdlib_specialmatrices . It is an intent(in) argument. B : Shall be a rank-2 allocatable array of the appropriate real or complex kind. transpose : Transposition of a special matrix Status Experimental Description Utility function returning the transpose of a special matrix. The returned matrix is of the same type and kind as the input one. Syntax B = stdlib_specialmatrices (A) Arguments A : Shall be a matrix of one of the types provided by stdlib_specialmatrices . It is an intent(in) argument. B : Shall be a matrix of one of the same type and kind as A . hermitian : Complex-conjugate transpose of a special matrix Status Experimental Description Utility function returning the complex-conjugate transpose of a special matrix. The returned matrix is of the same type and kind as the input one. For real-valued matrices, hermitian is equivalent to transpose . Syntax B = stdlib_specialmatrices (A) Arguments A : Shall be a matrix of one of the types provided by stdlib_specialmatrices . It is an intent(in) argument. B : Shall be a matrix of one of the same type and kind as A . Operator overloading ( + , - , * ) Status Experimental Description The definition of all standard artihmetic operators have been overloaded to be applicable for the matrix types defined by stdlib_specialmatrices : Overloading the + operator for adding two matrices of the same class and kind. Overloading the - operator for subtracting two matrices of the same class and kind. Overloading the * for scalar-matrix multiplication. Syntax Adding two matrices of the same class: C = A [[stdlib_specialmatrices(module):operator(+)(interface)]] B Subtracting two matrices of the same class: C = A [[stdlib_specialmatrices(module):operator(-)(interface)]] B Scalar multiplication B = alpha [[stdlib_specialmatrices(module):operator(*)(interface)]] A Note For addition ( + ) and subtraction ( - ), matrices A , and B need to be of the same class and kind. For scalar multiplication ( * ), A and B need to be of the same class and kind, while alpha is either real or complex (with the same kind again) depending on the type being used.","tags":"","url":"page/specs/stdlib_specialmatrices.html"},{"title":"stats – LightConvex","text":"Descriptive statistics Descriptive statistics corr - Pearson correlation of array elements Status Description Syntax Class Arguments Return value Example cov - covariance of array elements Status Description Syntax Class Arguments Return value Example mean - mean of array elements Status Description Syntax Class Arguments Return value Example median - median of array elements Status Description Syntax Class Arguments Return value Example moment - central moments of array elements Status Description Syntax Class Arguments Return value Example var - variance of array elements Status Description Syntax Class Arguments Return value Example corr - Pearson correlation of array elements Status Experimental Description Returns the Pearson correlation of the elements of array along dimension dim if the corresponding element in mask is true . The Pearson correlation between two rows (or columns), say x and y , of array is defined as: corr ( x , y ) = cov ( x , y ) / sqrt ( var ( x ) * var ( y )) Syntax result = stdlib_stats (array, dim [, mask]) Class Generic subroutine Arguments array : Shall be a rank-1 or a rank-2 array of type integer , real , or complex . It is an intent(in) argument. dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . It is an intent(in) argument. mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . It is an intent(in) argument. Return value If array is of rank 1 and of type real or complex , the result is of type real and has the same kind as array .\nIf array is of rank 2 and of type real or complex , the result is of the same type and kind as array .\nIf array is of type integer , the result is of type real(dp) . If array is of rank 1 and of size larger than 1, a scalar equal to 1 is returned. Otherwise, IEEE NaN is returned.\nIf array is of rank 2, a rank-2 array  with the corresponding correlations is returned. If mask is specified, the result is the Pearson correlation of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example cov - covariance of array elements Status Experimental Description Returns the covariance of the elements of array along dimension dim if the corresponding element in mask is true . Per default, the covariance is defined as: cov(array) = 1/(n-1) sum_i (array(i) - mean(array) * (array(i) - mean(array))) where n is the number of elements. The scaling can be changed with the logical argument corrected . If corrected is .false. , then the sum is scaled with n , otherwise with n-1 . Syntax result = stdlib_stats (array, dim [, mask [, corrected]]) Class Generic subroutine Arguments array : Shall be a rank-1 or a rank-2 array of type integer , real , or complex . It is an intent(in) argument. dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . It is an intent(in) argument. mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . It is an intent(in) argument. corrected (optional): Shall be a scalar of type logical . If corrected is .true. (default value), the sum is scaled with n-1 . If corrected is .false. , then the sum is scaled with n . It is an intent(in) argument. Return value If array is of rank 1 and of type real or complex , the result is of type real corresponding to the type of array .\nIf array is of rank 2 and of type real or complex , the result is of the same type as array .\nIf array is of type integer , the result is of type real(dp) . If array is of rank 1, a scalar with the covariance (that is the variance) of all elements in array is returned.\nIf array is of rank 2, a rank-2 array is returned. If mask is specified, the result is the covariance of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example mean - mean of array elements Status Experimental Description Returns the mean of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . Syntax result = stdlib_stats (array [, mask]) result = stdlib_stats (array, dim [, mask]) Class Generic subroutine Arguments array : Shall be an array of type integer , real , or complex . It is an intent(in) argument. dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . It is an intent(in) argument. mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . It is an intent(in) argument. Return value If array is of type real or complex , the result is of the same type as array .\nIf array is of type integer , the result is of type real(dp) . If dim is absent, a scalar with the mean of all elements in array is returned. Otherwise, an array of rank n-1 , where n equals the rank of array , and a shape similar to that of array with dimension dim dropped is returned. If mask is specified, the result is the mean of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example median - median of array elements Status Experimental Description Returns the median of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . The median of the elements of array is defined as the \"middle\"\nelement, after that the elements are sorted in an increasing order, e.g. array_sorted =\nsort(array) . If n = size(array) is an even number, the median is: median(array) = array_sorted( floor( (n + 1) / 2.)) and if n is an odd number, the median is: median(array) = mean( array_sorted( floor( (n + 1) / 2.):floor( (n + 1) / 2.) + 1 ) ) The current implementation relies on a selection algorithm applied on a copy of\nthe whole array, using the subroutine stdlib_selection provided by the stdlib_selection module. Syntax result = stdlib_stats (array [, mask]) result = stdlib_stats (array, dim [, mask]) Class Generic subroutine Arguments array : Shall be an array of type integer or real . It is an intent(in) argument. dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . It is an intent(in) argument. mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . It is an intent(in) argument. Return value If array is of type real , the result is of type real with the same kind as array .\nIf array is of type real and contains IEEE NaN , the result is IEEE NaN .\nIf array is of type integer , the result is of type real(dp) . If dim is absent, a scalar with the median of all elements in array is returned. Otherwise, an array of rank n-1 , where n equals the rank of array , and a shape similar to that of array with dimension dim dropped is returned. If mask is specified, the result is the median of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example moment - central moments of array elements Status Experimental Description Returns the k -th order central moment of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . If a scalar or an array center is provided, the function returns the k -th order moment about 'center', of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . The k -th order central moment is defined as : moment(array) = 1/n sum_i (array(i) - mean(array))&#94;k where n is the number of elements. The k -th order moment about center is defined as : moment(array) = 1/n sum_i (array(i) - center)&#94;k Syntax result = stdlib_stats (array, order [, center [, mask]]) result = stdlib_stats (array, order, dim [, center [, mask]]) Class Generic subroutine Arguments array : Shall be an array of type integer , real , or complex . order : Shall be an scalar of type integer . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . center (optional): Shall be a scalar of the same type of result if dim is not provided. If dim is provided, center shall be a scalar or an array (with a shape similar to that of array with dimension dim dropped) of the same type of result . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . Return value If array is of type real or complex , the result is of the same type as array .\nIf array is of type integer , the result is of type real(dp) . If dim is absent, a scalar with the k -th (central) moment of all elements in array is returned. Otherwise, an array of rank n-1 , where n equals the rank of array , and a shape similar to that of array with dimension dim dropped is returned. If mask is specified, the result is the k -th  (central) moment of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example var - variance of array elements Status Experimental Description Returns the variance of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . Per default, the variance is defined as the best unbiased estimator and is computed as: var ( array ) = 1 / ( n - 1 ) sum_i ( array ( i ) - mean ( array )) &#94; 2 where n is the number of elements. The use of the term n-1 for scaling is called Bessel 's correction. The scaling can be changed with the logical argument corrected . If corrected is .false. , then the sum is scaled with n , otherwise with n-1 . Syntax result = stdlib_stats (array [, mask [, corrected]]) result = stdlib_stats (array, dim [, mask [, corrected]]) Class Generic subroutine Arguments array : Shall be an array of type integer , real , or complex . It is an intent(in) argument. dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . It is an intent(in) argument. mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . It is an intent(in) argument. corrected (optional): Shall be a scalar of type logical . If corrected is .true. (default value), the sum is scaled with n-1 . If corrected is .false. , then the sum is scaled with n . It is an intent(in) argument. Return value If array is of type real or complex , the result is of type real corresponding to the type of array .\nIf array is of type integer , the result is of type real(dp) . If dim is absent, a scalar with the variance of all elements in array is returned. Otherwise, an array of rank n-1 , where n equals the rank of array , and a shape similar to that of array with dimension dim dropped is returned. If mask is specified, the result is the variance of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . If the variance is computed with only one single element, then the result is IEEE NaN if corrected is .true. and is 0. if corrected is .false. . Example","tags":"","url":"page/specs/stdlib_stats.html"},{"title":"stats_distribution_exponential – LightConvex","text":"Statistical Distributions -- Exponential Distribution Module Statistical Distributions -- Exponential Distribution Module rvs_exp - exponential distribution random variates Status Description Syntax Class Arguments Return value Example pdf_exp - exponential distribution probability density function Status Description Syntax Class Arguments Return value Example cdf_exp - exponential cumulative distribution function Status Description Syntax Class Arguments Return value Example rvs_exp - exponential distribution random variates Status Experimental Description An exponential distribution is the distribution of time between events in a Poisson point process.\nThe inverse scale parameter lambda specifies the average time between events ( ), also called the rate of events. The location loc specifies the value by which the distribution is shifted. Without argument, the function returns a random sample from the unshifted standard exponential distribution or . With a single argument of type real , the function returns a random sample from the exponential distribution . \nFor complex arguments, the real and imaginary parts are sampled independently of each other. With one argument of type real and one argument of type integer , the function returns a rank-1 array of exponentially distributed random variates for (E(\\lambda=\\text{lambda})). With two arguments of type real , the function returns a random sample from the exponential distribution .\nFor complex arguments, the real and imaginary parts are sampled independently of each other. With two arguments of type real and one argument of type integer , the function returns a rank-1 array of exponentially distributed random variates for . Note The algorithm used for generating exponential random variates is fundamentally limited to double precision. 1 Syntax result = stdlib_stats_distribution_exponential ([loc, scale] [[, array_size]]) or result = stdlib_stats_distribution_exponential ([lambda] [[, array_size]]) Class Elemental function Arguments lambda : optional argument has intent(in) and is a scalar of type real or complex .\nIf lambda is real , its value must be positive. If lambda is complex , both the real and imaginary components must be positive. loc : optional argument has intent(in) and is a scalar of type real or complex . scale : optional argument has intent(in) and is a positive scalar of type real or complex .\nIf scale is real , its value must be positive. If scale is complex , both the real and imaginary components must be positive. array_size : optional argument has intent(in) and is a scalar of type integer with default kind. Return value If lambda is passed, the result is a scalar or rank-1 array with a size of array_size , and the same type as lambda .\nIf lambda is non-positive, the result is NaN . If loc and scale are passed, the result is a scalar or rank-1 array with a size of array_size , and the same type as scale .\nIf scale is non-positive, the result is NaN . Example pdf_exp - exponential distribution probability density function Status Experimental Description The probability density function (pdf) of the single real variable exponential distribution is: For a complex variable with independent real and imaginary parts, the joint probability density function is the product of the corresponding real and imaginary marginal pdfs: 2 Instead of of the inverse scale parameter lambda , it is possible to pass loc and scale , where and loc specifies the value by which the distribution is shifted. Syntax result = stdlib_stats_distribution_exponential (x, loc, scale) or result = stdlib_stats_distribution_exponential (x, lambda) Class Elemental function Arguments x : has intent(in) and is a scalar of type real or complex . lambda : has intent(in) and is a scalar of type real or complex .\nIf lambda is real , its value must be positive. If lambda is complex , both the real and imaginary components must be positive. loc : has intent(in) and is a scalar of type real or complex . scale : has intent(in) and is a positive scalar of type real or complex .\nIf scale is real , its value must be positive. If scale is complex , both the real and imaginary components must be positive. All arguments must have the same type. Return value The result is a scalar or an array, with a shape conformable to the arguments, and the same type as the input arguments. If non-positive lambda or scale , the result is NaN . Example cdf_exp - exponential cumulative distribution function Status Experimental Description Cumulative distribution function (cdf) of the single real variable exponential distribution: For a complex variable with independent real and imaginary parts, the joint cumulative distribution function is the product of corresponding real and imaginary marginal cdfs: 2 Alternative to the inverse scale parameter lambda , it is possible to pass loc and scale , where and loc specifies the value by which the distribution is shifted. Syntax result = stdlib_stats_distribution_exponential (x, loc, scale) or result = stdlib_stats_distribution_exponential (x, lambda) Class Elemental function Arguments x : has intent(in) and is a scalar of type real or complex . lambda : has intent(in) and is a scalar of type real or complex .\nIf lambda is real , its value must be positive. If lambda is complex , both the real and imaginary components must be positive. loc : has intent(in) and is a scalar of type real or complex . scale : has intent(in) and is a positive scalar of type real or complex .\nIf scale is real , its value must be positive. If scale is complex , both the real and imaginary components must be positive. All arguments must have the same type. Return value The result is a scalar or an array, with a shape conformable to the arguments, and the same type as the input arguments. With non-positive lambda or scale , the result is NaN . Example Marsaglia, George, and Wai Wan Tsang. \"The ziggurat method for generating random variables.\" Journal of statistical software 5 (2000): 1-7. ↩ Miller, Scott, and Donald Childers. Probability and random processes: With applications to signal processing and communications . Academic Press, 2012 (p. 197). ↩ ↩","tags":"","url":"page/specs/stdlib_stats_distribution_exponential.html"},{"title":"stats_distribution_normal – LightConvex","text":"Statistical Distributions -- Normal Distribution Module Statistical Distributions -- Normal Distribution Module rvs_normal - normal distribution random variates Status Description Syntax Class Arguments Return value Example pdf_normal - normal distribution probability density function Status Description Syntax Class Arguments Return value Example cdf_normal - normal distribution cumulative distribution function Status Description Syntax Class Arguments Return value Example rvs_normal - normal distribution random variates Status Experimental Description A normal continuous random variate distribution, also known as Gaussian, or Gauss or Laplace-Gauss distribution.\nThe location loc specifies the mean or expectation ( ). The scale specifies the standard deviation ( ). Without argument, the function returns a standard normal distributed random variate . With two arguments, the function returns a normal distributed random variate . For complex arguments, the real and imaginary parts are independent of each other. With three arguments, the function returns a rank-1 array of normal distributed random variates. Note The algorithm used for generating exponential random variates is fundamentally limited to double precision. 1 Syntax result = stdlib_stats_distribution_normal ([loc, scale] [[, array_size]]) Class Elemental function (passing both loc and scale ). Arguments loc : optional argument has intent(in) and is a scalar of type real or complex . scale : optional argument has intent(in) and is a positive scalar of type real or complex . array_size : optional argument has intent(in) and is a scalar of type integer . loc and scale arguments must be of the same type. Return value The result is a scalar or rank-1 array, with a size of array_size , and the same type as scale and loc . If scale is non-positive, the result is NaN . Example pdf_normal - normal distribution probability density function Status Experimental Description The probability density function (pdf) of the single real variable normal distribution: For a complex varible with independent real and imaginary parts, the joint probability density function is the product of the the corresponding real and imaginary marginal pdfs: 2 Syntax result = stdlib_stats_distribution_normal (x, loc, scale) Class Elemental function Arguments x : has intent(in) and is a scalar of type real or complex . loc : has intent(in) and is a scalar of type real or complex . scale : has intent(in) and is a positive scalar of type real or complex . All three arguments must have the same type. Return value The result is a scalar or an array, with a shape conformable to the arguments, and the same type as the input arguments. If scale is non-positive, the result is NaN . Example cdf_normal - normal distribution cumulative distribution function Status Experimental Description Cumulative distribution function of the single real variable normal distribution: For the complex variable with independent real and imaginary parts, the joint cumulative distribution function is the product of the corresponding real and imaginary marginal cdfs: 2 Syntax result = stdlib_stats_distribution_normal (x, loc, scale) Class Elemental function Arguments x : has intent(in) and is a scalar of type real or complex . loc : has intent(in) and is a scalar of type real or complex . scale : has intent(in) and is a positive scalar of type real or complex . All three arguments must have the same type. Return value The result is a scalar or an array, with a shape conformable to the arguments, and the same type as the input arguments. If scale is non-positive, the result is NaN . Example Marsaglia, George, and Wai Wan Tsang. \"The ziggurat method for generating random variables.\" Journal of statistical software 5 (2000): 1-7. ↩ Miller, Scott, and Donald Childers. Probability and random processes: With applications to signal processing and communications . Academic Press, 2012 (p. 197). ↩ ↩","tags":"","url":"page/specs/stdlib_stats_distribution_normal.html"},{"title":"stats_distribution_uniform – LightConvex","text":"Statistical Distributions -- Uniform Distribution Module Statistical Distributions -- Uniform Distribution Module shuffle - Using Fisher-Yates algorithm to generate a random permutation of a list Status Description Syntax Class Arguments Return value Example rvs_uniform - uniform distribution random variates Status Description Syntax Class Arguments Return value Example pdf_uniform - Uniform distribution probability density function Status Description Syntax Class Arguments Return value Example cdf_uniform - Uniform distribution cumulative distribution function Status Description Syntax Class Arguments Return value Example shuffle - Using Fisher-Yates algorithm to generate a random permutation of a list Status Experimental Description Applying Fisher-Yates algorithm to generate an unbiased permutation for any list of intrinsic numerical data types. Syntax result = stdlib_stats_distribution_uniform ( list ) Class Function. Arguments list : argument has intent(in) and is a rank one array of integer , real , or complex type. Return value Return a randomized rank one array of the input type. Example rvs_uniform - uniform distribution random variates Status Experimental Description Without argument the function returns a scalar standard uniformly distributed variate U(0,1) of real type with single precision on [0,1]. With single argument scale of integer type the function returns a scalar uniformly distributed variate of integer type on [0,scale]. This is the standard Rectangular distribution. With single argument scale of real or complex type the function returns a scalar uniformly distributed variate of real type on [0, scale] or complex type on [(0, 0i), (scale, i(scale))]. With double arguments loc and scale the function returns a scalar uniformly distributed random variates of integer or real type on [loc, loc + scale], or complex type on [(loc, i(loc)), ((loc + scale), i(loc + scale))], dependent of input type. With triple arguments loc , scale and array_size the function returns a rank one array of uniformly distributed variates of integer , real or complex type with an array size of array_size . For complex type, the real part and imaginary part are independent of each other. Note: the algorithm used for generating uniform random variates is fundamentally limited to double precision. Syntax result = stdlib_stats_distribution_uniform ([[loc,] scale] [[[,array_size]]]) Class Elemental function (without the third argument). Arguments loc : optional argument has intent(in) and is a scalar of type integer , real or complex . scale : optional argument has intent(in) and is a scalar of type integer , real or complex . array_size : optional argument has intent(in) and is a scalar of type integer with default kind. loc and scale must have the same type and kind when both are present. Return value The result is a scalar or a rank one array with size of array_size , of type integer , real or complex depending on the input type. Example pdf_uniform - Uniform distribution probability density function Status Experimental Description The probability density function of the uniform distribution: f(x) = 0       x < loc or x > loc + scale  for all types uniform distributions For random variable x in [loc, loc + scale]: f(x) = 1 / (scale + 1);            for discrete uniform distribution. f(x) = 1 / scale;                  for continuous uniform distribution. f(x) = 1 / (scale%re * scale%im);  for complex uniform distribution. Syntax result = stdlib_stats_distribution_uniform (x, loc, scale) Class Elemental function. Arguments x : has intent(in) and is a scalar of type integer , real or complex . loc : has intent(in) and is a scalar of type integer , real or complex . scale : has intent(in) and is a scalar of type integer , real or complex . All three arguments must have the same type and kind. Return value The result is a scalar or an array, with a shape conformable to arguments, of type real . Example cdf_uniform - Uniform distribution cumulative distribution function Status Experimental Description Cumulative distribution function of the uniform distribution: F(x) = 0             x < loc             for all types uniform distributions F(x) = 1             x > loc + scale     for all types uniform distributions For random variable x in [loc, loc + scale]: F(x) = (x - loc + 1) / (scale + 1);      for discrete uniform distribution. F(x) = (x - loc) / scale;                for continuous uniform distribution. F(x) = (x%re - loc%re)(x%im - loc%im) / (scale%re * scale%im); for complex uniform distribution. Syntax result = stdlib_stats_distribution_uniform (x, loc, scale) Class Elemental function. Arguments x : has intent(in) and is a scalar of type integer , real or complex . loc : has intent(in) and is a scalar of type integer , real or complex . scale : has intent(in) and is a scalar of type integer , real or complex . All three arguments must have the same type and kind. Return value The result is a scalar or an array, with a shape conformable to arguments, of type real . Example","tags":"","url":"page/specs/stdlib_stats_distribution_uniform.html"},{"title":"str2num – LightConvex","text":"The stdlib_str2num module This module proposes a function-style interface for string-to-number conversion. It also profits from Fortran's interfaces to implement precision-dependant algorithms to maximize runtime efficiency. The stdlib_str2num module to_num - conversion of strings to numbers Status Description Syntax Arguments Return value Example to_num_from_stream - conversion of a stream of values in a string to numbers Status Description Syntax Arguments Return value Example Note to_num - conversion of strings to numbers Status Experimental Description Convert a string or an array of strings to numerical types. Syntax number = stdlib_str2num (string, mold) Arguments string : argument has intent(in) and is of type character(*) . mold : argument has intent(in) and is of numerical type (that is of integer or of real ). Note : The type of the mold argument defines the type of the result. Return value Return a scalar of numerical type (i.e., integer , or real ). Example to_num_from_stream - conversion of a stream of values in a string to numbers Status Experimental Description Convert a stream of values in a string to an array of values. Syntax number = stdlib_str2num (string, mold) Arguments string : argument has intent(in) and is of type character(:), pointer . mold : argument has intent(in) and is of numerical type (currently of integer or real ). Note : The type of the mold argument defines the type of the result. Return value Return a scalar of numerical type (i.e., integer or real ). Example Note The accuracy of the conversion is implementation dependent; it is recommended that implementers guarantee precision down to the last 3 bits. The current implementation has been tested to provide for : sp : exact match dp : precision up-to epsilon(0.0_dp) qp : precision around 200*epsilon(0.0_qp) Where precision refers to the relative difference between to_num and read . On the other hand, to_num provides speed-ups ranging from 4x to >10x compared to the intrinsic read .","tags":"","url":"page/specs/stdlib_str2num.html"},{"title":"string_type – LightConvex","text":"The stdlib_string_type module The stdlib_string_type module Introduction Derived types provided The string_type derived type Status Procedures and methods provided Constructor for empty string Status Description Syntax Class Argument Result value Example Constructor from character scalar Status Description Syntax Class Argument Result value Example Constructor from integer scalar Status Description Syntax Class Argument Result value Example Constructor from logical scalar Status Description Syntax Class Argument Result value Example Assignment of character scalar Status Description Syntax Class Example Len function Status Description Syntax Class Argument Result value Example Len_trim function Status Description Syntax Class Argument Result value Example Trim function Status Description Syntax Class Argument Result value Example Adjustl function Status Description Syntax Class Argument Result value Example Adjustr function Status Description Syntax Class Argument Result value Example Repeat function Status Description Syntax Class Argument Result value Example Char function Status Description Syntax Class Argument Result value Example Char function (position variant) Status Description Syntax Class Argument Result value Example Char function (range variant) Status Description Syntax Class Argument Result value Example Ichar function Status Description Syntax Class Argument Result value Example Iachar function Status Description Syntax Class Argument Result value Example Index function Status Description Syntax Class Argument Result value Example Scan function Status Description Syntax Class Argument Result value Example Verify function Status Description Syntax Class Argument Result value Example Lgt function (lexical greater than) Status Description Syntax Class Argument Result value Example Llt function (lexical less than) Status Description Syntax Class Argument Result value Example Lge function (lexical greater than or equal) Status Description Syntax Class Argument Result value Example Lle function (lexical less than or equal) Status Description Syntax Class Argument Result value Example To_lower function Status Description Syntax Class Argument Result Value Example To_upper function Status Description Syntax Class Argument Result Value Example To_title function Status Description Syntax Class Argument Result Value Example To_sentence function Status Description Syntax Class Argument Result Value Example Reverse function Status Description Syntax Class Argument Result Value Example Comparison operator greater Status Description Syntax Class Argument Result value Example Comparison operator less Status Description Syntax Class Argument Result value Example Comparison operator greater or equal Status Description Syntax Class Argument Result value Example Comparison operator less or equal Status Description Syntax Class Argument Result value Example Comparison operator equal Status Description Syntax Class Argument Result value Example Comparison operator not equal Status Description Syntax Class Argument Result value Example Concatenation operator Status Description Syntax Class Argument Result value Example Unformatted write Status Description Syntax Class Argument Example Formatted write Status Description Syntax Class Argument Example Unformatted read Status Description Syntax Class Argument Example Formatted read Status Description Syntax Class Argument Example move Status Description Syntax Class Argument Example Introduction The stdlib_string_type provides a derived type holding an arbitrary sequence\nof characters compatible with most Fortran intrinsic character procedures as\nwell as operators for working with character variables and constants. Derived types provided The string_type derived type The string_type is defined as a non-extendible derived type representing a\nsequence of characters. The internal representation of the character sequence\nis implementation dependent and not visible for the user of the module. Status Experimental Procedures and methods provided Procedures returning string_type instances can usually be used in elemental\ncontext, while procedures returning scalar character values can only be\nused in a pure way. Constructor for empty string Status Experimental Description The module defines a constructor to create an empty string type. Creates a string instance representing an empty string. Syntax res = stdlib_string_type () Class Elemental function. Argument None. Result value The result is an instance of string_type with zero length. Example Constructor from character scalar Status Experimental Description The module defines a constructor to create a string type from a character scalar. Creates a string instance representing the input character scalar value.\nThe constructor shall create an empty string if an unallocated deferred-length\ncharacter variable is passed. Syntax res = stdlib_string_type (string) Class Elemental function. Argument string : shall be a scalar character value. It is an intent(in) argument. Result value The result is an instance of string_type . Example Constructor from integer scalar Status Experimental Description The module defines a constructor to create a string type from an integer scalar. Syntax res = stdlib_string_type (string) Class Elemental function. Argument val : shall be a scalar integer value. It is an intent(in) argument. Result value The result is an instance of string_type . Example Constructor from logical scalar Status Experimental Description The module defines a constructor to create a string type from a logical scalar. Syntax res = stdlib_string_type (string) Class Elemental function. Argument val : shall be a scalar logical value. It is an intent(in) argument. Result value The result is an instance of string_type . Example Assignment of character scalar Status Experimental Description The module defines an assignment operations, = , to create a string type\nfrom a character scalar. Creates a string instance representing the right-hand-side character scalar value. Syntax lhs = rhs Class Elemental subroutine, assignment(=) . Example Len function Status Experimental Description Returns the length of the string. Syntax res = stdlib_string_type (string) Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a default integer scalar value. Example Len_trim function Status Experimental Description Returns the length of the character sequence without trailing spaces\nrepresented by the string. Syntax res = stdlib_string_type (string) Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a default integer scalar value. Example Trim function Status Experimental Description Returns the character sequence hold by the string without trailing spaces\nrepresented by a string_type . Syntax res = stdlib_string_type (string) Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a scalar string_type value. Example Adjustl function Status Experimental Description Left-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Syntax res = stdlib_string_type (string) Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a scalar string_type value. Example Adjustr function Status Experimental Description Right-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Syntax res = stdlib_string_type (string) Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a scalar string_type value. Example Repeat function Status Experimental Description Repeats the character sequence hold by the string by the number of\nspecified copies. Syntax res = stdlib_string_type (string, ncopies) Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . ncopies : Integer of default type. This argument is intent(in) . Result value The result is a scalar string_type value. Example Char function Status Experimental Description Return the character sequence represented by the string. Syntax res = stdlib_string_type (string) Class Pure function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a scalar character value. Example Char function (position variant) Status Experimental Description Return the character at a certain position in the string. Syntax res = stdlib_string_type (string, pos) Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . pos : Integer of default type. This argument is intent(in) . Result value The result is a scalar character value. Example Char function (range variant) Status Experimental Description Return a substring from the character sequence of the string. Syntax res = stdlib_string_type (string, start, last) Class Pure function. Argument string : Instance of a string_type . This argument is intent(in) . start : Integer of default type. This argument is intent(in) . last : Integer of default type. This argument is intent(in) . Result value The result is a scalar character value. Example Ichar function Status Experimental Description Character-to-integer conversion function. Returns the code for the character in the first character position of the\ncharacter sequence in the system's native character set. Syntax res = stdlib_string_type (string) Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a default integer scalar value. Example Iachar function Status Experimental Description Code in ASCII collating sequence. Returns the code for the ASCII character in the first character position of\nthe character sequences represent by the string. Syntax res = stdlib_string_type (string) Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a default integer scalar value. Example Index function Status Experimental Description Position of a substring within a string . Returns the position of the start of the leftmost or rightmost occurrence\nof string substring in string , counting from one. If substring is not\npresent in string , zero is returned. Syntax res = stdlib_string_type (string, substring[, back]) Class Elemental function. Argument string : Either scalar character value or string type. This argument is intent(in) . substring : Either scalar character value or string type. This argument is intent(in) . back : Either absent or a scalar logical value. This argument is intent(in) . Result value The result is a default integer scalar value. Example Scan function Status Experimental Description Scans a string for the  presence any of the characters in a set of characters.\nIf back is either absent or false , this function returns the position\nof the leftmost character of string that is in set . If back is true ,\nthe rightmost position is returned. If no character of set is found in string , the result is zero. Syntax res = stdlib_string_type (string, set[, back]) Class Elemental function. Argument string : Either scalar character value or string type. This argument is intent(in) . set : Either scalar character value or string type. This argument is intent(in) . back : Either absent or a scalar logical value. This argument is intent(in) . Result value The result is a default integer scalar value. Example Verify function Status Experimental Description Verifies that all the characters in string belong to the set of characters in set .\nIf back is either absent or false , this function returns the position\nof the leftmost character of string that is not in set . If back is true ,\nthe rightmost position is returned. If all characters of string are found\nin set , the result is zero. Syntax res = stdlib_string_type (string, set[, back]) Class Elemental function. Argument string : Either scalar character value or string type. This argument is intent(in) . set : Either scalar character value or string type. This argument is intent(in) . back : Either absent or a scalar logical value. This argument is intent(in) . Result value The result is a default integer scalar value. Example Lgt function (lexical greater than) Status Experimental Description Lexically compare the order of two character sequences being greater than. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic lgt procedure. Syntax res = stdlib_string_type (lhs, rhs) Class Elemental function. Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example Llt function (lexical less than) Status Experimental Description Lexically compare the order of two character sequences being less than. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic llt procedure. Syntax res = stdlib_string_type (lhs, rhs) Class Elemental function. Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example Lge function (lexical greater than or equal) Status Experimental Description Lexically compare the order of two character sequences being greater than\nor equal. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic lge procedure. Syntax res = stdlib_string_type (lhs, rhs) Class Elemental function. Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example Lle function (lexical less than or equal) Status Experimental Description Lexically compare the order of two character sequences being less than\nor equal. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic lle procedure. Syntax res = stdlib_string_type (lhs, rhs) Class Elemental function. Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example To_lower function Status Experimental Description Returns a new string_type instance which holds the lowercase version of the\ncharacter sequence hold by the input string. Syntax lowercase_string = stdlib_string_type (string) Class Elemental function. Argument string : Instance of string_type . This argument is intent(in) . Result Value The result is a scalar string_type value. Example To_upper function Status Experimental Description Returns a new string_type instance which holds the uppercase version of the\ncharacter sequence hold by the input string. Syntax uppercase_string = stdlib_string_type (string) Class Elemental function. Argument string : Instance of string_type . This argument is intent(in) . Result Value The result is a scalar string_type value. Example To_title function Status Experimental Description Returns a new string_type instance which holds the titlecase version\nof the character sequence hold by the input string.\nTitle case: First character of every word in the sentence is converted to\nuppercase and the rest of the characters are converted to lowercase.\nA word is a contiguous sequence of character(s) which consists of alphabetical\ncharacter(s) and numeral(s) only and doesn't exclude any alphabetical character\nor numeral present next to either of its 2 ends. Syntax titlecase_string = stdlib_string_type (string) Class Elemental function. Argument string : Instance of string_type . This argument is intent(in) . Result Value The result is a scalar string_type value. Example To_sentence function Status Experimental Description Returns a new string_type instance which holds the sentencecase\nversion of the character sequence hold by the input string.\nSentencecase version: The first alphabetical character of the input character sequence\nis transformed to uppercase unless it follows a numeral and the rest of the\ncharacters in the sequence are transformed to lowercase. Syntax sentencecase_string = stdlib_string_type (string) Class Elemental function. Argument string : Instance of string_type . This argument is intent(in) . Result Value The result is a scalar string_type value. Example Reverse function Status Experimental Description Returns a new string_type instance which holds the reversed version of the\ncharacter sequence hold by the input string. Syntax reverse_string = stdlib_string_type (string) Class Elemental function. Argument string : Instance of string_type . This argument is intent(in) . Result Value The result is a scalar string_type value. Example Comparison operator greater Status Experimental Description Compare the order of two character sequences being greater. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(>) and operator(.gt.) . Syntax res = lhs > rhs res = lhs .gt. rhs Class Elemental function, operator(>) and operator(.gt.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example Comparison operator less Status Experimental Description Compare the order of two character sequences being less. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(<) and operator(.lt.) . Syntax res = lhs < rhs res = lhs .lt. rhs Class Elemental function, operator(<) and operator(.lt.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example Comparison operator greater or equal Status Experimental Description Compare the order of two character sequences being greater or equal. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(>=) and operator(.ge.) . Syntax res = lhs >= rhs res = lhs .ge. rhs Class Elemental function, operator(>=) and operator(.ge.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example Comparison operator less or equal Status Experimental Description Compare the order of two character sequences being less or equal. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(<=) and operator(.le.) . Syntax res = lhs <= rhs res = lhs .le. rhs Class Elemental function, operator(<=) and operator(.le.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example Comparison operator equal Status Experimental Description Compare two character sequences for equality. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(==) and operator(.eq.) . Syntax res = lhs == rhs res = lhs .eq. rhs Class Elemental function, operator(==) and operator(.eq.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example Comparison operator not equal Status Experimental Description Compare two character sequences for inequality. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(/=) and operator(.ne.) . Syntax res = lhs /= rhs res = lhs .ne. rhs Class Elemental function, operator(/=) and operator(.ne.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example Concatenation operator Status Experimental Description Concatenate two character sequences. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(//) . Syntax res = lhs // rhs Class Elemental function, operator(//) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is an instance of string_type . Example Unformatted write Status Experimental Description Write the character sequence hold by the string to a connected unformatted unit.\nThe character sequences is represented by an 64 bit signed integer record,\nholding the length of the following character record. Syntax write(unit, iostat=iostat, iomsg=iomsg) string Class Unformatted user defined derived type output. Argument string : Instance of the string type to read. This argument is intent(inout) . unit : Formatted unit for output. This argument is intent(in) . iostat : Status identifier to indicate success of output operation.\n  This argument is intent(out) . iomsg : Buffer to return error message in case of failing output operation.\n  This argument is intent(inout) . Example Formatted write Status Experimental Description Write the character sequence hold by the string to a connected formatted unit. The current implementation is limited to list directed output and dt formatted\noutput. Requesting namelist output will raise an error. Syntax write(unit, fmt, iostat=iostat, iomsg=iomsg) string Class Formatted user defined derived type output. Argument string : Instance of the string type to read. This argument is intent(inout) . unit : Formatted unit for output. This argument is intent(in) . iotype : Type of formatted data transfer, has the value \"LISTDIRECTED\" for fmt=* , \"NAMELIST\" for namelist output or starts with \"DT\" for derived type output.\n  This argument is intent(in) . v_list : Rank one array of default integer type containing the edit descriptors for\n  derived type output.\n  This argument is intent(in) . iostat : Status identifier to indicate success of output operation.\n  This argument is intent(out) . iomsg : Buffer to return error message in case of failing output operation.\n  This argument is intent(inout) . Example Unformatted read Status Experimental Description Read a character sequence from a connected unformatted unit into the string.\nThe character sequences is represented by an 64 bit signed integer record,\nholding the length of the following character record. On failure the state the read variable is undefined and implementation dependent. Syntax read(unit, iostat=iostat, iomsg=iomsg) string Class Unformatted derived type input. Argument string : Instance of the string type to read. This argument is intent(inout) . unit : Formatted unit for input. This argument is intent(in) . iostat : Status identifier to indicate success of input operation.\n  This argument is intent(out) . iomsg : Buffer to return error message in case of failing input operation.\n  This argument is intent(inout) . Example Formatted read Status Experimental Description Read a character sequence from a connected formatted unit into the string.\nList-directed input will retrieve the complete record into the string. On failure the state the read variable is undefined and implementation dependent. The current implementation is limited to list directed input.\nRequesting dt formatted input or namelist output will raise an error. Syntax read(unit, fmt, iostat=iostat, iomsg=iomsg) string Class Formatted derived type input. Argument string : Instance of the string type to read. This argument is intent(inout) . unit : Formatted unit for input. This argument is intent(in) . iotype : Type of formatted data transfer, has the value \"LISTDIRECTED\" for fmt=* , \"NAMELIST\" for namelist input or starts with \"DT\" for derived type input.\n  This argument is intent(in) . v_list : Rank one array of default integer type containing the edit descriptors for\n  derived type input.\n  This argument is intent(in) . iostat : Status identifier to indicate success of input operation.\n  This argument is intent(out) . iomsg : Buffer to return error message in case of failing input operation.\n  This argument is intent(inout) . Example move Status Experimental Description Moves the allocation from from to to , consequently deallocating from in this process.\nIf from is not allocated before execution, to gets deallocated by the process.\nAn unallocated string_type instance is equivalent to an empty string.\nIf from and to are the same variable, then from remains unchanged. Syntax call stdlib_string_type (from, to) Class Pure subroutine (Elemental subroutine, only when both from and to are type(string_type) ) Argument from : Character scalar or stdlib_string_type .\n  This argument is intent(inout) . to : Character scalar or stdlib_string_type .\n  This argument is intent(inout) when both from and to are type(string_type) ,\n  otherwise intent(out) . Example","tags":"","url":"page/specs/stdlib_string_type.html"},{"title":"stringlist_type – LightConvex","text":"stdlib_stringlist_type module (1-D list of strings) stdlib_stringlist_type module (1-D list of strings) Introduction Derived types provided stringlist_type derived type Status stringlist_index_type derived type Status fidx/bidx Description Syntax Status Class Argument Result value Example Constructor for stringlist_type(or stringlist) Description Syntax Status Class Argument Result value Example insert_at Description Syntax Status Class Argument Example get Description Syntax Status Class Argument Result value Example len Description Syntax Status Class Argument Result value Example clear Description Syntax Status Class Argument Example Comparison operator equal Description Syntax Status Class Argument Result value Example Comparison operator not equal Description Syntax Status Class Argument Result value Example Concatenation operator(//) Description Syntax Status Class Argument Result value Example Introduction The stdlib_stringlist_type module provides with 2 derived types to deal with lists of strings. stringlist_type derived type represents one-dimensional list of variable-length strings (also referred as one-dimensional stringlist) which is compatible with Fortran intrinsic character and stringlist_index_type derived type represents an index to access, modify the elements of a stringlist, insert elements to a stringlist and much more. Derived types provided stringlist_type derived type The stringlist_type derived type represents one-dimensional list of strings (also referred as one-dimensional stringlist). The internal representation of the list is implementation dependent and is not visible to the user of the module. Note: stringlist is an abstract concept which is expressed through the derived type stringlist_type . Status Experimental stringlist_index_type derived type An instance of the derived type stringlist_index_type represents either a forward index OR a backward index. \nThe internal representation is implementation dependent and is not visible to the user of the module. list_head and list_tail are 2 special instances of this type representing the head and the tail of a stringlist respectively.\nAn index is independent of the stringlist(or stringlist_type ) it is used with and hence, an index can be used with multiple stringlists in the same program. Status Experimental fidx/bidx Description fidx : Returns an instance which represents forward index idx . bidx : Returns an instance which represents backward index idx . Syntax For fidx: res = stdlib_stringlist_type (idx) For bidx: res = stdlib_stringlist_type (idx) Status Experimental. Class Pure function. Argument idx : Shall be of kind integer .\n  This argument is intent(in) . Result value The result is of type stringlist_index_type . Example Constructor for stringlist_type (or stringlist) Description No arguments given: Initializes an empty stringlist(a stringlist containing no elements in it). With argument: Initializes a stringlist equivalent to the input array array i.e. a stringlist containing all elements of the input array array in the same order. Syntax res = stdlib_stringlist_type ([array]) Status Experimental Class Pure function. Argument array : Shall be an array of character scalar or array of stdlib_string_type .\n This argument is intent(in) and optional . Result value The result is an instance of type stringlist_type . Example insert_at Description Inserts the string string AT the index idx , so that the newly added element is present at index idx after insertion. Inserting an element AT index beyond length + 1 inserts the element AT list_tail , and likewise inserting AT a non-positive index inserts the element AT list_head . Syntax call stdlib_stringlist_type % stringlist_type (idx, string) Status Experimental. Class Pure subroutine. Argument idx : stdlib_stringlist_type .\n  This argument is intent(in) . string : Character scalar or stdlib_string_type .\n  This argument is intent(in) . Example get Description Returns the string present currently at the index idx in a stringlist. If index idx is out of bounds, then an empty string is returned. Syntax res = stdlib_stringlist_type % stringlist_type (idx) Status Experimental. Class Pure function. Argument idx : stdlib_stringlist_type .\n  This argument is intent(in) . Result value The result is a string of type string_type . Example len Description Returns the number of elements present currently in the stringlist. Syntax res = stdlib_stringlist_type % stringlist_type () Status Experimental. Class Pure function. Argument No arguments. Result value The result is of type integer . Example clear Description Removes all elements from a stringlist. Syntax call stdlib_stringlist_type % stringlist_type () Status Experimental. Class Pure subroutine. Argument No arguments. Example Comparison operator equal Description Compares left hand side (lhs) with right hand side (rhs) for equality. Syntax res = lhs == rhs res = lhs .eq. rhs Status Experimental. Class Pure function, operator(==) and operator(.eq.) . Argument lhs : Shall be an array of character scalar or of stdlib_string_type OR \na stdlib_stringlist_type .\n This argument is intent(in) . rhs : Shall be an array of character scalar or of stdlib_string_type OR \na stdlib_stringlist_type .\n This argument is intent(in) . Result value The result is a default logical scalar value. Example Comparison operator not equal Description Compares left hand side (lhs) with right hand side (rhs) for inequality. Syntax res = lhs /= rhs res = lhs .ne. rhs Status Experimental. Class Pure function, operator(/=) and operator(.ne.) . Argument lhs : Shall be an array of character scalar or of stdlib_string_type OR \na stdlib_stringlist_type .\n This argument is intent(in) . rhs : Shall be an array of character scalar or of stdlib_string_type OR \na stdlib_stringlist_type .\n This argument is intent(in) . Result value The result is a default logical scalar value. Example Concatenation operator(//) Description Returns the concatenated output of left hand side (lhs) and right hand side (rhs). Syntax res = lhs // rhs Status Experimental. Class Pure function, operator(//) . Argument lhs : Shall be a character scalar or stdlib_string_type OR an array of character scalar or of stdlib_string_type OR \na stdlib_stringlist_type .\n This argument is intent(in) . rhs : Shall be a character scalar or stdlib_string_type OR an array of character scalar or of stdlib_string_type OR \na stdlib_stringlist_type .\n This argument is intent(in) . Result value The result is an instance of stdlib_stringlist_type . Example","tags":"","url":"page/specs/stdlib_stringlist_type.html"},{"title":"strings – LightConvex","text":"The stdlib_strings module The stdlib_strings module Introduction Procedures and methods provided strip Description Syntax Status Class Argument Result value Example chomp Description Syntax Status Class Argument Result value Example starts_with Description Syntax Status Class Argument Result value Example ends_with Description Syntax Status Class Argument Result value Example slice Description Syntax Status Class Argument Result value Example find Description Syntax Status Class Argument Result value Example replace_all Description Syntax Status Class Argument Result value Example padl Description Syntax Status Class Argument Result value Example padr Description Syntax Status Class Argument Result value Example count Description Syntax Status Class Argument Result value Example zfill Description Syntax Status Class Argument Result value Example join Description Syntax Status Class Argument Result value Example to_string Description Syntax Status Class Argument Result value Example to_c_char Description Syntax Status Class Argument Result value Example Introduction The stdlib_strings module provides basic string handling and manipulation routines. Procedures and methods provided strip Description Remove leading and trailing whitespace characters. Syntax string = stdlib_strings (string) Status Experimental Class Pure function. Argument string : Character scalar or stdlib_string_type .\n  This argument is intent(in). Result value The result is of the same type as string . Example chomp Description Remove trailing characters in set or substring from string .\nIf no character set or substring is provided trailing whitespace is removed. Syntax string = stdlib_strings (string[, set|substring]) Status Experimental Class Pure function. Argument string : Character scalar or stdlib_string_type .\n  This argument is intent(in). set : Array of length one character. This argument is intent(in). substring : Character scalar or stdlib_string_type .\n  This argument is intent(in). Result value The result is of the same type as string . Example starts_with Description Check if a string starts with a given substring . Syntax string = stdlib_strings (string, substring) Status Experimental Class Pure function. Argument string : Character scalar or stdlib_string_type .\n  This argument is intent(in). substring : Character scalar or stdlib_string_type .\n  This argument is intent(in). Result value The result is of scalar logical type. Example ends_with Description Check if a string ends with a given substring . Syntax string = stdlib_strings (string, substring) Status Experimental Class Pure function. Argument string : Character scalar or stdlib_string_type .\n  This argument is intent(in). substring : Character scalar or stdlib_string_type .\n  This argument is intent(in). Result value The result is of scalar logical type. Example slice Description Extracts the characters from the defined region of the input string by taking strides. Argument first and last defines this region for extraction by function slice . Argument stride defines the magnitude and direction (+/-) of stride to be taken while extraction. stride when given invalid value 0, is converted to +1. Deduction Process: Function first automatically deduces the optional arguments that are not provided by the user. Deduced first and last argument take +infinity or -infinity value and deduced stride argument \ntakes value +1 or -1 depending upon the actual argument(s) provided by the user. Extraction Process: Extraction starts only if last is crossable from first with stride of stride . Extraction starts from the first valid index in the defined region to take stride of stride and ends when the last valid index in the defined region is crossed. If no valid index exists in the defined region, empty string is returned. Syntax string = stdlib_strings (string [, first, last, stride]) Status Experimental Class Pure function. Argument string : Character scalar or stdlib_string_type .\n  This argument is intent(in). first : integer.\n  This argument is intent(in) and optional. last : integer.\n  This argument is intent(in) and optional. stride : integer.\n  This argument is intent(in) and optional. Result value The result is of the same type as string . Example find Description Returns the starting index of the occurrence th occurrence of the substring pattern in the input string string . Default value of occurrence is set to 1 . \nIf consider_overlapping is not provided or is set to .true. the function counts two overlapping occurrences of substring pattern as two different occurrences. If occurrence th occurrence is not found, function returns 0 . Syntax string = stdlib_strings (string, pattern [, occurrence, consider_overlapping]) Status Experimental Class Elemental function Argument string : Character scalar or stdlib_string_type .\n  This argument is intent(in). pattern : Character scalar or stdlib_string_type .\n  This argument is intent(in). occurrence : integer.\n  This argument is intent(in) and optional. consider_overlapping : logical.\n  This argument is intent(in) and optional. Result value The result is a scalar of integer type or an integer array of rank equal to the highest rank among all dummy arguments. Example replace_all Description Replaces all occurrences of substring pattern in the input string with the replacement replacement . Occurrences overlapping on a base occurrence will not be replaced. Syntax string = stdlib_strings (string, pattern, replacement) Status Experimental Class Pure function Argument string : Character scalar or stdlib_string_type .\n  This argument is intent(in). pattern : Character scalar or stdlib_string_type .\n  This argument is intent(in). replacement : Character scalar or stdlib_string_type .\n  This argument is intent(in). Result value The result is of the same type as string . Example padl Description Returns a string of length output_length left padded with pad_with character if it is provided, otherwise with \" \" (1 whitespace). If output_length is less than or equal to the length of string , padding is not performed. Syntax string = stdlib_strings (string, output_length [, pad_with]) Status Experimental Class Pure function Argument string : Character scalar or stdlib_string_type .\n  This argument is intent(in). output_length : integer.\n  This argument is intent(in). pad_with : Character scalar of length 1.\n  This argument is intent(in) and optional. Result value The result is of the same type as string . Example padr Description Returns a string of length output_length right padded with pad_with character if it is provided, otherwise with \" \" (1 whitespace). If output_length is less than or equal to the length of string , padding is not performed. Syntax string = stdlib_strings (string, output_length [, pad_with]) Status Experimental Class Pure function Argument string : Character scalar or stdlib_string_type .\n  This argument is intent(in). output_length : integer.\n  This argument is intent(in). pad_with : Character scalar of length 1.\n  This argument is intent(in) and optional. Result value The result is of the same type as string . Example count Description Returns the number of times the substring pattern has occurred in the input string string . If consider_overlapping is not provided or is set to .true. the function counts two overlapping occurrences of substring pattern as two different occurrences. Syntax string = stdlib_strings (string, pattern [, consider_overlapping]) Status Experimental Class Elemental function Argument string : Character scalar or stdlib_string_type .\n  This argument is intent(in). pattern : Character scalar or stdlib_string_type .\n  This argument is intent(in). consider_overlapping : logical.\n  This argument is intent(in) and optional. Result value The result is a scalar of integer type or an integer array of rank equal to the highest rank among all dummy arguments. Example zfill Description Returns a string of length output_length left-padded with zeros.\nIf output_length is less than or equal to the length of string , padding is not performed. Syntax string = stdlib_strings (string, output_length) Status Experimental Class Pure function Argument string : Character scalar or stdlib_string_type .\n  This argument is intent(in). output_length : integer.\n  This argument is intent(in). Result value The result is of the same type as string . Example join Description Joins an array of strings into a single string. This function concatenates the strings from the input array, \ninserting a separator between each string (default: space). A user-defined separator may be provided, The resulting string is returned. Syntax joined = stdlib_strings (strings, separator) Status Experimental Class Pure function Argument strings : Array of strings (either type(string_type) or character(len=*) ).\n  This argument is intent(in) . It is an array of strings that will be concatenated together. separator : character(len=*) scalar (optional).\n  This argument is intent(in) . It specifies the separator to be used between the strings. If not provided, the default separator (a space) is used. Result value The result is of the same type as the elements of strings ( type(string_type) or character(len=:), allocatable ). Example to_string Description Format or transfer a integer/real/complex/logical scalar as a string. Input a wrong format that cause the internal-IO to fail, the result value is a string of [*] . Syntax string = stdlib_strings (value [, format]) Status Experimental Class Pure function. Argument value : Shall be an integer/real/complex/logical scalar.\n  This is an intent(in) argument. format : Shall be a character(len=*) scalar like '(F6.2)' or just 'F6.2' .\n  This is an intent(in) and optional argument. Contains the edit descriptor to format value into a string, for example '(F6.2)' or '(f6.2)' . to_string will automatically enclose format in a set of parentheses, so passing F6.2 or f6.2 as format is possible as well. Result value The result is an allocatable length character scalar with up to 128 cached character length. Example to_c_char Description Convert a Fortran character string or a type(string_type) variable to a C character array. This function converts a Fortran string into a C-style array of characters, ensuring proper null-termination for use in C functions or libraries. Syntax cstr = stdlib_strings (value) Status Experimental Class Pure function. Argument value : Shall be a character(len=*) string or a type(string_type) variable. It is an intent(in) argument. This Fortran variable will be converted to a C character array. Result value The result is a character(kind=c_char) array with a dimension of len(value) + 1 to accommodate the null terminator. Example","tags":"","url":"page/specs/stdlib_strings.html"},{"title":"system – LightConvex","text":"System and sub-processing module The stdlib_system module provides interface for interacting with external processes, enabling the execution \nand monitoring of system commands or applications directly from Fortran. System and sub-processing module run - Execute an external process synchronously Status Description Syntax Arguments Return Value Example runasync - Execute an external process asynchronously Status Description Syntax Arguments Return Value Example is_running - Check if a process is still running Status Description Syntax Arguments Return Value Example is_completed - Check if a process has completed execution Status Description Syntax Arguments Return Value Example elapsed - Return process lifetime in seconds Status Description Syntax Arguments Return Value Example wait - Wait until a running process is completed Status Description Syntax Arguments Example update - Update the internal state of a process Status Description Syntax Arguments Example kill - Terminate a running process Status Description Syntax Arguments Example sleep - Pause execution for a specified time in milliseconds Status Description Syntax Arguments Example is_windows - Check if the system is running on Windows Status Description Syntax Return Value Example get_runtime_os - Determine the OS type at runtime Status Description Syntax Class Arguments Return Value Example OS_TYPE - Cached OS type retrieval Status Description Syntax Class Arguments Return Value Example FS_ERROR - Helper function for error handling Status Description Syntax Class Arguments Behavior Return values Example FS_ERROR_CODE - Helper function for error handling (with error code) Status Description Syntax Class Arguments Behavior Return values Example is_directory - Test if a path is a directory Status Description Syntax Class Arguments Return values Example make_directory - Creates an empty directory Status Description Syntax Class Arguments Return values Example make_directory_all - Creates an empty directory with all its parent directories Status Description Syntax Class Arguments Return values Example remove_directory - Removes an empty directory Status Description Syntax Class Arguments Return values Example null_device - Return the null device file path Status Description Syntax Class Arguments Return Value Example delete_file - Delete a file Status Description Syntax Class Arguments Behavior Return values Example join_path - Joins the provided paths according to the OS Status Description Syntax Class Arguments Return values operator(/) Status Syntax Class Arguments Result value Example split_path - splits a path immediately following the last separator Status Description Syntax Class Arguments Behavior Return values Example base_name - The last part of a path Status Description Syntax Class Arguments Behavior Return values Example dir_name - Everything except the last part of the path Status Description Syntax Class Arguments Behavior Return values Example run - Execute an external process synchronously Status Experimental Description The run interface allows execution of external processes using a single command string or a list of arguments. Processes run synchronously, meaning execution is blocked until the process finishes. Optional arguments enable the collection of standard output and error streams, as well as sending input via standard input. \nAdditionally, a callback function can be specified to execute upon process completion, optionally receiving a user-defined payload. Syntax process = stdlib_system (args [, stdin] [, want_stdout] [, want_stderr] [, callback] [, payload]) Arguments args : Shall be a character(*) string (for command-line execution) or a character(*), dimension(:) array (for argument-based execution). It specifies the command and arguments to execute. This is an intent(in) argument. stdin (optional): Shall be a character(*) value containing input to send to the process via standard input (pipe). This is an intent(in) argument. want_stdout (optional): Shall be a logical flag. If .true. , the standard output of the process will be captured; if .false. (default), it will be lost. This is an intent(in) argument. want_stderr (optional): Shall be a logical flag. If .true. , the standard error output of the process will be captured. If .false. (default), it will be lost. This is an intent(in) argument. callback (optional): Shall be a procedure conforming to the process_callback interface. If present, this function will be called upon process completion with the process ID, exit state, and optionally collected standard input, output, and error streams. This is an intent(in) argument. payload (optional): Shall be a generic ( class(*) ) scalar that will be passed to the callback function upon process completion. It allows users to associate custom data with the process execution. This is an intent(inout), target argument. Return Value Returns an object of type process_type that contains information about the state of the created process. Example ! Example usage with command line or list of arguments type ( process_type ) :: p ! Run a simple command line synchronously p = run ( \"echo 'Hello, world!'\" , want_stdout = . true .) runasync - Execute an external process asynchronously Status Experimental Description The runasync interface allows execution of external processes using a single command string or a list of arguments. Processes are run asynchronously (non-blocking), meaning execution does not wait for the process to finish. Optional arguments enable the collection of standard output and error streams, as well as sending input via standard input.\nAdditionally, a callback function can be specified to execute upon process completion, optionally receiving a user-defined payload. Syntax process = stdlib_system (args [, stdin] [, want_stdout] [, want_stderr] [, callback] [, payload]) Arguments args : Shall be a character(*) string (for command-line execution) or a character(*), dimension(:) array (for argument-based execution). It specifies the command and arguments to execute. This is an intent(in) argument. stdin (optional): Shall be a character(*) value containing input to send to the process via standard input (pipe). This is an intent(in) argument. want_stdout (optional): Shall be a logical flag. If .true. , the standard output of the process will be captured; if .false. (default), it will be lost. This is an intent(in) argument. want_stderr (optional): Shall be a logical flag. If .true. , the standard error output of the process will be captured. Default: .false. . This is an intent(in) argument. callback (optional): Shall be a procedure conforming to the process_callback interface. If present, this function will be called upon process completion with the process ID, exit state, and optionally collected standard input, output, and error streams. This is an intent(in) argument. payload (optional): Shall be a generic ( class(*) ) scalar that will be passed to the callback function upon process completion. It allows users to associate custom data with the process execution. This is an intent(inout), target argument. Return Value Returns an object of type process_type that contains information about the state of the created process. Example is_running - Check if a process is still running Status Experimental Description The is_running interface provides a method to check if an external process is still running. This is useful for monitoring the status of asynchronous processes created with the run interface. Syntax status = stdlib_system (process) Arguments process :  Shall be a type(process_type) object representing the external process to check. This is an intent(inout) argument. Return Value Returns a logical value: .true. if the process is still running, or .false. if the process has terminated.\nAfter a call to is_running , the type(process_type) structure is also updated to the latest process state. Example is_completed - Check if a process has completed execution Status Experimental Description The is_completed interface provides a method to check if an external process has finished execution. This is useful for determining whether asynchronous processes created with the run interface have terminated. Syntax status = stdlib_system (process) Arguments process : Shall be a type(process_type) object representing the external process to check. This is an intent(inout) argument. Return Value Returns a logical value: - .true. if the process has completed. - .false. if the process is still running. After a call to is_completed , the type(process_type) structure is updated to reflect the latest process state. Example elapsed - Return process lifetime in seconds Status Experimental Description The elapsed interface provides a method to calculate the total time that has elapsed since a process was started. This is useful for tracking the duration of an external process or for performance monitoring purposes. The result is a real value representing the elapsed time in seconds, measured from the time the process was created. Syntax delta_t = stdlib_system (process) Arguments process : Shall be a type(process_type) object representing the external process. It is an intent(in) argument. Return Value Returns a real(real64) value that represents the elapsed time (in seconds) since the process was started. If the process is still running, the value returned is the time elapsed until the call to this function. \nOtherwise, the total process duration from creation until completion is returned. Example wait - Wait until a running process is completed Status Experimental Description The wait interface provides a method to block the calling program until the specified process completes. If the process is running asynchronously, this subroutine will pause the workflow until the given process finishes. Additionally, an optional maximum wait time can be provided. If the process does not finish within the specified time, \nthe subroutine will return without waiting further. On return from this routine, the process state is accordingly updated.\nThis is useful when you want to wait for a background task to complete, but want to avoid indefinite blocking \nin case of process hang or delay. Syntax call stdlib_system (process [, max_wait_time]) Arguments process : Shall be a type(process_type) object representing the external process to monitor. This is an intent(inout) argument, and its state is updated upon completion. max_wait_time (optional): Shall be a real value specifying the maximum wait time in seconds. If not provided, the subroutine will wait indefinitely until the process completes. Example update - Update the internal state of a process Status Experimental Description The update interface allows the internal state of a process object to be updated by querying the system. After the process completes, the standard output and standard error are retrieved, if they were requested, and loaded into the process%stdout and process%stderr string variables, respectively. This is especially useful for monitoring asynchronous processes and retrieving their output after they have finished. Syntax call stdlib_system (process) Arguments process : Shall be a type(process_type) object representing the external process whose state needs to be updated. This is an intent(inout) argument, and its internal state is updated on completion. Example kill - Terminate a running process Status Experimental Description The kill interface is used to terminate a running external process. It attempts to stop the process and returns a boolean flag indicating whether the operation was successful.\nThis interface is useful when a process needs to be forcefully stopped, for example, if it becomes unresponsive or if its execution is no longer required. Syntax call stdlib_system (process, success) Arguments process : Shall be a type(process_type) object representing the external process to be terminated. This is an intent(inout) argument, and on return is updated with the terminated process state. success : Shall be a logical variable. It is set to .true. if the process was successfully killed, or .false. otherwise. Example sleep - Pause execution for a specified time in milliseconds Status Experimental Description The sleep interface pauses the execution of a program for a specified duration, given in milliseconds. \nThis routine acts as a cross-platform wrapper, abstracting the underlying platform-specific sleep implementations. \nIt ensures that the requested sleep duration is honored on both Windows and Unix-like systems. Syntax call stdlib_system (millisec) Arguments millisec : Shall be an integer representing the number of milliseconds to sleep. This is an intent(in) argument. Example is_windows - Check if the system is running on Windows Status Experimental Description The is_windows interface provides a quick, compile-time check to determine if the current system is Windows. \nIt leverages a C function that checks for the presence of the _WIN32 macro, which is defined in C compilers when targeting Windows. \nThis function is highly efficient and works during the compilation phase, avoiding the need for runtime checks. Syntax result = stdlib_system () Return Value Returns a logical flag: .true. if the system is Windows, or .false. otherwise. Example get_runtime_os - Determine the OS type at runtime Status Experimental Description get_runtime_os inspects the runtime environment to identify the current OS type. It evaluates environment variables ( OSTYPE , OS ) and checks for specific files associated with known operating systems.\nThe supported OS types are integer, parameter variables stored in the stdlib_system module: Linux ( OS_LINUX ) macOS ( OS_MACOS ) Windows ( OS_WINDOWS ) Cygwin ( OS_CYGWIN ) Solaris ( OS_SOLARIS ) FreeBSD ( OS_FREEBSD ) OpenBSD ( OS_OPENBSD ) If the OS cannot be identified, the function returns OS_UNKNOWN . Syntax os = stdlib_system () Class Function Arguments None. Return Value Returns one of the integer OS_* parameters representing the OS type, from the stdlib_system module, or OS_UNKNOWN if undetermined. Example OS_TYPE - Cached OS type retrieval Status Experimental Description OS_TYPE provides a cached result of the get_runtime_os function. The OS type is determined during the first invocation and stored in a static variable. \nSubsequent calls reuse the cached value, making this function highly efficient. This caching mechanism ensures negligible overhead for repeated calls, unlike get_runtime_os , which performs a full runtime inspection. Syntax os = stdlib_system () Class Function Arguments None. Return Value Returns one of the integer OS_* parameters representing the OS type, from the stdlib_system module, or OS_UNKNOWN if undetermined. Example FS_ERROR - Helper function for error handling Status Experimental Description A helper function for returning the type(state_type) with the flag STDLIB_FS_ERROR set. Syntax err = FS_ERROR([a1,a2,a3,a4...... a20]) Class Pure Function Arguments a1,a2,a3.....a20 (optional): They are of type class(*), dimension(..), optional, intent(in) . \nAn arbitrary list of integer , real , complex , character or string_type variables. Numeric variables may be provided as either scalars or rank-1 (array) inputs. Behavior Formats all the arguments into a nice error message, utilizing the constructor of stdlib_system Return values type(state_type) Example FS_ERROR_CODE - Helper function for error handling (with error code) Status Experimental Description A helper function for returning the type(state_type) with the flag STDLIB_FS_ERROR set.\nIt also formats and prefixes the code passed to it as the first argument. Syntax err = FS_ERROR_CODE(code [, a1,a2,a3,a4...... a19]) Class Pure Function Arguments code : An integer code. a1,a2,a3.....a19 (optional): They are of type class(*), dimension(..), optional, intent(in) .\nAn arbitrary list of integer , real , complex , character or string_type variables. Numeric variables may be provided as either scalars or rank-1 (array) inputs. Behavior Formats all the arguments into a nice error message, utilizing the constructor of stdlib_system Return values type(state_type) Example is_directory - Test if a path is a directory Status Experimental Description This function checks if a specified file system path is a directory. \nIt is designed to work across multiple platforms. On Windows, paths with both forward / and backward \\ slashes are accepted. Syntax result = stdlib_system (path) Class Function Arguments path : Shall be a character string containing the file system path to evaluate. It is an intent(in) argument. Return values The function returns a logical value: .true. if the path matches an existing directory. .false. otherwise, or if the operating system is unsupported. Example make_directory - Creates an empty directory Status Experimental Description It creates an empty directory with default permissions.\nIt is designed to work across multiple platforms. On Windows, paths with both forward / and backward \\ slashes are accepted. Syntax call [[stdlib_system(module):make_directory(subroutine)]] (path [,err]) Class Subroutine Arguments path : Shall be a character string containing the path of the directory to create. It is an intent(in) argument. err (optional): Shall be of type state_type , and is used for error handling. It is an optional, intent(out) argument. Return values err is an optional state return flag. If not requested and an error occurs, an FS_ERROR will trigger an error stop. Example make_directory_all - Creates an empty directory with all its parent directories Status Experimental Description It creates an empty directory with default permissions.\nIt also creates all the necessary parent directories in the path if they do not exist already. Syntax call [[stdlib_system(module):make_directory_all(subroutine)]] (path [,err]) Class Subroutine Arguments path : Shall be a character string containing the path of the directory to create. It is an intent(in) argument. err (optional): Shall be of type state_type , and is used for error handling. It is an optional, intent(out) argument. Return values err is an optional state return flag. If not requested and an error occurs, an FS_ERROR will trigger an error stop. Example remove_directory - Removes an empty directory Status Experimental Description It deletes an empty directory.\nIt is designed to work across multiple platforms. On Windows, paths with both forward / and backward \\ slashes are accepted. Syntax call [[stdlib_system(module):remove_directory(subroutine)]] (path, err) Class Subroutine Arguments path : Shall be a character string containing the path of the directory to create. It is an intent(in) argument. err (optional): Shall be of type state_type , and is used for error handling. It is an optional, intent(out) argument. Return values err is an optional state return flag. On error if not requested, an FS_ERROR will trigger an error stop. Example null_device - Return the null device file path Status Experimental Description This function returns the file path of the null device, which is a special file used to discard any data written to it. \nIt reads as an empty file. The null device's path varies by operating system:\n- On Windows, the null device is represented as NUL .\n- On UNIX-like systems (Linux, macOS), the null device is represented as /dev/null . Syntax path = stdlib_system () Class Function Arguments None. Return Value Type: character(:), allocatable Returns the null device file path as a character string, appropriate for the operating system. Example delete_file - Delete a file Status Experimental Description This subroutine deletes a specified file from the filesystem. It ensures that the file exists and is not a directory before attempting deletion.\nIf the file cannot be deleted due to permissions, being a directory, or other issues, an error is raised. \nThe function provides an optional error-handling mechanism via the state_type class. If the err argument is not provided, exceptions will trigger an error stop . Syntax call stdlib_system (path [, err]) Class Subroutine Arguments path : Shall be a character string containing the path to the file to be deleted. It is an intent(in) argument. err (optional): Shall be a type(state_type) variable for error handling. If provided, errors are returned as a state object. If not provided, the program stops execution on error. Behavior Checks if the file exists. If not, an error is raised. Ensures the path is not a directory before deletion. Attempts to delete the file, raising an error if unsuccessful. Return values The file is removed from the filesystem if the operation is successful. If the operation fails, an error is raised. Example join_path - Joins the provided paths according to the OS Status Experimental Description This interface joins the paths provided to it according to the platform specific path-separator.\ni.e \\ for windows and / for others Syntax res = stdlib_system (p1, p2) res = stdlib_system (p) Class Pure function Arguments p1, p2 : Shall be a character string or type(string_type) . It is an intent(in) argument.\n    or p : Shall be a list of character strings or list of type(string_type) . It is an intent(in) argument. Return values The resultant path, either a character string or type(string_type) . operator(/) Alternative syntax to join_path using an overloaded operator. Join two paths according to the platform specific path-separator. Status Experimental Syntax p = lval / rval Class Pure function. Arguments lval : A character string or type(string_type) . It is an intent(in) argument. rval : A character string or type(string_type) . It is an intent(in) argument. Result value The result is an allocatable character string or type(string_type) Example split_path - splits a path immediately following the last separator Status Experimental Description This subroutine splits a path immediately following the last separator after removing the trailing separators\nsplitting it into most of the times a directory and a file name. Syntax call stdlib_system (p, head, tail) Class Subroutine Arguments p : A character string or type(string_type) containing the path to be split. It is an intent(in) argument. head : The first part of the path. Either a character string or type(string_type) . It is an intent(out) argument. tail : The rest part of the path. Either a character string or type(string_type) . It is an intent(out) argument. Behavior If p is empty, head is set to . and tail is left empty. If p consists entirely of path-separators, head is set to the path-separator and tail is left empty. head ends with a path-separator if and only if p appears to be a root directory or child of one. Return values The splitted path. head and tail . Example base_name - The last part of a path Status Experimental Description This function returns the last part of a path after removing trailing path separators. Syntax res = stdlib_system (p) Class Function Arguments p : the path, a character string or type(string_type) . It is an intent(in) argument. Behavior The tail of [[stdlib_system(module):split_path(interface)]] is exactly what is returned. Same Behavior. Return values A character string or type(string_type) . Example dir_name - Everything except the last part of the path Status Experimental Description This function returns everything except the last part of a path. Syntax res = stdlib_system (p) Class Function Arguments p : the path, a character string or type(string_type) . It is an intent(in) argument. Behavior The head of [[stdlib_system(module):split_path(interface)]] is exactly what is returned. Same Behavior. Return values A character string or type(string_type) . Example","tags":"","url":"page/specs/stdlib_system.html"},{"title":"version – LightConvex","text":"The stdlib_version module The stdlib_version module Introduction Constants provided by stdlib_version stdlib_version_string stdlib_version_compact get_stdlib_version Status Description Syntax Class Argument Example Introduction The stdlib_version module contains the version of the standard library.\nThe version information can be used as a compile time constant or retrieved from a getter function at runtime.\nIn case the standard library is dynamically linked, the version number retrieved from the getter might mismatch the compile time constants provided from the version built against.\nTherefore, it is recommended to retrieve the version information always at runtime. Constants provided by stdlib_version stdlib_version_string String constant representing the version number. stdlib_version_compact Compact representation of the version string following the scheme:\nmajor * 10000 + minor * 100 + patch. get_stdlib_version Status Experimental Description Getter function to retrieve version information Syntax res = stdlib_version ([major], [minor], [patch], [string]) Class Pure subroutine. Argument major : shall be an intrinsic integer type. It is an optional, intent(out) argument. minor : shall be an intrinsic integer type. It is an optional, intent(out) argument. patch : shall be an intrinsic integer type. It is an optional, intent(out) argument. string : shall be a deferred length character type. It is an optional, intent(out) argument. Example","tags":"","url":"page/specs/stdlib_version.html"}]}